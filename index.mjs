import * as pn from "react";
import yt, { createContext as Ui, useContext as It, forwardRef as Yt, useMemo as pe, useRef as ge, useCallback as Ie, useEffect as be, useState as Le, Fragment as Tt, createElement as Xl, useReducer as Lc, useLayoutEffect as t8, memo as n8, cloneElement as r8 } from "react";
import * as ia from "react/jsx-runtime";
import { jsx as q, jsxs as Pc } from "react/jsx-runtime";
import { FrameContent as i8, ImageContent as o8, LineContent as s8, RootContent as a8, ShapeContent as l8, SvgContent as c8, TextContent as u8, VideoContent as d8, getTransformStyle as ut, visualCorners as oi, isPointInsideBox as Jl, boundingRect as hr, rectangleInsideAnother as M1, getControlBoxSizeFromLayers as oa, isIntersection as g0, distanceBetweenPoints as Hs, horizontalAndVerticalChange as f8, angleBetweenPoints as h8, useResize as p8, positionOfObjectInsideAnother as R1, scalePath as g8, useEventCallback as m8, getTextEffectStyle as m0, useResizeLayer as v8, useDragLine as y8, useRotateLayer as w8, autoCorrectDegree as b8, getImageSize as x8, getVideoSize as S8, getVirtualDomHeight as D1, GlobalStyle as I1, isElementInViewport as v0, getPositionWhenLayerCenter as ao, getGradientBackground as Ql, getPositionChangesBetweenTwoCorners as y0 } from "@lidojs/design-core";
import { modifiers as Hl, normalizeKeyName as Bt, useLinkedRef as Pi, getPosition as Wt, useForwardedRef as _c, mergeWithoutArray as cr, isMouseEvent as w0, isTouchEvent as b0, Color as Nt, hex2rgbString as pf } from "@lidojs/design-utils";
import A1, { unstable_batchedUpdates as zs, createPortal as L1 } from "react-dom";
import { ColorPicker as ec, ColorIcon as qs } from "@lidojs/color-picker";
const di = Ui({}), je = (n) => {
  const e = It(di), { actions: t, getState: r, query: i } = e;
  return {
    ...n ? n(e.getState(), i) : {},
    actions: t,
    query: i,
    state: r()
  };
};
function C8(n) {
  if (n.sheet)
    return n.sheet;
  for (var e = 0; e < document.styleSheets.length; e++)
    if (document.styleSheets[e].ownerNode === n)
      return document.styleSheets[e];
}
function E8(n) {
  var e = document.createElement("style");
  return e.setAttribute("data-emotion", n.key), n.nonce !== void 0 && e.setAttribute("nonce", n.nonce), e.appendChild(document.createTextNode("")), e.setAttribute("data-s", ""), e;
}
var k8 = /* @__PURE__ */ function() {
  function n(t) {
    var r = this;
    this._insertTag = function(i) {
      var o;
      r.tags.length === 0 ? r.insertionPoint ? o = r.insertionPoint.nextSibling : r.prepend ? o = r.container.firstChild : o = r.before : o = r.tags[r.tags.length - 1].nextSibling, r.container.insertBefore(i, o), r.tags.push(i);
    }, this.isSpeedy = t.speedy === void 0 ? process.env.NODE_ENV === "production" : t.speedy, this.tags = [], this.ctr = 0, this.nonce = t.nonce, this.key = t.key, this.container = t.container, this.prepend = t.prepend, this.insertionPoint = t.insertionPoint, this.before = null;
  }
  var e = n.prototype;
  return e.hydrate = function(r) {
    r.forEach(this._insertTag);
  }, e.insert = function(r) {
    this.ctr % (this.isSpeedy ? 65e3 : 1) === 0 && this._insertTag(E8(this));
    var i = this.tags[this.tags.length - 1];
    if (process.env.NODE_ENV !== "production") {
      var o = r.charCodeAt(0) === 64 && r.charCodeAt(1) === 105;
      o && this._alreadyInsertedOrderInsensitiveRule && console.error(`You're attempting to insert the following rule:
` + r + "\n\n`@import` rules must be before all other types of rules in a stylesheet but other rules have already been inserted. Please ensure that `@import` rules are before all other rules."), this._alreadyInsertedOrderInsensitiveRule = this._alreadyInsertedOrderInsensitiveRule || !o;
    }
    if (this.isSpeedy) {
      var a = C8(i);
      try {
        a.insertRule(r, a.cssRules.length);
      } catch (l) {
        process.env.NODE_ENV !== "production" && !/:(-moz-placeholder|-moz-focus-inner|-moz-focusring|-ms-input-placeholder|-moz-read-write|-moz-read-only|-ms-clear|-ms-expand|-ms-reveal){/.test(r) && console.error('There was a problem inserting the following rule: "' + r + '"', l);
      }
    } else
      i.appendChild(document.createTextNode(r));
    this.ctr++;
  }, e.flush = function() {
    this.tags.forEach(function(r) {
      return r.parentNode && r.parentNode.removeChild(r);
    }), this.tags = [], this.ctr = 0, process.env.NODE_ENV !== "production" && (this._alreadyInsertedOrderInsensitiveRule = !1);
  }, n;
}(), cn = "-ms-", tc = "-moz-", at = "-webkit-", Kf = "comm", Xf = "rule", Jf = "decl", O8 = "@import", P1 = "@keyframes", T8 = "@layer", M8 = Math.abs, Nc = String.fromCharCode, R8 = Object.assign;
function D8(n, e) {
  return tn(n, 0) ^ 45 ? (((e << 2 ^ tn(n, 0)) << 2 ^ tn(n, 1)) << 2 ^ tn(n, 2)) << 2 ^ tn(n, 3) : 0;
}
function _1(n) {
  return n.trim();
}
function I8(n, e) {
  return (n = e.exec(n)) ? n[0] : n;
}
function lt(n, e, t) {
  return n.replace(e, t);
}
function gf(n, e) {
  return n.indexOf(e);
}
function tn(n, e) {
  return n.charCodeAt(e) | 0;
}
function sa(n, e, t) {
  return n.slice(e, t);
}
function Nr(n) {
  return n.length;
}
function Qf(n) {
  return n.length;
}
function Ml(n, e) {
  return e.push(n), n;
}
function A8(n, e) {
  return n.map(e).join("");
}
var zc = 1, ss = 1, N1 = 0, Nn = 0, Ft = 0, ps = "";
function Bc(n, e, t, r, i, o, a) {
  return { value: n, root: e, parent: t, type: r, props: i, children: o, line: zc, column: ss, length: a, return: "" };
}
function Bs(n, e) {
  return R8(Bc("", null, null, "", null, null, 0), n, { length: -n.length }, e);
}
function L8() {
  return Ft;
}
function P8() {
  return Ft = Nn > 0 ? tn(ps, --Nn) : 0, ss--, Ft === 10 && (ss = 1, zc--), Ft;
}
function Kn() {
  return Ft = Nn < N1 ? tn(ps, Nn++) : 0, ss++, Ft === 10 && (ss = 1, zc++), Ft;
}
function Vr() {
  return tn(ps, Nn);
}
function $l() {
  return Nn;
}
function Ea(n, e) {
  return sa(ps, n, e);
}
function aa(n) {
  switch (n) {
    case 0:
    case 9:
    case 10:
    case 13:
    case 32:
      return 5;
    case 33:
    case 43:
    case 44:
    case 47:
    case 62:
    case 64:
    case 126:
    case 59:
    case 123:
    case 125:
      return 4;
    case 58:
      return 3;
    case 34:
    case 39:
    case 40:
    case 91:
      return 2;
    case 41:
    case 93:
      return 1;
  }
  return 0;
}
function z1(n) {
  return zc = ss = 1, N1 = Nr(ps = n), Nn = 0, [];
}
function B1(n) {
  return ps = "", n;
}
function Ul(n) {
  return _1(Ea(Nn - 1, mf(n === 91 ? n + 2 : n === 40 ? n + 1 : n)));
}
function _8(n) {
  for (; (Ft = Vr()) && Ft < 33; )
    Kn();
  return aa(n) > 2 || aa(Ft) > 3 ? "" : " ";
}
function N8(n, e) {
  for (; --e && Kn() && !(Ft < 48 || Ft > 102 || Ft > 57 && Ft < 65 || Ft > 70 && Ft < 97); )
    ;
  return Ea(n, $l() + (e < 6 && Vr() == 32 && Kn() == 32));
}
function mf(n) {
  for (; Kn(); )
    switch (Ft) {
      case n:
        return Nn;
      case 34:
      case 39:
        n !== 34 && n !== 39 && mf(Ft);
        break;
      case 40:
        n === 41 && mf(n);
        break;
      case 92:
        Kn();
        break;
    }
  return Nn;
}
function z8(n, e) {
  for (; Kn() && n + Ft !== 47 + 10; )
    if (n + Ft === 42 + 42 && Vr() === 47)
      break;
  return "/*" + Ea(e, Nn - 1) + "*" + Nc(n === 47 ? n : Kn());
}
function B8(n) {
  for (; !aa(Vr()); )
    Kn();
  return Ea(n, Nn);
}
function F8(n) {
  return B1(Zl("", null, null, null, [""], n = z1(n), 0, [0], n));
}
function Zl(n, e, t, r, i, o, a, l, u) {
  for (var d = 0, h = 0, p = a, g = 0, v = 0, m = 0, w = 1, b = 1, C = 1, M = 0, k = "", D = i, T = o, R = r, _ = k; b; )
    switch (m = M, M = Kn()) {
      case 40:
        if (m != 108 && tn(_, p - 1) == 58) {
          gf(_ += lt(Ul(M), "&", "&\f"), "&\f") != -1 && (C = -1);
          break;
        }
      case 34:
      case 39:
      case 91:
        _ += Ul(M);
        break;
      case 9:
      case 10:
      case 13:
      case 32:
        _ += _8(m);
        break;
      case 92:
        _ += N8($l() - 1, 7);
        continue;
      case 47:
        switch (Vr()) {
          case 42:
          case 47:
            Ml(V8(z8(Kn(), $l()), e, t), u);
            break;
          default:
            _ += "/";
        }
        break;
      case 123 * w:
        l[d++] = Nr(_) * C;
      case 125 * w:
      case 59:
      case 0:
        switch (M) {
          case 0:
          case 125:
            b = 0;
          case 59 + h:
            C == -1 && (_ = lt(_, /\f/g, "")), v > 0 && Nr(_) - p && Ml(v > 32 ? S0(_ + ";", r, t, p - 1) : S0(lt(_, " ", "") + ";", r, t, p - 2), u);
            break;
          case 59:
            _ += ";";
          default:
            if (Ml(R = x0(_, e, t, d, h, i, l, k, D = [], T = [], p), o), M === 123)
              if (h === 0)
                Zl(_, e, R, R, D, o, p, l, T);
              else
                switch (g === 99 && tn(_, 3) === 110 ? 100 : g) {
                  case 100:
                  case 108:
                  case 109:
                  case 115:
                    Zl(n, R, R, r && Ml(x0(n, R, R, 0, 0, i, l, k, i, D = [], p), T), i, T, p, l, r ? D : T);
                    break;
                  default:
                    Zl(_, R, R, R, [""], T, 0, l, T);
                }
        }
        d = h = v = 0, w = C = 1, k = _ = "", p = a;
        break;
      case 58:
        p = 1 + Nr(_), v = m;
      default:
        if (w < 1) {
          if (M == 123)
            --w;
          else if (M == 125 && w++ == 0 && P8() == 125)
            continue;
        }
        switch (_ += Nc(M), M * w) {
          case 38:
            C = h > 0 ? 1 : (_ += "\f", -1);
            break;
          case 44:
            l[d++] = (Nr(_) - 1) * C, C = 1;
            break;
          case 64:
            Vr() === 45 && (_ += Ul(Kn())), g = Vr(), h = p = Nr(k = _ += B8($l())), M++;
            break;
          case 45:
            m === 45 && Nr(_) == 2 && (w = 0);
        }
    }
  return o;
}
function x0(n, e, t, r, i, o, a, l, u, d, h) {
  for (var p = i - 1, g = i === 0 ? o : [""], v = Qf(g), m = 0, w = 0, b = 0; m < r; ++m)
    for (var C = 0, M = sa(n, p + 1, p = M8(w = a[m])), k = n; C < v; ++C)
      (k = _1(w > 0 ? g[C] + " " + M : lt(M, /&\f/g, g[C]))) && (u[b++] = k);
  return Bc(n, e, t, i === 0 ? Xf : l, u, d, h);
}
function V8(n, e, t) {
  return Bc(n, e, t, Kf, Nc(L8()), sa(n, 2, -2), 0);
}
function S0(n, e, t, r) {
  return Bc(n, e, t, Jf, sa(n, 0, r), sa(n, r + 1, -1), r);
}
function Qo(n, e) {
  for (var t = "", r = Qf(n), i = 0; i < r; i++)
    t += e(n[i], i, n, e) || "";
  return t;
}
function W8(n, e, t, r) {
  switch (n.type) {
    case T8:
      if (n.children.length)
        break;
    case O8:
    case Jf:
      return n.return = n.return || n.value;
    case Kf:
      return "";
    case P1:
      return n.return = n.value + "{" + Qo(n.children, r) + "}";
    case Xf:
      n.value = n.props.join(",");
  }
  return Nr(t = Qo(n.children, r)) ? n.return = n.value + "{" + t + "}" : "";
}
function H8(n) {
  var e = Qf(n);
  return function(t, r, i, o) {
    for (var a = "", l = 0; l < e; l++)
      a += n[l](t, r, i, o) || "";
    return a;
  };
}
function $8(n) {
  return function(e) {
    e.root || (e = e.return) && n(e);
  };
}
function U8(n) {
  var e = /* @__PURE__ */ Object.create(null);
  return function(t) {
    return e[t] === void 0 && (e[t] = n(t)), e[t];
  };
}
var Z8 = function(e, t, r) {
  for (var i = 0, o = 0; i = o, o = Vr(), i === 38 && o === 12 && (t[r] = 1), !aa(o); )
    Kn();
  return Ea(e, Nn);
}, j8 = function(e, t) {
  var r = -1, i = 44;
  do
    switch (aa(i)) {
      case 0:
        i === 38 && Vr() === 12 && (t[r] = 1), e[r] += Z8(Nn - 1, t, r);
        break;
      case 2:
        e[r] += Ul(i);
        break;
      case 4:
        if (i === 44) {
          e[++r] = Vr() === 58 ? "&\f" : "", t[r] = e[r].length;
          break;
        }
      default:
        e[r] += Nc(i);
    }
  while (i = Kn());
  return e;
}, Y8 = function(e, t) {
  return B1(j8(z1(e), t));
}, C0 = /* @__PURE__ */ new WeakMap(), q8 = function(e) {
  if (!(e.type !== "rule" || !e.parent || // positive .length indicates that this rule contains pseudo
  // negative .length indicates that this rule has been already prefixed
  e.length < 1)) {
    for (var t = e.value, r = e.parent, i = e.column === r.column && e.line === r.line; r.type !== "rule"; )
      if (r = r.parent, !r)
        return;
    if (!(e.props.length === 1 && t.charCodeAt(0) !== 58 && !C0.get(r)) && !i) {
      C0.set(e, !0);
      for (var o = [], a = Y8(t, o), l = r.props, u = 0, d = 0; u < a.length; u++)
        for (var h = 0; h < l.length; h++, d++)
          e.props[d] = o[u] ? a[u].replace(/&\f/g, l[h]) : l[h] + " " + a[u];
    }
  }
}, G8 = function(e) {
  if (e.type === "decl") {
    var t = e.value;
    // charcode for l
    t.charCodeAt(0) === 108 && // charcode for b
    t.charCodeAt(2) === 98 && (e.return = "", e.value = "");
  }
}, K8 = "emotion-disable-server-rendering-unsafe-selector-warning-please-do-not-use-this-the-warning-exists-for-a-reason", X8 = function(e) {
  return e.type === "comm" && e.children.indexOf(K8) > -1;
}, J8 = function(e) {
  return function(t, r, i) {
    if (!(t.type !== "rule" || e.compat)) {
      var o = t.value.match(/(:first|:nth|:nth-last)-child/g);
      if (o) {
        for (var a = !!t.parent, l = a ? t.parent.children : (
          // global rule at the root level
          i
        ), u = l.length - 1; u >= 0; u--) {
          var d = l[u];
          if (d.line < t.line)
            break;
          if (d.column < t.column) {
            if (X8(d))
              return;
            break;
          }
        }
        o.forEach(function(h) {
          console.error('The pseudo class "' + h + '" is potentially unsafe when doing server-side rendering. Try changing it to "' + h.split("-child")[0] + '-of-type".');
        });
      }
    }
  };
}, F1 = function(e) {
  return e.type.charCodeAt(1) === 105 && e.type.charCodeAt(0) === 64;
}, Q8 = function(e, t) {
  for (var r = e - 1; r >= 0; r--)
    if (!F1(t[r]))
      return !0;
  return !1;
}, E0 = function(e) {
  e.type = "", e.value = "", e.return = "", e.children = "", e.props = "";
}, eO = function(e, t, r) {
  F1(e) && (e.parent ? (console.error("`@import` rules can't be nested inside other rules. Please move it to the top level and put it before regular rules. Keep in mind that they can only be used within global styles."), E0(e)) : Q8(t, r) && (console.error("`@import` rules can't be after other rules. Please put your `@import` rules before your other rules."), E0(e)));
};
function V1(n, e) {
  switch (D8(n, e)) {
    case 5103:
      return at + "print-" + n + n;
    case 5737:
    case 4201:
    case 3177:
    case 3433:
    case 1641:
    case 4457:
    case 2921:
    case 5572:
    case 6356:
    case 5844:
    case 3191:
    case 6645:
    case 3005:
    case 6391:
    case 5879:
    case 5623:
    case 6135:
    case 4599:
    case 4855:
    case 4215:
    case 6389:
    case 5109:
    case 5365:
    case 5621:
    case 3829:
      return at + n + n;
    case 5349:
    case 4246:
    case 4810:
    case 6968:
    case 2756:
      return at + n + tc + n + cn + n + n;
    case 6828:
    case 4268:
      return at + n + cn + n + n;
    case 6165:
      return at + n + cn + "flex-" + n + n;
    case 5187:
      return at + n + lt(n, /(\w+).+(:[^]+)/, at + "box-$1$2" + cn + "flex-$1$2") + n;
    case 5443:
      return at + n + cn + "flex-item-" + lt(n, /flex-|-self/, "") + n;
    case 4675:
      return at + n + cn + "flex-line-pack" + lt(n, /align-content|flex-|-self/, "") + n;
    case 5548:
      return at + n + cn + lt(n, "shrink", "negative") + n;
    case 5292:
      return at + n + cn + lt(n, "basis", "preferred-size") + n;
    case 6060:
      return at + "box-" + lt(n, "-grow", "") + at + n + cn + lt(n, "grow", "positive") + n;
    case 4554:
      return at + lt(n, /([^-])(transform)/g, "$1" + at + "$2") + n;
    case 6187:
      return lt(lt(lt(n, /(zoom-|grab)/, at + "$1"), /(image-set)/, at + "$1"), n, "") + n;
    case 5495:
    case 3959:
      return lt(n, /(image-set\([^]*)/, at + "$1$`$1");
    case 4968:
      return lt(lt(n, /(.+:)(flex-)?(.*)/, at + "box-pack:$3" + cn + "flex-pack:$3"), /s.+-b[^;]+/, "justify") + at + n + n;
    case 4095:
    case 3583:
    case 4068:
    case 2532:
      return lt(n, /(.+)-inline(.+)/, at + "$1$2") + n;
    case 8116:
    case 7059:
    case 5753:
    case 5535:
    case 5445:
    case 5701:
    case 4933:
    case 4677:
    case 5533:
    case 5789:
    case 5021:
    case 4765:
      if (Nr(n) - 1 - e > 6)
        switch (tn(n, e + 1)) {
          case 109:
            if (tn(n, e + 4) !== 45)
              break;
          case 102:
            return lt(n, /(.+:)(.+)-([^]+)/, "$1" + at + "$2-$3$1" + tc + (tn(n, e + 3) == 108 ? "$3" : "$2-$3")) + n;
          case 115:
            return ~gf(n, "stretch") ? V1(lt(n, "stretch", "fill-available"), e) + n : n;
        }
      break;
    case 4949:
      if (tn(n, e + 1) !== 115)
        break;
    case 6444:
      switch (tn(n, Nr(n) - 3 - (~gf(n, "!important") && 10))) {
        case 107:
          return lt(n, ":", ":" + at) + n;
        case 101:
          return lt(n, /(.+:)([^;!]+)(;|!.+)?/, "$1" + at + (tn(n, 14) === 45 ? "inline-" : "") + "box$3$1" + at + "$2$3$1" + cn + "$2box$3") + n;
      }
      break;
    case 5936:
      switch (tn(n, e + 11)) {
        case 114:
          return at + n + cn + lt(n, /[svh]\w+-[tblr]{2}/, "tb") + n;
        case 108:
          return at + n + cn + lt(n, /[svh]\w+-[tblr]{2}/, "tb-rl") + n;
        case 45:
          return at + n + cn + lt(n, /[svh]\w+-[tblr]{2}/, "lr") + n;
      }
      return at + n + cn + n + n;
  }
  return n;
}
var tO = function(e, t, r, i) {
  if (e.length > -1 && !e.return)
    switch (e.type) {
      case Jf:
        e.return = V1(e.value, e.length);
        break;
      case P1:
        return Qo([Bs(e, {
          value: lt(e.value, "@", "@" + at)
        })], i);
      case Xf:
        if (e.length)
          return A8(e.props, function(o) {
            switch (I8(o, /(::plac\w+|:read-\w+)/)) {
              case ":read-only":
              case ":read-write":
                return Qo([Bs(e, {
                  props: [lt(o, /:(read-\w+)/, ":" + tc + "$1")]
                })], i);
              case "::placeholder":
                return Qo([Bs(e, {
                  props: [lt(o, /:(plac\w+)/, ":" + at + "input-$1")]
                }), Bs(e, {
                  props: [lt(o, /:(plac\w+)/, ":" + tc + "$1")]
                }), Bs(e, {
                  props: [lt(o, /:(plac\w+)/, cn + "input-$1")]
                })], i);
            }
            return "";
          });
    }
}, nO = [tO], rO = function(e) {
  var t = e.key;
  if (process.env.NODE_ENV !== "production" && !t)
    throw new Error(`You have to configure \`key\` for your cache. Please make sure it's unique (and not equal to 'css') as it's used for linking styles to your cache.
If multiple caches share the same key they might "fight" for each other's style elements.`);
  if (t === "css") {
    var r = document.querySelectorAll("style[data-emotion]:not([data-s])");
    Array.prototype.forEach.call(r, function(w) {
      var b = w.getAttribute("data-emotion");
      b.indexOf(" ") !== -1 && (document.head.appendChild(w), w.setAttribute("data-s", ""));
    });
  }
  var i = e.stylisPlugins || nO;
  if (process.env.NODE_ENV !== "production" && /[^a-z-]/.test(t))
    throw new Error('Emotion key must only contain lower case alphabetical characters and - but "' + t + '" was passed');
  var o = {}, a, l = [];
  a = e.container || document.head, Array.prototype.forEach.call(
    // this means we will ignore elements which don't have a space in them which
    // means that the style elements we're looking at are only Emotion 11 server-rendered style elements
    document.querySelectorAll('style[data-emotion^="' + t + ' "]'),
    function(w) {
      for (var b = w.getAttribute("data-emotion").split(" "), C = 1; C < b.length; C++)
        o[b[C]] = !0;
      l.push(w);
    }
  );
  var u, d = [q8, G8];
  process.env.NODE_ENV !== "production" && d.push(J8({
    get compat() {
      return m.compat;
    }
  }), eO);
  {
    var h, p = [W8, process.env.NODE_ENV !== "production" ? function(w) {
      w.root || (w.return ? h.insert(w.return) : w.value && w.type !== Kf && h.insert(w.value + "{}"));
    } : $8(function(w) {
      h.insert(w);
    })], g = H8(d.concat(i, p)), v = function(b) {
      return Qo(F8(b), g);
    };
    u = function(b, C, M, k) {
      h = M, process.env.NODE_ENV !== "production" && C.map !== void 0 && (h = {
        insert: function(T) {
          M.insert(T + C.map);
        }
      }), v(b ? b + "{" + C.styles + "}" : C.styles), k && (m.inserted[C.name] = !0);
    };
  }
  var m = {
    key: t,
    sheet: new k8({
      key: t,
      container: a,
      nonce: e.nonce,
      speedy: e.speedy,
      prepend: e.prepend,
      insertionPoint: e.insertionPoint
    }),
    nonce: e.nonce,
    inserted: o,
    registered: {},
    insert: u
  };
  return m.sheet.hydrate(l), m;
};
function Re() {
  return Re = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, Re.apply(this, arguments);
}
var qo = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function iO(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var vf = { exports: {} }, ft = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var k0;
function oO() {
  if (k0)
    return ft;
  k0 = 1;
  var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, a = n ? Symbol.for("react.provider") : 60109, l = n ? Symbol.for("react.context") : 60110, u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111, h = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, g = n ? Symbol.for("react.suspense_list") : 60120, v = n ? Symbol.for("react.memo") : 60115, m = n ? Symbol.for("react.lazy") : 60116, w = n ? Symbol.for("react.block") : 60121, b = n ? Symbol.for("react.fundamental") : 60117, C = n ? Symbol.for("react.responder") : 60118, M = n ? Symbol.for("react.scope") : 60119;
  function k(T) {
    if (typeof T == "object" && T !== null) {
      var R = T.$$typeof;
      switch (R) {
        case e:
          switch (T = T.type, T) {
            case u:
            case d:
            case r:
            case o:
            case i:
            case p:
              return T;
            default:
              switch (T = T && T.$$typeof, T) {
                case l:
                case h:
                case m:
                case v:
                case a:
                  return T;
                default:
                  return R;
              }
          }
        case t:
          return R;
      }
    }
  }
  function D(T) {
    return k(T) === d;
  }
  return ft.AsyncMode = u, ft.ConcurrentMode = d, ft.ContextConsumer = l, ft.ContextProvider = a, ft.Element = e, ft.ForwardRef = h, ft.Fragment = r, ft.Lazy = m, ft.Memo = v, ft.Portal = t, ft.Profiler = o, ft.StrictMode = i, ft.Suspense = p, ft.isAsyncMode = function(T) {
    return D(T) || k(T) === u;
  }, ft.isConcurrentMode = D, ft.isContextConsumer = function(T) {
    return k(T) === l;
  }, ft.isContextProvider = function(T) {
    return k(T) === a;
  }, ft.isElement = function(T) {
    return typeof T == "object" && T !== null && T.$$typeof === e;
  }, ft.isForwardRef = function(T) {
    return k(T) === h;
  }, ft.isFragment = function(T) {
    return k(T) === r;
  }, ft.isLazy = function(T) {
    return k(T) === m;
  }, ft.isMemo = function(T) {
    return k(T) === v;
  }, ft.isPortal = function(T) {
    return k(T) === t;
  }, ft.isProfiler = function(T) {
    return k(T) === o;
  }, ft.isStrictMode = function(T) {
    return k(T) === i;
  }, ft.isSuspense = function(T) {
    return k(T) === p;
  }, ft.isValidElementType = function(T) {
    return typeof T == "string" || typeof T == "function" || T === r || T === d || T === o || T === i || T === p || T === g || typeof T == "object" && T !== null && (T.$$typeof === m || T.$$typeof === v || T.$$typeof === a || T.$$typeof === l || T.$$typeof === h || T.$$typeof === b || T.$$typeof === C || T.$$typeof === M || T.$$typeof === w);
  }, ft.typeOf = k, ft;
}
var ht = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var O0;
function sO() {
  return O0 || (O0 = 1, process.env.NODE_ENV !== "production" && function() {
    var n = typeof Symbol == "function" && Symbol.for, e = n ? Symbol.for("react.element") : 60103, t = n ? Symbol.for("react.portal") : 60106, r = n ? Symbol.for("react.fragment") : 60107, i = n ? Symbol.for("react.strict_mode") : 60108, o = n ? Symbol.for("react.profiler") : 60114, a = n ? Symbol.for("react.provider") : 60109, l = n ? Symbol.for("react.context") : 60110, u = n ? Symbol.for("react.async_mode") : 60111, d = n ? Symbol.for("react.concurrent_mode") : 60111, h = n ? Symbol.for("react.forward_ref") : 60112, p = n ? Symbol.for("react.suspense") : 60113, g = n ? Symbol.for("react.suspense_list") : 60120, v = n ? Symbol.for("react.memo") : 60115, m = n ? Symbol.for("react.lazy") : 60116, w = n ? Symbol.for("react.block") : 60121, b = n ? Symbol.for("react.fundamental") : 60117, C = n ? Symbol.for("react.responder") : 60118, M = n ? Symbol.for("react.scope") : 60119;
    function k(te) {
      return typeof te == "string" || typeof te == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      te === r || te === d || te === o || te === i || te === p || te === g || typeof te == "object" && te !== null && (te.$$typeof === m || te.$$typeof === v || te.$$typeof === a || te.$$typeof === l || te.$$typeof === h || te.$$typeof === b || te.$$typeof === C || te.$$typeof === M || te.$$typeof === w);
    }
    function D(te) {
      if (typeof te == "object" && te !== null) {
        var $e = te.$$typeof;
        switch ($e) {
          case e:
            var Be = te.type;
            switch (Be) {
              case u:
              case d:
              case r:
              case o:
              case i:
              case p:
                return Be;
              default:
                var vt = Be && Be.$$typeof;
                switch (vt) {
                  case l:
                  case h:
                  case m:
                  case v:
                  case a:
                    return vt;
                  default:
                    return $e;
                }
            }
          case t:
            return $e;
        }
      }
    }
    var T = u, R = d, _ = l, Z = a, K = e, $ = h, F = r, Y = m, Q = v, ee = t, ie = o, re = i, oe = p, de = !1;
    function se(te) {
      return de || (de = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), we(te) || D(te) === u;
    }
    function we(te) {
      return D(te) === d;
    }
    function Oe(te) {
      return D(te) === l;
    }
    function le(te) {
      return D(te) === a;
    }
    function Ce(te) {
      return typeof te == "object" && te !== null && te.$$typeof === e;
    }
    function Ne(te) {
      return D(te) === h;
    }
    function me(te) {
      return D(te) === r;
    }
    function U(te) {
      return D(te) === m;
    }
    function ae(te) {
      return D(te) === v;
    }
    function G(te) {
      return D(te) === t;
    }
    function xe(te) {
      return D(te) === o;
    }
    function ye(te) {
      return D(te) === i;
    }
    function Je(te) {
      return D(te) === p;
    }
    ht.AsyncMode = T, ht.ConcurrentMode = R, ht.ContextConsumer = _, ht.ContextProvider = Z, ht.Element = K, ht.ForwardRef = $, ht.Fragment = F, ht.Lazy = Y, ht.Memo = Q, ht.Portal = ee, ht.Profiler = ie, ht.StrictMode = re, ht.Suspense = oe, ht.isAsyncMode = se, ht.isConcurrentMode = we, ht.isContextConsumer = Oe, ht.isContextProvider = le, ht.isElement = Ce, ht.isForwardRef = Ne, ht.isFragment = me, ht.isLazy = U, ht.isMemo = ae, ht.isPortal = G, ht.isProfiler = xe, ht.isStrictMode = ye, ht.isSuspense = Je, ht.isValidElementType = k, ht.typeOf = D;
  }()), ht;
}
process.env.NODE_ENV === "production" ? vf.exports = oO() : vf.exports = sO();
var aO = vf.exports, W1 = aO, lO = {
  $$typeof: !0,
  render: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0
}, cO = {
  $$typeof: !0,
  compare: !0,
  defaultProps: !0,
  displayName: !0,
  propTypes: !0,
  type: !0
}, H1 = {};
H1[W1.ForwardRef] = lO;
H1[W1.Memo] = cO;
var uO = !0;
function $1(n, e, t) {
  var r = "";
  return t.split(" ").forEach(function(i) {
    n[i] !== void 0 ? e.push(n[i] + ";") : r += i + " ";
  }), r;
}
var eh = function(e, t, r) {
  var i = e.key + "-" + t.name;
  // we only need to add the styles to the registered cache if the
  // class name could be used further down
  // the tree but if it's a string tag, we know it won't
  // so we don't have to add it to registered cache.
  // this improves memory usage since we can avoid storing the whole style string
  (r === !1 || // we need to always store it if we're in compat mode and
  // in node since emotion-server relies on whether a style is in
  // the registered cache to know whether a style is global or not
  // also, note that this check will be dead code eliminated in the browser
  uO === !1) && e.registered[i] === void 0 && (e.registered[i] = t.styles);
}, th = function(e, t, r) {
  eh(e, t, r);
  var i = e.key + "-" + t.name;
  if (e.inserted[t.name] === void 0) {
    var o = t;
    do
      e.insert(t === o ? "." + i : "", o, e.sheet, !0), o = o.next;
    while (o !== void 0);
  }
};
function dO(n) {
  for (var e = 0, t, r = 0, i = n.length; i >= 4; ++r, i -= 4)
    t = n.charCodeAt(r) & 255 | (n.charCodeAt(++r) & 255) << 8 | (n.charCodeAt(++r) & 255) << 16 | (n.charCodeAt(++r) & 255) << 24, t = /* Math.imul(k, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16), t ^= /* k >>> r: */
    t >>> 24, e = /* Math.imul(k, m): */
    (t & 65535) * 1540483477 + ((t >>> 16) * 59797 << 16) ^ /* Math.imul(h, m): */
    (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  switch (i) {
    case 3:
      e ^= (n.charCodeAt(r + 2) & 255) << 16;
    case 2:
      e ^= (n.charCodeAt(r + 1) & 255) << 8;
    case 1:
      e ^= n.charCodeAt(r) & 255, e = /* Math.imul(h, m): */
      (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16);
  }
  return e ^= e >>> 13, e = /* Math.imul(h, m): */
  (e & 65535) * 1540483477 + ((e >>> 16) * 59797 << 16), ((e ^ e >>> 15) >>> 0).toString(36);
}
var fO = {
  animationIterationCount: 1,
  aspectRatio: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
}, T0 = `You have illegal escape sequence in your template literal, most likely inside content's property value.
Because you write your CSS inside a JavaScript string you actually have to do double escaping, so for example "content: '\\00d7';" should become "content: '\\\\00d7';".
You can read more about this here:
https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#ES2018_revision_of_illegal_escape_sequences`, hO = "You have passed in falsy value as style object's key (can happen when in example you pass unexported component as computed key).", pO = /[A-Z]|^ms/g, U1 = /_EMO_([^_]+?)_([^]*?)_EMO_/g, nh = function(e) {
  return e.charCodeAt(1) === 45;
}, M0 = function(e) {
  return e != null && typeof e != "boolean";
}, bd = /* @__PURE__ */ U8(function(n) {
  return nh(n) ? n : n.replace(pO, "-$&").toLowerCase();
}), nc = function(e, t) {
  switch (e) {
    case "animation":
    case "animationName":
      if (typeof t == "string")
        return t.replace(U1, function(r, i, o) {
          return Er = {
            name: i,
            styles: o,
            next: Er
          }, i;
        });
  }
  return fO[e] !== 1 && !nh(e) && typeof t == "number" && t !== 0 ? t + "px" : t;
};
if (process.env.NODE_ENV !== "production") {
  var gO = /(var|attr|counters?|url|element|(((repeating-)?(linear|radial))|conic)-gradient)\(|(no-)?(open|close)-quote/, mO = ["normal", "none", "initial", "inherit", "unset"], vO = nc, yO = /^-ms-/, wO = /-(.)/g, R0 = {};
  nc = function(e, t) {
    if (e === "content" && (typeof t != "string" || mO.indexOf(t) === -1 && !gO.test(t) && (t.charAt(0) !== t.charAt(t.length - 1) || t.charAt(0) !== '"' && t.charAt(0) !== "'")))
      throw new Error("You seem to be using a value for 'content' without quotes, try replacing it with `content: '\"" + t + "\"'`");
    var r = vO(e, t);
    return r !== "" && !nh(e) && e.indexOf("-") !== -1 && R0[e] === void 0 && (R0[e] = !0, console.error("Using kebab-case for css properties in objects is not supported. Did you mean " + e.replace(yO, "ms-").replace(wO, function(i, o) {
      return o.toUpperCase();
    }) + "?")), r;
  };
}
var Z1 = "Component selectors can only be used in conjunction with @emotion/babel-plugin, the swc Emotion plugin, or another Emotion-aware compiler transform.";
function la(n, e, t) {
  if (t == null)
    return "";
  if (t.__emotion_styles !== void 0) {
    if (process.env.NODE_ENV !== "production" && t.toString() === "NO_COMPONENT_SELECTOR")
      throw new Error(Z1);
    return t;
  }
  switch (typeof t) {
    case "boolean":
      return "";
    case "object": {
      if (t.anim === 1)
        return Er = {
          name: t.name,
          styles: t.styles,
          next: Er
        }, t.name;
      if (t.styles !== void 0) {
        var r = t.next;
        if (r !== void 0)
          for (; r !== void 0; )
            Er = {
              name: r.name,
              styles: r.styles,
              next: Er
            }, r = r.next;
        var i = t.styles + ";";
        return process.env.NODE_ENV !== "production" && t.map !== void 0 && (i += t.map), i;
      }
      return bO(n, e, t);
    }
    case "function": {
      if (n !== void 0) {
        var o = Er, a = t(n);
        return Er = o, la(n, e, a);
      } else
        process.env.NODE_ENV !== "production" && console.error("Functions that are interpolated in css calls will be stringified.\nIf you want to have a css call based on props, create a function that returns a css call like this\nlet dynamicStyle = (props) => css`color: ${props.color}`\nIt can be called directly with props or interpolated in a styled call like this\nlet SomeComponent = styled('div')`${dynamicStyle}`");
      break;
    }
    case "string":
      if (process.env.NODE_ENV !== "production") {
        var l = [], u = t.replace(U1, function(h, p, g) {
          var v = "animation" + l.length;
          return l.push("const " + v + " = keyframes`" + g.replace(/^@keyframes animation-\w+/, "") + "`"), "${" + v + "}";
        });
        l.length && console.error("`keyframes` output got interpolated into plain string, please wrap it with `css`.\n\nInstead of doing this:\n\n" + [].concat(l, ["`" + u + "`"]).join(`
`) + `

You should wrap it with \`css\` like this:

` + ("css`" + u + "`"));
      }
      break;
  }
  if (e == null)
    return t;
  var d = e[t];
  return d !== void 0 ? d : t;
}
function bO(n, e, t) {
  var r = "";
  if (Array.isArray(t))
    for (var i = 0; i < t.length; i++)
      r += la(n, e, t[i]) + ";";
  else
    for (var o in t) {
      var a = t[o];
      if (typeof a != "object")
        e != null && e[a] !== void 0 ? r += o + "{" + e[a] + "}" : M0(a) && (r += bd(o) + ":" + nc(o, a) + ";");
      else {
        if (o === "NO_COMPONENT_SELECTOR" && process.env.NODE_ENV !== "production")
          throw new Error(Z1);
        if (Array.isArray(a) && typeof a[0] == "string" && (e == null || e[a[0]] === void 0))
          for (var l = 0; l < a.length; l++)
            M0(a[l]) && (r += bd(o) + ":" + nc(o, a[l]) + ";");
        else {
          var u = la(n, e, a);
          switch (o) {
            case "animation":
            case "animationName": {
              r += bd(o) + ":" + u + ";";
              break;
            }
            default:
              process.env.NODE_ENV !== "production" && o === "undefined" && console.error(hO), r += o + "{" + u + "}";
          }
        }
      }
    }
  return r;
}
var D0 = /label:\s*([^\s;\n{]+)\s*(;|$)/g, j1;
process.env.NODE_ENV !== "production" && (j1 = /\/\*#\ssourceMappingURL=data:application\/json;\S+\s+\*\//g);
var Er, ca = function(e, t, r) {
  if (e.length === 1 && typeof e[0] == "object" && e[0] !== null && e[0].styles !== void 0)
    return e[0];
  var i = !0, o = "";
  Er = void 0;
  var a = e[0];
  a == null || a.raw === void 0 ? (i = !1, o += la(r, t, a)) : (process.env.NODE_ENV !== "production" && a[0] === void 0 && console.error(T0), o += a[0]);
  for (var l = 1; l < e.length; l++)
    o += la(r, t, e[l]), i && (process.env.NODE_ENV !== "production" && a[l] === void 0 && console.error(T0), o += a[l]);
  var u;
  process.env.NODE_ENV !== "production" && (o = o.replace(j1, function(g) {
    return u = g, "";
  })), D0.lastIndex = 0;
  for (var d = "", h; (h = D0.exec(o)) !== null; )
    d += "-" + // $FlowFixMe we know it's not null
    h[1];
  var p = dO(o) + d;
  return process.env.NODE_ENV !== "production" ? {
    name: p,
    styles: o,
    map: u,
    next: Er,
    toString: function() {
      return "You have tried to stringify object returned from `css` function. It isn't supposed to be used directly (e.g. as value of the `className` prop), but rather handed to emotion so it can handle it (e.g. as value of `css` prop).";
    }
  } : {
    name: p,
    styles: o,
    next: Er
  };
}, xO = function(e) {
  return e();
}, Y1 = pn["useInsertionEffect"] ? pn["useInsertionEffect"] : !1, q1 = Y1 || xO, I0 = Y1 || pn.useLayoutEffect, Fc = {}.hasOwnProperty, rh = /* @__PURE__ */ pn.createContext(
  // we're doing this to avoid preconstruct's dead code elimination in this one case
  // because this module is primarily intended for the browser and node
  // but it's also required in react native and similar environments sometimes
  // and we could have a special build just for that
  // but this is much easier and the native packages
  // might use a different theme context in the future anyway
  typeof HTMLElement < "u" ? /* @__PURE__ */ rO({
    key: "css"
  }) : null
);
process.env.NODE_ENV !== "production" && (rh.displayName = "EmotionCacheContext");
rh.Provider;
var ih = function(e) {
  return /* @__PURE__ */ Yt(function(t, r) {
    var i = It(rh);
    return e(t, i, r);
  });
}, Vc = /* @__PURE__ */ pn.createContext({});
process.env.NODE_ENV !== "production" && (Vc.displayName = "EmotionThemeContext");
var A0 = function(e) {
  var t = e.split(".");
  return t[t.length - 1];
}, SO = function(e) {
  var t = /^\s+at\s+([A-Za-z0-9$.]+)\s/.exec(e);
  if (t || (t = /^([A-Za-z0-9$.]+)@/.exec(e), t))
    return A0(t[1]);
}, CO = /* @__PURE__ */ new Set(["renderWithHooks", "processChild", "finishClassComponent", "renderToString"]), EO = function(e) {
  return e.replace(/\$/g, "-");
}, kO = function(e) {
  if (e)
    for (var t = e.split(`
`), r = 0; r < t.length; r++) {
      var i = SO(t[r]);
      if (i) {
        if (CO.has(i))
          break;
        if (/^[A-Z]/.test(i))
          return EO(i);
      }
    }
}, yf = "__EMOTION_TYPE_PLEASE_DO_NOT_USE__", wf = "__EMOTION_LABEL_PLEASE_DO_NOT_USE__", G1 = function(e, t) {
  if (process.env.NODE_ENV !== "production" && typeof t.css == "string" && // check if there is a css declaration
  t.css.indexOf(":") !== -1)
    throw new Error("Strings are not allowed as css prop values, please wrap it in a css template literal from '@emotion/react' like this: css`" + t.css + "`");
  var r = {};
  for (var i in t)
    Fc.call(t, i) && (r[i] = t[i]);
  if (r[yf] = e, process.env.NODE_ENV !== "production" && t.css && (typeof t.css != "object" || typeof t.css.name != "string" || t.css.name.indexOf("-") === -1)) {
    var o = kO(new Error().stack);
    o && (r[wf] = o);
  }
  return r;
}, OO = function(e) {
  var t = e.cache, r = e.serialized, i = e.isStringTag;
  return eh(t, r, i), q1(function() {
    return th(t, r, i);
  }), null;
}, K1 = /* @__PURE__ */ ih(function(n, e, t) {
  var r = n.css;
  typeof r == "string" && e.registered[r] !== void 0 && (r = e.registered[r]);
  var i = n[yf], o = [r], a = "";
  typeof n.className == "string" ? a = $1(e.registered, o, n.className) : n.className != null && (a = n.className + " ");
  var l = ca(o, void 0, pn.useContext(Vc));
  if (process.env.NODE_ENV !== "production" && l.name.indexOf("-") === -1) {
    var u = n[wf];
    u && (l = ca([l, "label:" + u + ";"]));
  }
  a += e.key + "-" + l.name;
  var d = {};
  for (var h in n)
    Fc.call(n, h) && h !== "css" && h !== yf && (process.env.NODE_ENV === "production" || h !== wf) && (d[h] = n[h]);
  return d.ref = t, d.className = a, /* @__PURE__ */ pn.createElement(pn.Fragment, null, /* @__PURE__ */ pn.createElement(OO, {
    cache: e,
    serialized: l,
    isStringTag: typeof i == "string"
  }), /* @__PURE__ */ pn.createElement(i, d));
});
process.env.NODE_ENV !== "production" && (K1.displayName = "EmotionCssPropInternal");
var X1 = K1, J1 = ia.Fragment;
function x(n, e, t) {
  return Fc.call(e, "css") ? ia.jsx(X1, G1(n, e), t) : ia.jsx(n, e, t);
}
function W(n, e, t) {
  return Fc.call(e, "css") ? ia.jsxs(X1, G1(n, e), t) : ia.jsxs(n, e, t);
}
const Q1 = Ui(
  {}
), ev = ({
  id: n,
  children: e
}) => /* @__PURE__ */ x(Q1.Provider, { value: { id: n }, children: e }), Mo = Ui(
  {}
), tv = ({
  pageIndex: n,
  children: e
}) => /* @__PURE__ */ x(Mo.Provider, { value: { pageIndex: n }, children: e }), gs = (n) => {
  const { pageIndex: e } = It(Mo), { id: t } = It(Q1), {
    state: r,
    actions: i,
    ...o
  } = je((l) => n && l.pages[e] && l.pages[e].layers[t] && n(l.pages[e].layers[t])), a = pe(
    () => ({
      setProp: (l) => i.setProp(e, t, l),
      select: () => i.selectLayers(e, t),
      hover: (l) => i.hoverLayer(
        e,
        typeof l > "u" ? t : null
      ),
      setTextEditor: (l) => i.setTextEditor(e, t, l),
      openTextEditor: () => i.openTextEditor(e, t),
      openImageEditor: ({ boxSize: l, position: u, rotate: d, image: h, video: p }) => i.openImageEditor(e, t, {
        boxSize: l,
        position: u,
        rotate: d,
        image: h,
        video: p
      })
    }),
    [i, e, t]
  );
  return {
    ...o,
    pageIndex: e,
    id: t,
    state: r,
    actions: a
  };
}, rn = () => {
  const { pageIndex: n } = It(Mo), { selectedLayerIds: e, selectedLayers: t } = je((r) => {
    const i = typeof n > "u" ? r.activePage : n, o = (r.selectedLayers[i] || []).filter((a) => r.pages[i] && r.pages[i].layers[a]);
    return {
      selectedLayerIds: o,
      selectedLayers: o.map(
        (a) => r.pages[i].layers[a]
      )
    };
  });
  return { selectedLayerIds: e, selectedLayers: t };
};
var TO = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M100 36H56a20 20 0 0 0-20 20v44a20 20 0 0 0 20 20h44a20 20 0 0 0 20-20V56a20 20 0 0 0-20-20Zm-4 60H60V60h36Zm104-60h-44a20 20 0 0 0-20 20v44a20 20 0 0 0 20 20h44a20 20 0 0 0 20-20V56a20 20 0 0 0-20-20Zm-4 60h-36V60h36Zm-96 40H56a20 20 0 0 0-20 20v44a20 20 0 0 0 20 20h44a20 20 0 0 0 20-20v-44a20 20 0 0 0-20-20Zm-4 60H60v-36h36Zm104-60h-44a20 20 0 0 0-20 20v44a20 20 0 0 0 20 20h44a20 20 0 0 0 20-20v-44a20 20 0 0 0-20-20Zm-4 60h-36v-36h36Z"
    })
  }));
}, ua = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 128a8 8 0 0 1-8 8h-80v80a8 8 0 0 1-16 0v-80H40a8 8 0 0 1 0-16h80V40a8 8 0 0 1 16 0v80h80a8 8 0 0 1 8 8Z"
    })
  }));
}, Ee = {}, bf = { exports: {} };
(function(n, e) {
  (function(t, r) {
    var i = "1.0.36", o = "", a = "?", l = "function", u = "undefined", d = "object", h = "string", p = "major", g = "model", v = "name", m = "type", w = "vendor", b = "version", C = "architecture", M = "console", k = "mobile", D = "tablet", T = "smarttv", R = "wearable", _ = "embedded", Z = 350, K = "Amazon", $ = "Apple", F = "ASUS", Y = "BlackBerry", Q = "Browser", ee = "Chrome", ie = "Edge", re = "Firefox", oe = "Google", de = "Huawei", se = "LG", we = "Microsoft", Oe = "Motorola", le = "Opera", Ce = "Samsung", Ne = "Sharp", me = "Sony", U = "Xiaomi", ae = "Zebra", G = "Facebook", xe = "Chromium OS", ye = "Mac OS", Je = function(Pe, qe) {
      var ve = {};
      for (var Ae in Pe)
        qe[Ae] && qe[Ae].length % 2 === 0 ? ve[Ae] = qe[Ae].concat(Pe[Ae]) : ve[Ae] = Pe[Ae];
      return ve;
    }, te = function(Pe) {
      for (var qe = {}, ve = 0; ve < Pe.length; ve++)
        qe[Pe[ve].toUpperCase()] = Pe[ve];
      return qe;
    }, $e = function(Pe, qe) {
      return typeof Pe === h ? Be(qe).indexOf(Be(Pe)) !== -1 : !1;
    }, Be = function(Pe) {
      return Pe.toLowerCase();
    }, vt = function(Pe) {
      return typeof Pe === h ? Pe.replace(/[^\d\.]/g, o).split(".")[0] : r;
    }, P = function(Pe, qe) {
      if (typeof Pe === h)
        return Pe = Pe.replace(/^\s\s*/, o), typeof qe === u ? Pe : Pe.substring(0, Z);
    }, A = function(Pe, qe) {
      for (var ve = 0, Ae, ot, Ct, Fe, De, on; ve < qe.length && !De; ) {
        var Ur = qe[ve], Zr = qe[ve + 1];
        for (Ae = ot = 0; Ae < Ur.length && !De && Ur[Ae]; )
          if (De = Ur[Ae++].exec(Pe), De)
            for (Ct = 0; Ct < Zr.length; Ct++)
              on = De[++ot], Fe = Zr[Ct], typeof Fe === d && Fe.length > 0 ? Fe.length === 2 ? typeof Fe[1] == l ? this[Fe[0]] = Fe[1].call(this, on) : this[Fe[0]] = Fe[1] : Fe.length === 3 ? typeof Fe[1] === l && !(Fe[1].exec && Fe[1].test) ? this[Fe[0]] = on ? Fe[1].call(this, on, Fe[2]) : r : this[Fe[0]] = on ? on.replace(Fe[1], Fe[2]) : r : Fe.length === 4 && (this[Fe[0]] = on ? Fe[3].call(this, on.replace(Fe[1], Fe[2])) : r) : this[Fe] = on || r;
        ve += 2;
      }
    }, z = function(Pe, qe) {
      for (var ve in qe)
        if (typeof qe[ve] === d && qe[ve].length > 0) {
          for (var Ae = 0; Ae < qe[ve].length; Ae++)
            if ($e(qe[ve][Ae], Pe))
              return ve === a ? r : ve;
        } else if ($e(qe[ve], Pe))
          return ve === a ? r : ve;
      return Pe;
    }, H = { "1.0": "/8", 1.2: "/1", 1.3: "/3", "2.0": "/412", "2.0.2": "/416", "2.0.3": "/417", "2.0.4": "/419", "?": "/" }, ce = { ME: "4.90", "NT 3.11": "NT3.51", "NT 4.0": "NT4.0", 2e3: "NT 5.0", XP: ["NT 5.1", "NT 5.2"], Vista: "NT 6.0", 7: "NT 6.1", 8: "NT 6.2", 8.1: "NT 6.3", 10: ["NT 6.4", "NT 10.0"], RT: "ARM" }, fe = { browser: [[/\b(?:crmo|crios)\/([\w\.]+)/i], [b, [v, "Chrome"]], [/edg(?:e|ios|a)?\/([\w\.]+)/i], [b, [v, "Edge"]], [/(opera mini)\/([-\w\.]+)/i, /(opera [mobiletab]{3,6})\b.+version\/([-\w\.]+)/i, /(opera)(?:.+version\/|[\/ ]+)([\w\.]+)/i], [v, b], [/opios[\/ ]+([\w\.]+)/i], [b, [v, le + " Mini"]], [/\bopr\/([\w\.]+)/i], [b, [v, le]], [/(kindle)\/([\w\.]+)/i, /(lunascape|maxthon|netfront|jasmine|blazer)[\/ ]?([\w\.]*)/i, /(avant |iemobile|slim)(?:browser)?[\/ ]?([\w\.]*)/i, /(ba?idubrowser)[\/ ]?([\w\.]+)/i, /(?:ms|\()(ie) ([\w\.]+)/i, /(flock|rockmelt|midori|epiphany|silk|skyfire|bolt|iron|vivaldi|iridium|phantomjs|bowser|quark|qupzilla|falkon|rekonq|puffin|brave|whale(?!.+naver)|qqbrowserlite|qq|duckduckgo)\/([-\w\.]+)/i, /(heytap|ovi)browser\/([\d\.]+)/i, /(weibo)__([\d\.]+)/i], [v, b], [/(?:\buc? ?browser|(?:juc.+)ucweb)[\/ ]?([\w\.]+)/i], [b, [v, "UC" + Q]], [/microm.+\bqbcore\/([\w\.]+)/i, /\bqbcore\/([\w\.]+).+microm/i], [b, [v, "WeChat(Win) Desktop"]], [/micromessenger\/([\w\.]+)/i], [b, [v, "WeChat"]], [/konqueror\/([\w\.]+)/i], [b, [v, "Konqueror"]], [/trident.+rv[: ]([\w\.]{1,9})\b.+like gecko/i], [b, [v, "IE"]], [/ya(?:search)?browser\/([\w\.]+)/i], [b, [v, "Yandex"]], [/(avast|avg)\/([\w\.]+)/i], [[v, /(.+)/, "$1 Secure " + Q], b], [/\bfocus\/([\w\.]+)/i], [b, [v, re + " Focus"]], [/\bopt\/([\w\.]+)/i], [b, [v, le + " Touch"]], [/coc_coc\w+\/([\w\.]+)/i], [b, [v, "Coc Coc"]], [/dolfin\/([\w\.]+)/i], [b, [v, "Dolphin"]], [/coast\/([\w\.]+)/i], [b, [v, le + " Coast"]], [/miuibrowser\/([\w\.]+)/i], [b, [v, "MIUI " + Q]], [/fxios\/([-\w\.]+)/i], [b, [v, re]], [/\bqihu|(qi?ho?o?|360)browser/i], [[v, "360 " + Q]], [/(oculus|samsung|sailfish|huawei)browser\/([\w\.]+)/i], [[v, /(.+)/, "$1 " + Q], b], [/(comodo_dragon)\/([\w\.]+)/i], [[v, /_/g, " "], b], [/(electron)\/([\w\.]+) safari/i, /(tesla)(?: qtcarbrowser|\/(20\d\d\.[-\w\.]+))/i, /m?(qqbrowser|baiduboxapp|2345Explorer)[\/ ]?([\w\.]+)/i], [v, b], [/(metasr)[\/ ]?([\w\.]+)/i, /(lbbrowser)/i, /\[(linkedin)app\]/i], [v], [/((?:fban\/fbios|fb_iab\/fb4a)(?!.+fbav)|;fbav\/([\w\.]+);)/i], [[v, G], b], [/(kakao(?:talk|story))[\/ ]([\w\.]+)/i, /(naver)\(.*?(\d+\.[\w\.]+).*\)/i, /safari (line)\/([\w\.]+)/i, /\b(line)\/([\w\.]+)\/iab/i, /(chromium|instagram|snapchat)[\/ ]([-\w\.]+)/i], [v, b], [/\bgsa\/([\w\.]+) .*safari\//i], [b, [v, "GSA"]], [/musical_ly(?:.+app_?version\/|_)([\w\.]+)/i], [b, [v, "TikTok"]], [/headlesschrome(?:\/([\w\.]+)| )/i], [b, [v, ee + " Headless"]], [/ wv\).+(chrome)\/([\w\.]+)/i], [[v, ee + " WebView"], b], [/droid.+ version\/([\w\.]+)\b.+(?:mobile safari|safari)/i], [b, [v, "Android " + Q]], [/(chrome|omniweb|arora|[tizenoka]{5} ?browser)\/v?([\w\.]+)/i], [v, b], [/version\/([\w\.\,]+) .*mobile\/\w+ (safari)/i], [b, [v, "Mobile Safari"]], [/version\/([\w(\.|\,)]+) .*(mobile ?safari|safari)/i], [b, v], [/webkit.+?(mobile ?safari|safari)(\/[\w\.]+)/i], [v, [b, z, H]], [/(webkit|khtml)\/([\w\.]+)/i], [v, b], [/(navigator|netscape\d?)\/([-\w\.]+)/i], [[v, "Netscape"], b], [/mobile vr; rv:([\w\.]+)\).+firefox/i], [b, [v, re + " Reality"]], [/ekiohf.+(flow)\/([\w\.]+)/i, /(swiftfox)/i, /(icedragon|iceweasel|camino|chimera|fennec|maemo browser|minimo|conkeror|klar)[\/ ]?([\w\.\+]+)/i, /(seamonkey|k-meleon|icecat|iceape|firebird|phoenix|palemoon|basilisk|waterfox)\/([-\w\.]+)$/i, /(firefox)\/([\w\.]+)/i, /(mozilla)\/([\w\.]+) .+rv\:.+gecko\/\d+/i, /(polaris|lynx|dillo|icab|doris|amaya|w3m|netsurf|sleipnir|obigo|mosaic|(?:go|ice|up)[\. ]?browser)[-\/ ]?v?([\w\.]+)/i, /(links) \(([\w\.]+)/i, /panasonic;(viera)/i], [v, b], [/(cobalt)\/([\w\.]+)/i], [v, [b, /master.|lts./, ""]]], cpu: [[/(?:(amd|x(?:(?:86|64)[-_])?|wow|win)64)[;\)]/i], [[C, "amd64"]], [/(ia32(?=;))/i], [[C, Be]], [/((?:i[346]|x)86)[;\)]/i], [[C, "ia32"]], [/\b(aarch64|arm(v?8e?l?|_?64))\b/i], [[C, "arm64"]], [/\b(arm(?:v[67])?ht?n?[fl]p?)\b/i], [[C, "armhf"]], [/windows (ce|mobile); ppc;/i], [[C, "arm"]], [/((?:ppc|powerpc)(?:64)?)(?: mac|;|\))/i], [[C, /ower/, o, Be]], [/(sun4\w)[;\)]/i], [[C, "sparc"]], [/((?:avr32|ia64(?=;))|68k(?=\))|\barm(?=v(?:[1-7]|[5-7]1)l?|;|eabi)|(?=atmel )avr|(?:irix|mips|sparc)(?:64)?\b|pa-risc)/i], [[C, Be]]], device: [[/\b(sch-i[89]0\d|shw-m380s|sm-[ptx]\w{2,4}|gt-[pn]\d{2,4}|sgh-t8[56]9|nexus 10)/i], [g, [w, Ce], [m, D]], [/\b((?:s[cgp]h|gt|sm)-\w+|sc[g-]?[\d]+a?|galaxy nexus)/i, /samsung[- ]([-\w]+)/i, /sec-(sgh\w+)/i], [g, [w, Ce], [m, k]], [/(?:\/|\()(ip(?:hone|od)[\w, ]*)(?:\/|;)/i], [g, [w, $], [m, k]], [/\((ipad);[-\w\),; ]+apple/i, /applecoremedia\/[\w\.]+ \((ipad)/i, /\b(ipad)\d\d?,\d\d?[;\]].+ios/i], [g, [w, $], [m, D]], [/(macintosh);/i], [g, [w, $]], [/\b(sh-?[altvz]?\d\d[a-ekm]?)/i], [g, [w, Ne], [m, k]], [/\b((?:ag[rs][23]?|bah2?|sht?|btv)-a?[lw]\d{2})\b(?!.+d\/s)/i], [g, [w, de], [m, D]], [/(?:huawei|honor)([-\w ]+)[;\)]/i, /\b(nexus 6p|\w{2,4}e?-[atu]?[ln][\dx][012359c][adn]?)\b(?!.+d\/s)/i], [g, [w, de], [m, k]], [/\b(poco[\w ]+|m2\d{3}j\d\d[a-z]{2})(?: bui|\))/i, /\b; (\w+) build\/hm\1/i, /\b(hm[-_ ]?note?[_ ]?(?:\d\w)?) bui/i, /\b(redmi[\-_ ]?(?:note|k)?[\w_ ]+)(?: bui|\))/i, /\b(mi[-_ ]?(?:a\d|one|one[_ ]plus|note lte|max|cc)?[_ ]?(?:\d?\w?)[_ ]?(?:plus|se|lite)?)(?: bui|\))/i], [[g, /_/g, " "], [w, U], [m, k]], [/\b(mi[-_ ]?(?:pad)(?:[\w_ ]+))(?: bui|\))/i], [[g, /_/g, " "], [w, U], [m, D]], [/; (\w+) bui.+ oppo/i, /\b(cph[12]\d{3}|p(?:af|c[al]|d\w|e[ar])[mt]\d0|x9007|a101op)\b/i], [g, [w, "OPPO"], [m, k]], [/vivo (\w+)(?: bui|\))/i, /\b(v[12]\d{3}\w?[at])(?: bui|;)/i], [g, [w, "Vivo"], [m, k]], [/\b(rmx[12]\d{3})(?: bui|;|\))/i], [g, [w, "Realme"], [m, k]], [/\b(milestone|droid(?:[2-4x]| (?:bionic|x2|pro|razr))?:?( 4g)?)\b[\w ]+build\//i, /\bmot(?:orola)?[- ](\w*)/i, /((?:moto[\w\(\) ]+|xt\d{3,4}|nexus 6)(?= bui|\)))/i], [g, [w, Oe], [m, k]], [/\b(mz60\d|xoom[2 ]{0,2}) build\//i], [g, [w, Oe], [m, D]], [/((?=lg)?[vl]k\-?\d{3}) bui| 3\.[-\w; ]{10}lg?-([06cv9]{3,4})/i], [g, [w, se], [m, D]], [/(lm(?:-?f100[nv]?|-[\w\.]+)(?= bui|\))|nexus [45])/i, /\blg[-e;\/ ]+((?!browser|netcast|android tv)\w+)/i, /\blg-?([\d\w]+) bui/i], [g, [w, se], [m, k]], [/(ideatab[-\w ]+)/i, /lenovo ?(s[56]000[-\w]+|tab(?:[\w ]+)|yt[-\d\w]{6}|tb[-\d\w]{6})/i], [g, [w, "Lenovo"], [m, D]], [/(?:maemo|nokia).*(n900|lumia \d+)/i, /nokia[-_ ]?([-\w\.]*)/i], [[g, /_/g, " "], [w, "Nokia"], [m, k]], [/(pixel c)\b/i], [g, [w, oe], [m, D]], [/droid.+; (pixel[\daxl ]{0,6})(?: bui|\))/i], [g, [w, oe], [m, k]], [/droid.+ (a?\d[0-2]{2}so|[c-g]\d{4}|so[-gl]\w+|xq-a\w[4-7][12])(?= bui|\).+chrome\/(?![1-6]{0,1}\d\.))/i], [g, [w, me], [m, k]], [/sony tablet [ps]/i, /\b(?:sony)?sgp\w+(?: bui|\))/i], [[g, "Xperia Tablet"], [w, me], [m, D]], [/ (kb2005|in20[12]5|be20[12][59])\b/i, /(?:one)?(?:plus)? (a\d0\d\d)(?: b|\))/i], [g, [w, "OnePlus"], [m, k]], [/(alexa)webm/i, /(kf[a-z]{2}wi|aeo[c-r]{2})( bui|\))/i, /(kf[a-z]+)( bui|\)).+silk\//i], [g, [w, K], [m, D]], [/((?:sd|kf)[0349hijorstuw]+)( bui|\)).+silk\//i], [[g, /(.+)/g, "Fire Phone $1"], [w, K], [m, k]], [/(playbook);[-\w\),; ]+(rim)/i], [g, w, [m, D]], [/\b((?:bb[a-f]|st[hv])100-\d)/i, /\(bb10; (\w+)/i], [g, [w, Y], [m, k]], [/(?:\b|asus_)(transfo[prime ]{4,10} \w+|eeepc|slider \w+|nexus 7|padfone|p00[cj])/i], [g, [w, F], [m, D]], [/ (z[bes]6[027][012][km][ls]|zenfone \d\w?)\b/i], [g, [w, F], [m, k]], [/(nexus 9)/i], [g, [w, "HTC"], [m, D]], [/(htc)[-;_ ]{1,2}([\w ]+(?=\)| bui)|\w+)/i, /(zte)[- ]([\w ]+?)(?: bui|\/|\))/i, /(alcatel|geeksphone|nexian|panasonic(?!(?:;|\.))|sony(?!-bra))[-_ ]?([-\w]*)/i], [w, [g, /_/g, " "], [m, k]], [/droid.+; ([ab][1-7]-?[0178a]\d\d?)/i], [g, [w, "Acer"], [m, D]], [/droid.+; (m[1-5] note) bui/i, /\bmz-([-\w]{2,})/i], [g, [w, "Meizu"], [m, k]], [/(blackberry|benq|palm(?=\-)|sonyericsson|acer|asus|dell|meizu|motorola|polytron|infinix|tecno)[-_ ]?([-\w]*)/i, /(hp) ([\w ]+\w)/i, /(asus)-?(\w+)/i, /(microsoft); (lumia[\w ]+)/i, /(lenovo)[-_ ]?([-\w]+)/i, /(jolla)/i, /(oppo) ?([\w ]+) bui/i], [w, g, [m, k]], [/(kobo)\s(ereader|touch)/i, /(archos) (gamepad2?)/i, /(hp).+(touchpad(?!.+tablet)|tablet)/i, /(kindle)\/([\w\.]+)/i, /(nook)[\w ]+build\/(\w+)/i, /(dell) (strea[kpr\d ]*[\dko])/i, /(le[- ]+pan)[- ]+(\w{1,9}) bui/i, /(trinity)[- ]*(t\d{3}) bui/i, /(gigaset)[- ]+(q\w{1,9}) bui/i, /(vodafone) ([\w ]+)(?:\)| bui)/i], [w, g, [m, D]], [/(surface duo)/i], [g, [w, we], [m, D]], [/droid [\d\.]+; (fp\du?)(?: b|\))/i], [g, [w, "Fairphone"], [m, k]], [/(u304aa)/i], [g, [w, "AT&T"], [m, k]], [/\bsie-(\w*)/i], [g, [w, "Siemens"], [m, k]], [/\b(rct\w+) b/i], [g, [w, "RCA"], [m, D]], [/\b(venue[\d ]{2,7}) b/i], [g, [w, "Dell"], [m, D]], [/\b(q(?:mv|ta)\w+) b/i], [g, [w, "Verizon"], [m, D]], [/\b(?:barnes[& ]+noble |bn[rt])([\w\+ ]*) b/i], [g, [w, "Barnes & Noble"], [m, D]], [/\b(tm\d{3}\w+) b/i], [g, [w, "NuVision"], [m, D]], [/\b(k88) b/i], [g, [w, "ZTE"], [m, D]], [/\b(nx\d{3}j) b/i], [g, [w, "ZTE"], [m, k]], [/\b(gen\d{3}) b.+49h/i], [g, [w, "Swiss"], [m, k]], [/\b(zur\d{3}) b/i], [g, [w, "Swiss"], [m, D]], [/\b((zeki)?tb.*\b) b/i], [g, [w, "Zeki"], [m, D]], [/\b([yr]\d{2}) b/i, /\b(dragon[- ]+touch |dt)(\w{5}) b/i], [[w, "Dragon Touch"], g, [m, D]], [/\b(ns-?\w{0,9}) b/i], [g, [w, "Insignia"], [m, D]], [/\b((nxa|next)-?\w{0,9}) b/i], [g, [w, "NextBook"], [m, D]], [/\b(xtreme\_)?(v(1[045]|2[015]|[3469]0|7[05])) b/i], [[w, "Voice"], g, [m, k]], [/\b(lvtel\-)?(v1[12]) b/i], [[w, "LvTel"], g, [m, k]], [/\b(ph-1) /i], [g, [w, "Essential"], [m, k]], [/\b(v(100md|700na|7011|917g).*\b) b/i], [g, [w, "Envizen"], [m, D]], [/\b(trio[-\w\. ]+) b/i], [g, [w, "MachSpeed"], [m, D]], [/\btu_(1491) b/i], [g, [w, "Rotor"], [m, D]], [/(shield[\w ]+) b/i], [g, [w, "Nvidia"], [m, D]], [/(sprint) (\w+)/i], [w, g, [m, k]], [/(kin\.[onetw]{3})/i], [[g, /\./g, " "], [w, we], [m, k]], [/droid.+; (cc6666?|et5[16]|mc[239][23]x?|vc8[03]x?)\)/i], [g, [w, ae], [m, D]], [/droid.+; (ec30|ps20|tc[2-8]\d[kx])\)/i], [g, [w, ae], [m, k]], [/smart-tv.+(samsung)/i], [w, [m, T]], [/hbbtv.+maple;(\d+)/i], [[g, /^/, "SmartTV"], [w, Ce], [m, T]], [/(nux; netcast.+smarttv|lg (netcast\.tv-201\d|android tv))/i], [[w, se], [m, T]], [/(apple) ?tv/i], [w, [g, $ + " TV"], [m, T]], [/crkey/i], [[g, ee + "cast"], [w, oe], [m, T]], [/droid.+aft(\w+)( bui|\))/i], [g, [w, K], [m, T]], [/\(dtv[\);].+(aquos)/i, /(aquos-tv[\w ]+)\)/i], [g, [w, Ne], [m, T]], [/(bravia[\w ]+)( bui|\))/i], [g, [w, me], [m, T]], [/(mitv-\w{5}) bui/i], [g, [w, U], [m, T]], [/Hbbtv.*(technisat) (.*);/i], [w, g, [m, T]], [/\b(roku)[\dx]*[\)\/]((?:dvp-)?[\d\.]*)/i, /hbbtv\/\d+\.\d+\.\d+ +\([\w\+ ]*; *([\w\d][^;]*);([^;]*)/i], [[w, P], [g, P], [m, T]], [/\b(android tv|smart[- ]?tv|opera tv|tv; rv:)\b/i], [[m, T]], [/(ouya)/i, /(nintendo) ([wids3utch]+)/i], [w, g, [m, M]], [/droid.+; (shield) bui/i], [g, [w, "Nvidia"], [m, M]], [/(playstation [345portablevi]+)/i], [g, [w, me], [m, M]], [/\b(xbox(?: one)?(?!; xbox))[\); ]/i], [g, [w, we], [m, M]], [/((pebble))app/i], [w, g, [m, R]], [/(watch)(?: ?os[,\/]|\d,\d\/)[\d\.]+/i], [g, [w, $], [m, R]], [/droid.+; (glass) \d/i], [g, [w, oe], [m, R]], [/droid.+; (wt63?0{2,3})\)/i], [g, [w, ae], [m, R]], [/(quest( 2| pro)?)/i], [g, [w, G], [m, R]], [/(tesla)(?: qtcarbrowser|\/[-\w\.]+)/i], [w, [m, _]], [/(aeobc)\b/i], [g, [w, K], [m, _]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+? mobile safari/i], [g, [m, k]], [/droid .+?; ([^;]+?)(?: bui|\) applew).+?(?! mobile) safari/i], [g, [m, D]], [/\b((tablet|tab)[;\/]|focus\/\d(?!.+mobile))/i], [[m, D]], [/(phone|mobile(?:[;\/]| [ \w\/\.]*safari)|pda(?=.+windows ce))/i], [[m, k]], [/(android[-\w\. ]{0,9});.+buil/i], [g, [w, "Generic"]]], engine: [[/windows.+ edge\/([\w\.]+)/i], [b, [v, ie + "HTML"]], [/webkit\/537\.36.+chrome\/(?!27)([\w\.]+)/i], [b, [v, "Blink"]], [/(presto)\/([\w\.]+)/i, /(webkit|trident|netfront|netsurf|amaya|lynx|w3m|goanna)\/([\w\.]+)/i, /ekioh(flow)\/([\w\.]+)/i, /(khtml|tasman|links)[\/ ]\(?([\w\.]+)/i, /(icab)[\/ ]([23]\.[\d\.]+)/i, /\b(libweb)/i], [v, b], [/rv\:([\w\.]{1,9})\b.+(gecko)/i], [b, v]], os: [[/microsoft (windows) (vista|xp)/i], [v, b], [/(windows) nt 6\.2; (arm)/i, /(windows (?:phone(?: os)?|mobile))[\/ ]?([\d\.\w ]*)/i, /(windows)[\/ ]?([ntce\d\. ]+\w)(?!.+xbox)/i], [v, [b, z, ce]], [/(win(?=3|9|n)|win 9x )([nt\d\.]+)/i], [[v, "Windows"], [b, z, ce]], [/ip[honead]{2,4}\b(?:.*os ([\w]+) like mac|; opera)/i, /(?:ios;fbsv\/|iphone.+ios[\/ ])([\d\.]+)/i, /cfnetwork\/.+darwin/i], [[b, /_/g, "."], [v, "iOS"]], [/(mac os x) ?([\w\. ]*)/i, /(macintosh|mac_powerpc\b)(?!.+haiku)/i], [[v, ye], [b, /_/g, "."]], [/droid ([\w\.]+)\b.+(android[- ]x86|harmonyos)/i], [b, v], [/(android|webos|qnx|bada|rim tablet os|maemo|meego|sailfish)[-\/ ]?([\w\.]*)/i, /(blackberry)\w*\/([\w\.]*)/i, /(tizen|kaios)[\/ ]([\w\.]+)/i, /\((series40);/i], [v, b], [/\(bb(10);/i], [b, [v, Y]], [/(?:symbian ?os|symbos|s60(?=;)|series60)[-\/ ]?([\w\.]*)/i], [b, [v, "Symbian"]], [/mozilla\/[\d\.]+ \((?:mobile|tablet|tv|mobile; [\w ]+); rv:.+ gecko\/([\w\.]+)/i], [b, [v, re + " OS"]], [/web0s;.+rt(tv)/i, /\b(?:hp)?wos(?:browser)?\/([\w\.]+)/i], [b, [v, "webOS"]], [/watch(?: ?os[,\/]|\d,\d\/)([\d\.]+)/i], [b, [v, "watchOS"]], [/crkey\/([\d\.]+)/i], [b, [v, ee + "cast"]], [/(cros) [\w]+(?:\)| ([\w\.]+)\b)/i], [[v, xe], b], [/panasonic;(viera)/i, /(netrange)mmh/i, /(nettv)\/(\d+\.[\w\.]+)/i, /(nintendo|playstation) ([wids345portablevuch]+)/i, /(xbox); +xbox ([^\);]+)/i, /\b(joli|palm)\b ?(?:os)?\/?([\w\.]*)/i, /(mint)[\/\(\) ]?(\w*)/i, /(mageia|vectorlinux)[; ]/i, /([kxln]?ubuntu|debian|suse|opensuse|gentoo|arch(?= linux)|slackware|fedora|mandriva|centos|pclinuxos|red ?hat|zenwalk|linpus|raspbian|plan 9|minix|risc os|contiki|deepin|manjaro|elementary os|sabayon|linspire)(?: gnu\/linux)?(?: enterprise)?(?:[- ]linux)?(?:-gnu)?[-\/ ]?(?!chrom|package)([-\w\.]*)/i, /(hurd|linux) ?([\w\.]*)/i, /(gnu) ?([\w\.]*)/i, /\b([-frentopcghs]{0,5}bsd|dragonfly)[\/ ]?(?!amd|[ix346]{1,2}86)([\w\.]*)/i, /(haiku) (\w+)/i], [v, b], [/(sunos) ?([\w\.\d]*)/i], [[v, "Solaris"], b], [/((?:open)?solaris)[-\/ ]?([\w\.]*)/i, /(aix) ((\d)(?=\.|\)| )[\w\.])*/i, /\b(beos|os\/2|amigaos|morphos|openvms|fuchsia|hp-ux|serenityos)/i, /(unix) ?([\w\.]*)/i], [v, b]] }, _e = function(Pe, qe) {
      if (typeof Pe === d && (qe = Pe, Pe = r), !(this instanceof _e))
        return new _e(Pe, qe).getResult();
      var ve = typeof t !== u && t.navigator ? t.navigator : r, Ae = Pe || (ve && ve.userAgent ? ve.userAgent : o), ot = ve && ve.userAgentData ? ve.userAgentData : r, Ct = qe ? Je(fe, qe) : fe, Fe = ve && ve.userAgent == Ae;
      return this.getBrowser = function() {
        var De = {};
        return De[v] = r, De[b] = r, A.call(De, Ae, Ct.browser), De[p] = vt(De[b]), Fe && ve && ve.brave && typeof ve.brave.isBrave == l && (De[v] = "Brave"), De;
      }, this.getCPU = function() {
        var De = {};
        return De[C] = r, A.call(De, Ae, Ct.cpu), De;
      }, this.getDevice = function() {
        var De = {};
        return De[w] = r, De[g] = r, De[m] = r, A.call(De, Ae, Ct.device), Fe && !De[m] && ot && ot.mobile && (De[m] = k), Fe && De[g] == "Macintosh" && ve && typeof ve.standalone !== u && ve.maxTouchPoints && ve.maxTouchPoints > 2 && (De[g] = "iPad", De[m] = D), De;
      }, this.getEngine = function() {
        var De = {};
        return De[v] = r, De[b] = r, A.call(De, Ae, Ct.engine), De;
      }, this.getOS = function() {
        var De = {};
        return De[v] = r, De[b] = r, A.call(De, Ae, Ct.os), Fe && !De[v] && ot && ot.platform != "Unknown" && (De[v] = ot.platform.replace(/chrome os/i, xe).replace(/macos/i, ye)), De;
      }, this.getResult = function() {
        return { ua: this.getUA(), browser: this.getBrowser(), engine: this.getEngine(), os: this.getOS(), device: this.getDevice(), cpu: this.getCPU() };
      }, this.getUA = function() {
        return Ae;
      }, this.setUA = function(De) {
        return Ae = typeof De === h && De.length > Z ? P(De, Z) : De, this;
      }, this.setUA(Ae), this;
    };
    _e.VERSION = i, _e.BROWSER = te([v, b, p]), _e.CPU = te([C]), _e.DEVICE = te([g, w, m, M, k, T, D, R, _]), _e.ENGINE = _e.OS = te([v, b]), n.exports && (e = n.exports = _e), e.UAParser = _e;
    var tt = typeof t !== u && (t.jQuery || t.Zepto);
    if (tt && !tt.ua) {
      var Mt = new _e();
      tt.ua = Mt.getResult(), tt.ua.get = function() {
        return Mt.getUA();
      }, tt.ua.set = function(Pe) {
        Mt.setUA(Pe);
        var qe = Mt.getResult();
        for (var ve in qe)
          tt.ua[ve] = qe[ve];
      };
    }
  })(typeof window == "object" ? window : qo);
})(bf, bf.exports);
var MO = bf.exports;
Object.defineProperty(Ee, "__esModule", { value: !0 });
function RO(n) {
  return n && typeof n == "object" && "default" in n ? n.default : n;
}
var mn = yt, St = RO(mn), nv = MO, Zi = new nv(), vn = Zi.getBrowser(), DO = Zi.getCPU(), er = Zi.getDevice(), oh = Zi.getEngine(), ji = Zi.getOS(), ka = Zi.getUA(), rv = function(e) {
  return Zi.setUA(e);
}, Oa = function(e) {
  if (!e) {
    console.error("No userAgent string was provided");
    return;
  }
  var t = new nv(e);
  return {
    UA: t,
    browser: t.getBrowser(),
    cpu: t.getCPU(),
    device: t.getDevice(),
    engine: t.getEngine(),
    os: t.getOS(),
    ua: t.getUA(),
    setUserAgent: function(i) {
      return t.setUA(i);
    }
  };
}, iv = /* @__PURE__ */ Object.freeze({
  ClientUAInstance: Zi,
  browser: vn,
  cpu: DO,
  device: er,
  engine: oh,
  os: ji,
  ua: ka,
  setUa: rv,
  parseUserAgent: Oa
});
function L0(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function IO(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? L0(Object(t), !0).forEach(function(r) {
      PO(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : L0(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function Gs(n) {
  "@babel/helpers - typeof";
  return typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Gs = function(e) {
    return typeof e;
  } : Gs = function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Gs(n);
}
function AO(n, e) {
  if (!(n instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function P0(n, e) {
  for (var t = 0; t < e.length; t++) {
    var r = e[t];
    r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(n, r.key, r);
  }
}
function LO(n, e, t) {
  return e && P0(n.prototype, e), t && P0(n, t), n;
}
function PO(n, e, t) {
  return e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function xf() {
  return xf = Object.assign || function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t)
        Object.prototype.hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, xf.apply(this, arguments);
}
function _O(n, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function");
  n.prototype = Object.create(e && e.prototype, {
    constructor: {
      value: n,
      writable: !0,
      configurable: !0
    }
  }), e && Cf(n, e);
}
function Sf(n) {
  return Sf = Object.setPrototypeOf ? Object.getPrototypeOf : function(t) {
    return t.__proto__ || Object.getPrototypeOf(t);
  }, Sf(n);
}
function Cf(n, e) {
  return Cf = Object.setPrototypeOf || function(r, i) {
    return r.__proto__ = i, r;
  }, Cf(n, e);
}
function NO(n, e) {
  if (n == null)
    return {};
  var t = {}, r = Object.keys(n), i, o;
  for (o = 0; o < r.length; o++)
    i = r[o], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function vr(n, e) {
  if (n == null)
    return {};
  var t = NO(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(n);
    for (i = 0; i < o.length; i++)
      r = o[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
function jl(n) {
  if (n === void 0)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return n;
}
function zO(n, e) {
  if (e && (typeof e == "object" || typeof e == "function"))
    return e;
  if (e !== void 0)
    throw new TypeError("Derived constructors may only return object or undefined");
  return jl(n);
}
function BO(n, e) {
  return FO(n) || VO(n, e) || WO(n, e) || HO();
}
function FO(n) {
  if (Array.isArray(n))
    return n;
}
function VO(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r = [], i = !0, o = !1, a, l;
    try {
      for (t = t.call(n); !(i = (a = t.next()).done) && (r.push(a.value), !(e && r.length === e)); i = !0)
        ;
    } catch (u) {
      o = !0, l = u;
    } finally {
      try {
        !i && t.return != null && t.return();
      } finally {
        if (o)
          throw l;
      }
    }
    return r;
  }
}
function WO(n, e) {
  if (n) {
    if (typeof n == "string")
      return _0(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set")
      return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t))
      return _0(n, e);
  }
}
function _0(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++)
    r[t] = n[t];
  return r;
}
function HO() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
var fn = {
  Mobile: "mobile",
  Tablet: "tablet",
  SmartTv: "smarttv",
  Console: "console",
  Wearable: "wearable",
  Embedded: "embedded",
  Browser: void 0
}, zn = {
  Chrome: "Chrome",
  Firefox: "Firefox",
  Opera: "Opera",
  Yandex: "Yandex",
  Safari: "Safari",
  InternetExplorer: "Internet Explorer",
  Edge: "Edge",
  Chromium: "Chromium",
  Ie: "IE",
  MobileSafari: "Mobile Safari",
  EdgeChromium: "Edge Chromium",
  MIUI: "MIUI Browser",
  SamsungBrowser: "Samsung Browser"
}, ms = {
  IOS: "iOS",
  Android: "Android",
  WindowsPhone: "Windows Phone",
  Windows: "Windows",
  MAC_OS: "Mac OS"
}, $O = {
  isMobile: !1,
  isTablet: !1,
  isBrowser: !1,
  isSmartTV: !1,
  isConsole: !1,
  isWearable: !1
}, UO = function(e) {
  switch (e) {
    case fn.Mobile:
      return {
        isMobile: !0
      };
    case fn.Tablet:
      return {
        isTablet: !0
      };
    case fn.SmartTv:
      return {
        isSmartTV: !0
      };
    case fn.Console:
      return {
        isConsole: !0
      };
    case fn.Wearable:
      return {
        isWearable: !0
      };
    case fn.Browser:
      return {
        isBrowser: !0
      };
    case fn.Embedded:
      return {
        isEmbedded: !0
      };
    default:
      return $O;
  }
}, ZO = function(e) {
  return rv(e);
}, Ue = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "none";
  return e || t;
}, sh = function() {
  return typeof window < "u" && (window.navigator || navigator) ? window.navigator || navigator : !1;
}, ah = function(e) {
  var t = sh();
  return t && t.platform && (t.platform.indexOf(e) !== -1 || t.platform === "MacIntel" && t.maxTouchPoints > 1 && !window.MSStream);
}, jO = function(e, t, r, i, o) {
  return {
    isBrowser: e,
    browserMajorVersion: Ue(t.major),
    browserFullVersion: Ue(t.version),
    browserName: Ue(t.name),
    engineName: Ue(r.name),
    engineVersion: Ue(r.version),
    osName: Ue(i.name),
    osVersion: Ue(i.version),
    userAgent: Ue(o)
  };
}, N0 = function(e, t, r, i) {
  return IO({}, e, {
    vendor: Ue(t.vendor),
    model: Ue(t.model),
    os: Ue(r.name),
    osVersion: Ue(r.version),
    ua: Ue(i)
  });
}, YO = function(e, t, r, i) {
  return {
    isSmartTV: e,
    engineName: Ue(t.name),
    engineVersion: Ue(t.version),
    osName: Ue(r.name),
    osVersion: Ue(r.version),
    userAgent: Ue(i)
  };
}, qO = function(e, t, r, i) {
  return {
    isConsole: e,
    engineName: Ue(t.name),
    engineVersion: Ue(t.version),
    osName: Ue(r.name),
    osVersion: Ue(r.version),
    userAgent: Ue(i)
  };
}, GO = function(e, t, r, i) {
  return {
    isWearable: e,
    engineName: Ue(t.name),
    engineVersion: Ue(t.version),
    osName: Ue(r.name),
    osVersion: Ue(r.version),
    userAgent: Ue(i)
  };
}, KO = function(e, t, r, i, o) {
  return {
    isEmbedded: e,
    vendor: Ue(t.vendor),
    model: Ue(t.model),
    engineName: Ue(r.name),
    engineVersion: Ue(r.version),
    osName: Ue(i.name),
    osVersion: Ue(i.version),
    userAgent: Ue(o)
  };
};
function XO(n) {
  var e = n ? Oa(n) : iv, t = e.device, r = e.browser, i = e.engine, o = e.os, a = e.ua, l = UO(t.type), u = l.isBrowser, d = l.isMobile, h = l.isTablet, p = l.isSmartTV, g = l.isConsole, v = l.isWearable, m = l.isEmbedded;
  if (u)
    return jO(u, r, i, o, a);
  if (p)
    return YO(p, i, o, a);
  if (g)
    return qO(g, i, o, a);
  if (d || h)
    return N0(l, t, o, a);
  if (v)
    return GO(v, i, o, a);
  if (m)
    return KO(m, t, i, o, a);
}
var ov = function(e) {
  var t = e.type;
  return t === fn.Mobile;
}, sv = function(e) {
  var t = e.type;
  return t === fn.Tablet;
}, av = function(e) {
  var t = e.type;
  return t === fn.Mobile || t === fn.Tablet;
}, lv = function(e) {
  var t = e.type;
  return t === fn.SmartTv;
}, rc = function(e) {
  var t = e.type;
  return t === fn.Browser;
}, cv = function(e) {
  var t = e.type;
  return t === fn.Wearable;
}, uv = function(e) {
  var t = e.type;
  return t === fn.Console;
}, dv = function(e) {
  var t = e.type;
  return t === fn.Embedded;
}, fv = function(e) {
  var t = e.vendor;
  return Ue(t);
}, hv = function(e) {
  var t = e.model;
  return Ue(t);
}, pv = function(e) {
  var t = e.type;
  return Ue(t, "browser");
}, gv = function(e) {
  var t = e.name;
  return t === ms.Android;
}, mv = function(e) {
  var t = e.name;
  return t === ms.Windows;
}, vv = function(e) {
  var t = e.name;
  return t === ms.MAC_OS;
}, yv = function(e) {
  var t = e.name;
  return t === ms.WindowsPhone;
}, wv = function(e) {
  var t = e.name;
  return t === ms.IOS;
}, bv = function(e) {
  var t = e.version;
  return Ue(t);
}, xv = function(e) {
  var t = e.name;
  return Ue(t);
}, Sv = function(e) {
  var t = e.name;
  return t === zn.Chrome;
}, Cv = function(e) {
  var t = e.name;
  return t === zn.Firefox;
}, Ev = function(e) {
  var t = e.name;
  return t === zn.Chromium;
}, ic = function(e) {
  var t = e.name;
  return t === zn.Edge;
}, kv = function(e) {
  var t = e.name;
  return t === zn.Yandex;
}, Ov = function(e) {
  var t = e.name;
  return t === zn.Safari || t === zn.MobileSafari;
}, Tv = function(e) {
  var t = e.name;
  return t === zn.MobileSafari;
}, Mv = function(e) {
  var t = e.name;
  return t === zn.Opera;
}, Rv = function(e) {
  var t = e.name;
  return t === zn.InternetExplorer || t === zn.Ie;
}, Dv = function(e) {
  var t = e.name;
  return t === zn.MIUI;
}, Iv = function(e) {
  var t = e.name;
  return t === zn.SamsungBrowser;
}, Av = function(e) {
  var t = e.version;
  return Ue(t);
}, Lv = function(e) {
  var t = e.major;
  return Ue(t);
}, Pv = function(e) {
  var t = e.name;
  return Ue(t);
}, _v = function(e) {
  var t = e.name;
  return Ue(t);
}, Nv = function(e) {
  var t = e.version;
  return Ue(t);
}, zv = function() {
  var e = sh(), t = e && e.userAgent && e.userAgent.toLowerCase();
  return typeof t == "string" ? /electron/.test(t) : !1;
}, es = function(e) {
  return typeof e == "string" && e.indexOf("Edg/") !== -1;
}, Bv = function() {
  var e = sh();
  return e && (/iPad|iPhone|iPod/.test(e.platform) || e.platform === "MacIntel" && e.maxTouchPoints > 1) && !window.MSStream;
}, zr = function() {
  return ah("iPad");
}, Fv = function() {
  return ah("iPhone");
}, Vv = function() {
  return ah("iPod");
}, Wv = function(e) {
  return Ue(e);
};
function Hv(n) {
  var e = n || iv, t = e.device, r = e.browser, i = e.os, o = e.engine, a = e.ua;
  return {
    isSmartTV: lv(t),
    isConsole: uv(t),
    isWearable: cv(t),
    isEmbedded: dv(t),
    isMobileSafari: Tv(r) || zr(),
    isChromium: Ev(r),
    isMobile: av(t) || zr(),
    isMobileOnly: ov(t),
    isTablet: sv(t) || zr(),
    isBrowser: rc(t),
    isDesktop: rc(t),
    isAndroid: gv(i),
    isWinPhone: yv(i),
    isIOS: wv(i) || zr(),
    isChrome: Sv(r),
    isFirefox: Cv(r),
    isSafari: Ov(r),
    isOpera: Mv(r),
    isIE: Rv(r),
    osVersion: bv(i),
    osName: xv(i),
    fullBrowserVersion: Av(r),
    browserVersion: Lv(r),
    browserName: Pv(r),
    mobileVendor: fv(t),
    mobileModel: hv(t),
    engineName: _v(o),
    engineVersion: Nv(o),
    getUA: Wv(a),
    isEdge: ic(r) || es(a),
    isYandex: kv(r),
    deviceType: pv(t),
    isIOS13: Bv(),
    isIPad13: zr(),
    isIPhone13: Fv(),
    isIPod13: Vv(),
    isElectron: zv(),
    isEdgeChromium: es(a),
    isLegacyEdge: ic(r) && !es(a),
    isWindows: mv(i),
    isMacOs: vv(i),
    isMIUI: Dv(r),
    isSamsungBrowser: Iv(r)
  };
}
var $v = lv(er), Uv = uv(er), Zv = cv(er), JO = dv(er), QO = Tv(vn) || zr(), eT = Ev(vn), Wc = av(er) || zr(), jv = ov(er), Yv = sv(er) || zr(), qv = rc(er), tT = rc(er), Gv = gv(ji), Kv = yv(ji), Xv = wv(ji) || zr(), nT = Sv(vn), rT = Cv(vn), iT = Ov(vn), oT = Mv(vn), Jv = Rv(vn), sT = bv(ji), aT = xv(ji), lT = Av(vn), cT = Lv(vn), uT = Pv(vn), dT = fv(er), fT = hv(er), hT = _v(oh), pT = Nv(oh), gT = Wv(ka), mT = ic(vn) || es(ka), vT = kv(vn), yT = pv(er), wT = Bv(), bT = zr(), xT = Fv(), ST = Vv(), CT = zv(), ET = es(ka), kT = ic(vn) && !es(ka), OT = mv(ji), TT = vv(ji), MT = Dv(vn), RT = Iv(vn), DT = function(e) {
  if (!e || typeof e != "string") {
    console.error("No valid user agent string was provided");
    return;
  }
  var t = Oa(e), r = t.device, i = t.browser, o = t.os, a = t.engine, l = t.ua;
  return Hv({
    device: r,
    browser: i,
    os: o,
    engine: a,
    ua: l
  });
}, IT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Gv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, AT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return qv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, LT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Jv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, PT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Xv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, _T = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Wc ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, NT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Yv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, zT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Kv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, BT = function(e) {
  var t = e.renderWithFragment, r = e.children;
  e.viewClassName, e.style;
  var i = vr(e, ["renderWithFragment", "children", "viewClassName", "style"]);
  return jv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, FT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return $v ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, VT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Uv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, WT = function(e) {
  var t = e.renderWithFragment, r = e.children, i = vr(e, ["renderWithFragment", "children"]);
  return Zv ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", i, r) : null;
}, HT = function(e) {
  var t = e.renderWithFragment, r = e.children;
  e.viewClassName, e.style;
  var i = e.condition, o = vr(e, ["renderWithFragment", "children", "viewClassName", "style", "condition"]);
  return i ? t ? St.createElement(mn.Fragment, null, r) : St.createElement("div", o, r) : null;
};
function $T(n) {
  return /* @__PURE__ */ function(e) {
    _O(t, e);
    function t(r) {
      var i;
      return AO(this, t), i = zO(this, Sf(t).call(this, r)), i.isEventListenerAdded = !1, i.handleOrientationChange = i.handleOrientationChange.bind(jl(i)), i.onOrientationChange = i.onOrientationChange.bind(jl(i)), i.onPageLoad = i.onPageLoad.bind(jl(i)), i.state = {
        isLandscape: !1,
        isPortrait: !1
      }, i;
    }
    return LO(t, [{
      key: "handleOrientationChange",
      value: function() {
        this.isEventListenerAdded || (this.isEventListenerAdded = !0);
        var i = window.innerWidth > window.innerHeight ? 90 : 0;
        this.setState({
          isPortrait: i === 0,
          isLandscape: i === 90
        });
      }
    }, {
      key: "onOrientationChange",
      value: function() {
        this.handleOrientationChange();
      }
    }, {
      key: "onPageLoad",
      value: function() {
        this.handleOrientationChange();
      }
    }, {
      key: "componentDidMount",
      value: function() {
        (typeof window > "u" ? "undefined" : Gs(window)) !== void 0 && Wc && (this.isEventListenerAdded ? window.removeEventListener("load", this.onPageLoad, !1) : (this.handleOrientationChange(), window.addEventListener("load", this.onPageLoad, !1)), window.addEventListener("resize", this.onOrientationChange, !1));
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        window.removeEventListener("resize", this.onOrientationChange, !1);
      }
    }, {
      key: "render",
      value: function() {
        return St.createElement(n, xf({}, this.props, {
          isLandscape: this.state.isLandscape,
          isPortrait: this.state.isPortrait
        }));
      }
    }]), t;
  }(St.Component);
}
function UT() {
  var n = mn.useState(function() {
    var o = window.innerWidth > window.innerHeight ? 90 : 0;
    return {
      isPortrait: o === 0,
      isLandscape: o === 90,
      orientation: o === 0 ? "portrait" : "landscape"
    };
  }), e = BO(n, 2), t = e[0], r = e[1], i = mn.useCallback(function() {
    var o = window.innerWidth > window.innerHeight ? 90 : 0, a = {
      isPortrait: o === 0,
      isLandscape: o === 90,
      orientation: o === 0 ? "portrait" : "landscape"
    };
    t.orientation !== a.orientation && r(a);
  }, [t.orientation]);
  return mn.useEffect(function() {
    return (typeof window > "u" ? "undefined" : Gs(window)) !== void 0 && Wc && (i(), window.addEventListener("load", i, !1), window.addEventListener("resize", i, !1)), function() {
      window.removeEventListener("resize", i, !1), window.removeEventListener("load", i, !1);
    };
  }, [i]), t;
}
function Qv(n) {
  var e = n || window.navigator.userAgent;
  return Oa(e);
}
function ZT(n) {
  var e = n || window.navigator.userAgent, t = Qv(e), r = Hv(t);
  return [r, t];
}
Ee.AndroidView = IT;
Ee.BrowserTypes = zn;
Ee.BrowserView = AT;
Ee.ConsoleView = VT;
Ee.CustomView = HT;
Ee.IEView = LT;
Ee.IOSView = PT;
Ee.MobileOnlyView = BT;
Ee.MobileView = _T;
Ee.OsTypes = ms;
Ee.SmartTVView = FT;
Ee.TabletView = NT;
Ee.WearableView = WT;
Ee.WinPhoneView = zT;
Ee.browserName = uT;
Ee.browserVersion = cT;
Ee.deviceDetect = XO;
Ee.deviceType = yT;
Ee.engineName = hT;
Ee.engineVersion = pT;
Ee.fullBrowserVersion = lT;
Ee.getSelectorsByUserAgent = DT;
Ee.getUA = gT;
Ee.isAndroid = Gv;
Ee.isBrowser = qv;
Ee.isChrome = nT;
Ee.isChromium = eT;
Ee.isConsole = Uv;
Ee.isDesktop = tT;
Ee.isEdge = mT;
Ee.isEdgeChromium = ET;
Ee.isElectron = CT;
Ee.isEmbedded = JO;
Ee.isFirefox = rT;
Ee.isIE = Jv;
Ee.isIOS = Xv;
Ee.isIOS13 = wT;
Ee.isIPad13 = bT;
Ee.isIPhone13 = xT;
Ee.isIPod13 = ST;
Ee.isLegacyEdge = kT;
Ee.isMIUI = MT;
var jT = Ee.isMacOs = TT, Hc = Ee.isMobile = Wc;
Ee.isMobileOnly = jv;
Ee.isMobileSafari = QO;
Ee.isOpera = oT;
Ee.isSafari = iT;
Ee.isSamsungBrowser = RT;
Ee.isSmartTV = $v;
Ee.isTablet = Yv;
Ee.isWearable = Zv;
Ee.isWinPhone = Kv;
Ee.isWindows = OT;
Ee.isYandex = vT;
Ee.mobileModel = fT;
Ee.mobileVendor = dT;
Ee.osName = aT;
Ee.osVersion = sT;
Ee.parseUserAgent = Oa;
Ee.setUserAgent = ZO;
Ee.useDeviceData = Qv;
Ee.useDeviceSelectors = ZT;
Ee.useMobileOrientation = UT;
Ee.withOrientationChange = $T;
const YT = (n, e, t = "mousedown", r) => {
  const i = ge(e), o = Ie(
    (a) => {
      const l = n == null ? void 0 : n.current;
      !l || l.contains(a.target) || i.current(a);
    },
    [n, i]
  );
  be(() => (window.addEventListener(t, o, r), () => {
    window.removeEventListener(t, o, r);
  }), [o, t, r]);
};
var oc = { exports: {} };
/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
oc.exports;
(function(n, e) {
  (function() {
    var t, r = "4.17.21", i = 200, o = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", a = "Expected a function", l = "Invalid `variable` option passed into `_.template`", u = "__lodash_hash_undefined__", d = 500, h = "__lodash_placeholder__", p = 1, g = 2, v = 4, m = 1, w = 2, b = 1, C = 2, M = 4, k = 8, D = 16, T = 32, R = 64, _ = 128, Z = 256, K = 512, $ = 30, F = "...", Y = 800, Q = 16, ee = 1, ie = 2, re = 3, oe = 1 / 0, de = 9007199254740991, se = 17976931348623157e292, we = 0 / 0, Oe = 4294967295, le = Oe - 1, Ce = Oe >>> 1, Ne = [
      ["ary", _],
      ["bind", b],
      ["bindKey", C],
      ["curry", k],
      ["curryRight", D],
      ["flip", K],
      ["partial", T],
      ["partialRight", R],
      ["rearg", Z]
    ], me = "[object Arguments]", U = "[object Array]", ae = "[object AsyncFunction]", G = "[object Boolean]", xe = "[object Date]", ye = "[object DOMException]", Je = "[object Error]", te = "[object Function]", $e = "[object GeneratorFunction]", Be = "[object Map]", vt = "[object Number]", P = "[object Null]", A = "[object Object]", z = "[object Promise]", H = "[object Proxy]", ce = "[object RegExp]", fe = "[object Set]", _e = "[object String]", tt = "[object Symbol]", Mt = "[object Undefined]", Pe = "[object WeakMap]", qe = "[object WeakSet]", ve = "[object ArrayBuffer]", Ae = "[object DataView]", ot = "[object Float32Array]", Ct = "[object Float64Array]", Fe = "[object Int8Array]", De = "[object Int16Array]", on = "[object Int32Array]", Ur = "[object Uint8Array]", Zr = "[object Uint8ClampedArray]", bs = "[object Uint16Array]", Do = "[object Uint32Array]", au = /\b__p \+= '';/g, lu = /\b(__p \+=) '' \+/g, cu = /(__e\(.*?\)|\b__t\)) \+\n'';/g, zt = /&(?:amp|lt|gt|quot|#39);/g, sn = /[&<>"']/g, wn = RegExp(zt.source), Rr = RegExp(sn.source), Mn = /<%-([\s\S]+?)%>/g, Bn = /<%([\s\S]+?)%>/g, Fn = /<%=([\s\S]+?)%>/g, fi = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, Vn = /^\w*$/, Gi = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g, jr = /[\\^$.*+?()[\]{}|]/g, Io = RegExp(jr.source), hi = /^\s+/, Fa = /\s/, Ki = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, Xi = /\{\n\/\* \[wrapped with (.+)\] \*/, xs = /,? & /, zb = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g, Bb = /[()=,{}\[\]\/\s]/, Fb = /\\(\\)?/g, Vb = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g, $h = /\w*$/, Wb = /^[-+]0x[0-9a-f]+$/i, Hb = /^0b[01]+$/i, $b = /^\[object .+?Constructor\]$/, Ub = /^0o[0-7]+$/i, Zb = /^(?:0|[1-9]\d*)$/, jb = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g, Va = /($^)/, Yb = /['\n\r\u2028\u2029\\]/g, Wa = "\\ud800-\\udfff", qb = "\\u0300-\\u036f", Gb = "\\ufe20-\\ufe2f", Kb = "\\u20d0-\\u20ff", Uh = qb + Gb + Kb, Zh = "\\u2700-\\u27bf", jh = "a-z\\xdf-\\xf6\\xf8-\\xff", Xb = "\\xac\\xb1\\xd7\\xf7", Jb = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", Qb = "\\u2000-\\u206f", ex = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", Yh = "A-Z\\xc0-\\xd6\\xd8-\\xde", qh = "\\ufe0e\\ufe0f", Gh = Xb + Jb + Qb + ex, uu = "['’]", tx = "[" + Wa + "]", Kh = "[" + Gh + "]", Ha = "[" + Uh + "]", Xh = "\\d+", nx = "[" + Zh + "]", Jh = "[" + jh + "]", Qh = "[^" + Wa + Gh + Xh + Zh + jh + Yh + "]", du = "\\ud83c[\\udffb-\\udfff]", rx = "(?:" + Ha + "|" + du + ")", ep = "[^" + Wa + "]", fu = "(?:\\ud83c[\\udde6-\\uddff]){2}", hu = "[\\ud800-\\udbff][\\udc00-\\udfff]", Ao = "[" + Yh + "]", tp = "\\u200d", np = "(?:" + Jh + "|" + Qh + ")", ix = "(?:" + Ao + "|" + Qh + ")", rp = "(?:" + uu + "(?:d|ll|m|re|s|t|ve))?", ip = "(?:" + uu + "(?:D|LL|M|RE|S|T|VE))?", op = rx + "?", sp = "[" + qh + "]?", ox = "(?:" + tp + "(?:" + [ep, fu, hu].join("|") + ")" + sp + op + ")*", sx = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", ax = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", ap = sp + op + ox, lx = "(?:" + [nx, fu, hu].join("|") + ")" + ap, cx = "(?:" + [ep + Ha + "?", Ha, fu, hu, tx].join("|") + ")", ux = RegExp(uu, "g"), dx = RegExp(Ha, "g"), pu = RegExp(du + "(?=" + du + ")|" + cx + ap, "g"), fx = RegExp([
      Ao + "?" + Jh + "+" + rp + "(?=" + [Kh, Ao, "$"].join("|") + ")",
      ix + "+" + ip + "(?=" + [Kh, Ao + np, "$"].join("|") + ")",
      Ao + "?" + np + "+" + rp,
      Ao + "+" + ip,
      ax,
      sx,
      Xh,
      lx
    ].join("|"), "g"), hx = RegExp("[" + tp + Wa + Uh + qh + "]"), px = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/, gx = [
      "Array",
      "Buffer",
      "DataView",
      "Date",
      "Error",
      "Float32Array",
      "Float64Array",
      "Function",
      "Int8Array",
      "Int16Array",
      "Int32Array",
      "Map",
      "Math",
      "Object",
      "Promise",
      "RegExp",
      "Set",
      "String",
      "Symbol",
      "TypeError",
      "Uint8Array",
      "Uint8ClampedArray",
      "Uint16Array",
      "Uint32Array",
      "WeakMap",
      "_",
      "clearTimeout",
      "isFinite",
      "parseInt",
      "setTimeout"
    ], mx = -1, Et = {};
    Et[ot] = Et[Ct] = Et[Fe] = Et[De] = Et[on] = Et[Ur] = Et[Zr] = Et[bs] = Et[Do] = !0, Et[me] = Et[U] = Et[ve] = Et[G] = Et[Ae] = Et[xe] = Et[Je] = Et[te] = Et[Be] = Et[vt] = Et[A] = Et[ce] = Et[fe] = Et[_e] = Et[Pe] = !1;
    var xt = {};
    xt[me] = xt[U] = xt[ve] = xt[Ae] = xt[G] = xt[xe] = xt[ot] = xt[Ct] = xt[Fe] = xt[De] = xt[on] = xt[Be] = xt[vt] = xt[A] = xt[ce] = xt[fe] = xt[_e] = xt[tt] = xt[Ur] = xt[Zr] = xt[bs] = xt[Do] = !0, xt[Je] = xt[te] = xt[Pe] = !1;
    var vx = {
      // Latin-1 Supplement block.
      À: "A",
      Á: "A",
      Â: "A",
      Ã: "A",
      Ä: "A",
      Å: "A",
      à: "a",
      á: "a",
      â: "a",
      ã: "a",
      ä: "a",
      å: "a",
      Ç: "C",
      ç: "c",
      Ð: "D",
      ð: "d",
      È: "E",
      É: "E",
      Ê: "E",
      Ë: "E",
      è: "e",
      é: "e",
      ê: "e",
      ë: "e",
      Ì: "I",
      Í: "I",
      Î: "I",
      Ï: "I",
      ì: "i",
      í: "i",
      î: "i",
      ï: "i",
      Ñ: "N",
      ñ: "n",
      Ò: "O",
      Ó: "O",
      Ô: "O",
      Õ: "O",
      Ö: "O",
      Ø: "O",
      ò: "o",
      ó: "o",
      ô: "o",
      õ: "o",
      ö: "o",
      ø: "o",
      Ù: "U",
      Ú: "U",
      Û: "U",
      Ü: "U",
      ù: "u",
      ú: "u",
      û: "u",
      ü: "u",
      Ý: "Y",
      ý: "y",
      ÿ: "y",
      Æ: "Ae",
      æ: "ae",
      Þ: "Th",
      þ: "th",
      ß: "ss",
      // Latin Extended-A block.
      Ā: "A",
      Ă: "A",
      Ą: "A",
      ā: "a",
      ă: "a",
      ą: "a",
      Ć: "C",
      Ĉ: "C",
      Ċ: "C",
      Č: "C",
      ć: "c",
      ĉ: "c",
      ċ: "c",
      č: "c",
      Ď: "D",
      Đ: "D",
      ď: "d",
      đ: "d",
      Ē: "E",
      Ĕ: "E",
      Ė: "E",
      Ę: "E",
      Ě: "E",
      ē: "e",
      ĕ: "e",
      ė: "e",
      ę: "e",
      ě: "e",
      Ĝ: "G",
      Ğ: "G",
      Ġ: "G",
      Ģ: "G",
      ĝ: "g",
      ğ: "g",
      ġ: "g",
      ģ: "g",
      Ĥ: "H",
      Ħ: "H",
      ĥ: "h",
      ħ: "h",
      Ĩ: "I",
      Ī: "I",
      Ĭ: "I",
      Į: "I",
      İ: "I",
      ĩ: "i",
      ī: "i",
      ĭ: "i",
      į: "i",
      ı: "i",
      Ĵ: "J",
      ĵ: "j",
      Ķ: "K",
      ķ: "k",
      ĸ: "k",
      Ĺ: "L",
      Ļ: "L",
      Ľ: "L",
      Ŀ: "L",
      Ł: "L",
      ĺ: "l",
      ļ: "l",
      ľ: "l",
      ŀ: "l",
      ł: "l",
      Ń: "N",
      Ņ: "N",
      Ň: "N",
      Ŋ: "N",
      ń: "n",
      ņ: "n",
      ň: "n",
      ŋ: "n",
      Ō: "O",
      Ŏ: "O",
      Ő: "O",
      ō: "o",
      ŏ: "o",
      ő: "o",
      Ŕ: "R",
      Ŗ: "R",
      Ř: "R",
      ŕ: "r",
      ŗ: "r",
      ř: "r",
      Ś: "S",
      Ŝ: "S",
      Ş: "S",
      Š: "S",
      ś: "s",
      ŝ: "s",
      ş: "s",
      š: "s",
      Ţ: "T",
      Ť: "T",
      Ŧ: "T",
      ţ: "t",
      ť: "t",
      ŧ: "t",
      Ũ: "U",
      Ū: "U",
      Ŭ: "U",
      Ů: "U",
      Ű: "U",
      Ų: "U",
      ũ: "u",
      ū: "u",
      ŭ: "u",
      ů: "u",
      ű: "u",
      ų: "u",
      Ŵ: "W",
      ŵ: "w",
      Ŷ: "Y",
      ŷ: "y",
      Ÿ: "Y",
      Ź: "Z",
      Ż: "Z",
      Ž: "Z",
      ź: "z",
      ż: "z",
      ž: "z",
      Ĳ: "IJ",
      ĳ: "ij",
      Œ: "Oe",
      œ: "oe",
      ŉ: "'n",
      ſ: "s"
    }, yx = {
      "&": "&amp;",
      "<": "&lt;",
      ">": "&gt;",
      '"': "&quot;",
      "'": "&#39;"
    }, wx = {
      "&amp;": "&",
      "&lt;": "<",
      "&gt;": ">",
      "&quot;": '"',
      "&#39;": "'"
    }, bx = {
      "\\": "\\",
      "'": "'",
      "\n": "n",
      "\r": "r",
      "\u2028": "u2028",
      "\u2029": "u2029"
    }, xx = parseFloat, Sx = parseInt, lp = typeof qo == "object" && qo && qo.Object === Object && qo, Cx = typeof self == "object" && self && self.Object === Object && self, Xt = lp || Cx || Function("return this")(), gu = e && !e.nodeType && e, Ji = gu && !0 && n && !n.nodeType && n, cp = Ji && Ji.exports === gu, mu = cp && lp.process, tr = function() {
      try {
        var N = Ji && Ji.require && Ji.require("util").types;
        return N || mu && mu.binding && mu.binding("util");
      } catch {
      }
    }(), up = tr && tr.isArrayBuffer, dp = tr && tr.isDate, fp = tr && tr.isMap, hp = tr && tr.isRegExp, pp = tr && tr.isSet, gp = tr && tr.isTypedArray;
    function Wn(N, j, V) {
      switch (V.length) {
        case 0:
          return N.call(j);
        case 1:
          return N.call(j, V[0]);
        case 2:
          return N.call(j, V[0], V[1]);
        case 3:
          return N.call(j, V[0], V[1], V[2]);
      }
      return N.apply(j, V);
    }
    function Ex(N, j, V, Se) {
      for (var Ze = -1, st = N == null ? 0 : N.length; ++Ze < st; ) {
        var Ht = N[Ze];
        j(Se, Ht, V(Ht), N);
      }
      return Se;
    }
    function nr(N, j) {
      for (var V = -1, Se = N == null ? 0 : N.length; ++V < Se && j(N[V], V, N) !== !1; )
        ;
      return N;
    }
    function kx(N, j) {
      for (var V = N == null ? 0 : N.length; V-- && j(N[V], V, N) !== !1; )
        ;
      return N;
    }
    function mp(N, j) {
      for (var V = -1, Se = N == null ? 0 : N.length; ++V < Se; )
        if (!j(N[V], V, N))
          return !1;
      return !0;
    }
    function pi(N, j) {
      for (var V = -1, Se = N == null ? 0 : N.length, Ze = 0, st = []; ++V < Se; ) {
        var Ht = N[V];
        j(Ht, V, N) && (st[Ze++] = Ht);
      }
      return st;
    }
    function $a(N, j) {
      var V = N == null ? 0 : N.length;
      return !!V && Lo(N, j, 0) > -1;
    }
    function vu(N, j, V) {
      for (var Se = -1, Ze = N == null ? 0 : N.length; ++Se < Ze; )
        if (V(j, N[Se]))
          return !0;
      return !1;
    }
    function Ot(N, j) {
      for (var V = -1, Se = N == null ? 0 : N.length, Ze = Array(Se); ++V < Se; )
        Ze[V] = j(N[V], V, N);
      return Ze;
    }
    function gi(N, j) {
      for (var V = -1, Se = j.length, Ze = N.length; ++V < Se; )
        N[Ze + V] = j[V];
      return N;
    }
    function yu(N, j, V, Se) {
      var Ze = -1, st = N == null ? 0 : N.length;
      for (Se && st && (V = N[++Ze]); ++Ze < st; )
        V = j(V, N[Ze], Ze, N);
      return V;
    }
    function Ox(N, j, V, Se) {
      var Ze = N == null ? 0 : N.length;
      for (Se && Ze && (V = N[--Ze]); Ze--; )
        V = j(V, N[Ze], Ze, N);
      return V;
    }
    function wu(N, j) {
      for (var V = -1, Se = N == null ? 0 : N.length; ++V < Se; )
        if (j(N[V], V, N))
          return !0;
      return !1;
    }
    var Tx = bu("length");
    function Mx(N) {
      return N.split("");
    }
    function Rx(N) {
      return N.match(zb) || [];
    }
    function vp(N, j, V) {
      var Se;
      return V(N, function(Ze, st, Ht) {
        if (j(Ze, st, Ht))
          return Se = st, !1;
      }), Se;
    }
    function Ua(N, j, V, Se) {
      for (var Ze = N.length, st = V + (Se ? 1 : -1); Se ? st-- : ++st < Ze; )
        if (j(N[st], st, N))
          return st;
      return -1;
    }
    function Lo(N, j, V) {
      return j === j ? Wx(N, j, V) : Ua(N, yp, V);
    }
    function Dx(N, j, V, Se) {
      for (var Ze = V - 1, st = N.length; ++Ze < st; )
        if (Se(N[Ze], j))
          return Ze;
      return -1;
    }
    function yp(N) {
      return N !== N;
    }
    function wp(N, j) {
      var V = N == null ? 0 : N.length;
      return V ? Su(N, j) / V : we;
    }
    function bu(N) {
      return function(j) {
        return j == null ? t : j[N];
      };
    }
    function xu(N) {
      return function(j) {
        return N == null ? t : N[j];
      };
    }
    function bp(N, j, V, Se, Ze) {
      return Ze(N, function(st, Ht, wt) {
        V = Se ? (Se = !1, st) : j(V, st, Ht, wt);
      }), V;
    }
    function Ix(N, j) {
      var V = N.length;
      for (N.sort(j); V--; )
        N[V] = N[V].value;
      return N;
    }
    function Su(N, j) {
      for (var V, Se = -1, Ze = N.length; ++Se < Ze; ) {
        var st = j(N[Se]);
        st !== t && (V = V === t ? st : V + st);
      }
      return V;
    }
    function Cu(N, j) {
      for (var V = -1, Se = Array(N); ++V < N; )
        Se[V] = j(V);
      return Se;
    }
    function Ax(N, j) {
      return Ot(j, function(V) {
        return [V, N[V]];
      });
    }
    function xp(N) {
      return N && N.slice(0, kp(N) + 1).replace(hi, "");
    }
    function Hn(N) {
      return function(j) {
        return N(j);
      };
    }
    function Eu(N, j) {
      return Ot(j, function(V) {
        return N[V];
      });
    }
    function Ss(N, j) {
      return N.has(j);
    }
    function Sp(N, j) {
      for (var V = -1, Se = N.length; ++V < Se && Lo(j, N[V], 0) > -1; )
        ;
      return V;
    }
    function Cp(N, j) {
      for (var V = N.length; V-- && Lo(j, N[V], 0) > -1; )
        ;
      return V;
    }
    function Lx(N, j) {
      for (var V = N.length, Se = 0; V--; )
        N[V] === j && ++Se;
      return Se;
    }
    var Px = xu(vx), _x = xu(yx);
    function Nx(N) {
      return "\\" + bx[N];
    }
    function zx(N, j) {
      return N == null ? t : N[j];
    }
    function Po(N) {
      return hx.test(N);
    }
    function Bx(N) {
      return px.test(N);
    }
    function Fx(N) {
      for (var j, V = []; !(j = N.next()).done; )
        V.push(j.value);
      return V;
    }
    function ku(N) {
      var j = -1, V = Array(N.size);
      return N.forEach(function(Se, Ze) {
        V[++j] = [Ze, Se];
      }), V;
    }
    function Ep(N, j) {
      return function(V) {
        return N(j(V));
      };
    }
    function mi(N, j) {
      for (var V = -1, Se = N.length, Ze = 0, st = []; ++V < Se; ) {
        var Ht = N[V];
        (Ht === j || Ht === h) && (N[V] = h, st[Ze++] = V);
      }
      return st;
    }
    function Za(N) {
      var j = -1, V = Array(N.size);
      return N.forEach(function(Se) {
        V[++j] = Se;
      }), V;
    }
    function Vx(N) {
      var j = -1, V = Array(N.size);
      return N.forEach(function(Se) {
        V[++j] = [Se, Se];
      }), V;
    }
    function Wx(N, j, V) {
      for (var Se = V - 1, Ze = N.length; ++Se < Ze; )
        if (N[Se] === j)
          return Se;
      return -1;
    }
    function Hx(N, j, V) {
      for (var Se = V + 1; Se--; )
        if (N[Se] === j)
          return Se;
      return Se;
    }
    function _o(N) {
      return Po(N) ? Ux(N) : Tx(N);
    }
    function yr(N) {
      return Po(N) ? Zx(N) : Mx(N);
    }
    function kp(N) {
      for (var j = N.length; j-- && Fa.test(N.charAt(j)); )
        ;
      return j;
    }
    var $x = xu(wx);
    function Ux(N) {
      for (var j = pu.lastIndex = 0; pu.test(N); )
        ++j;
      return j;
    }
    function Zx(N) {
      return N.match(pu) || [];
    }
    function jx(N) {
      return N.match(fx) || [];
    }
    var Yx = function N(j) {
      j = j == null ? Xt : No.defaults(Xt.Object(), j, No.pick(Xt, gx));
      var V = j.Array, Se = j.Date, Ze = j.Error, st = j.Function, Ht = j.Math, wt = j.Object, Ou = j.RegExp, qx = j.String, rr = j.TypeError, ja = V.prototype, Gx = st.prototype, zo = wt.prototype, Ya = j["__core-js_shared__"], qa = Gx.toString, mt = zo.hasOwnProperty, Kx = 0, Op = function() {
        var s = /[^.]+$/.exec(Ya && Ya.keys && Ya.keys.IE_PROTO || "");
        return s ? "Symbol(src)_1." + s : "";
      }(), Ga = zo.toString, Xx = qa.call(wt), Jx = Xt._, Qx = Ou(
        "^" + qa.call(mt).replace(jr, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
      ), Ka = cp ? j.Buffer : t, yi = j.Symbol, Xa = j.Uint8Array, Tp = Ka ? Ka.allocUnsafe : t, Ja = Ep(wt.getPrototypeOf, wt), Mp = wt.create, Rp = zo.propertyIsEnumerable, Qa = ja.splice, Dp = yi ? yi.isConcatSpreadable : t, Cs = yi ? yi.iterator : t, Qi = yi ? yi.toStringTag : t, el = function() {
        try {
          var s = io(wt, "defineProperty");
          return s({}, "", {}), s;
        } catch {
        }
      }(), eS = j.clearTimeout !== Xt.clearTimeout && j.clearTimeout, tS = Se && Se.now !== Xt.Date.now && Se.now, nS = j.setTimeout !== Xt.setTimeout && j.setTimeout, tl = Ht.ceil, nl = Ht.floor, Tu = wt.getOwnPropertySymbols, rS = Ka ? Ka.isBuffer : t, Ip = j.isFinite, iS = ja.join, oS = Ep(wt.keys, wt), $t = Ht.max, an = Ht.min, sS = Se.now, aS = j.parseInt, Ap = Ht.random, lS = ja.reverse, Mu = io(j, "DataView"), Es = io(j, "Map"), Ru = io(j, "Promise"), Bo = io(j, "Set"), ks = io(j, "WeakMap"), Os = io(wt, "create"), rl = ks && new ks(), Fo = {}, cS = oo(Mu), uS = oo(Es), dS = oo(Ru), fS = oo(Bo), hS = oo(ks), il = yi ? yi.prototype : t, Ts = il ? il.valueOf : t, Lp = il ? il.toString : t;
      function E(s) {
        if (At(s) && !Ye(s) && !(s instanceof et)) {
          if (s instanceof ir)
            return s;
          if (mt.call(s, "__wrapped__"))
            return Pg(s);
        }
        return new ir(s);
      }
      var Vo = function() {
        function s() {
        }
        return function(c) {
          if (!Rt(c))
            return {};
          if (Mp)
            return Mp(c);
          s.prototype = c;
          var f = new s();
          return s.prototype = t, f;
        };
      }();
      function ol() {
      }
      function ir(s, c) {
        this.__wrapped__ = s, this.__actions__ = [], this.__chain__ = !!c, this.__index__ = 0, this.__values__ = t;
      }
      E.templateSettings = {
        /**
         * Used to detect `data` property values to be HTML-escaped.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        escape: Mn,
        /**
         * Used to detect code to be evaluated.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        evaluate: Bn,
        /**
         * Used to detect `data` property values to inject.
         *
         * @memberOf _.templateSettings
         * @type {RegExp}
         */
        interpolate: Fn,
        /**
         * Used to reference the data object in the template text.
         *
         * @memberOf _.templateSettings
         * @type {string}
         */
        variable: "",
        /**
         * Used to import variables into the compiled template.
         *
         * @memberOf _.templateSettings
         * @type {Object}
         */
        imports: {
          /**
           * A reference to the `lodash` function.
           *
           * @memberOf _.templateSettings.imports
           * @type {Function}
           */
          _: E
        }
      }, E.prototype = ol.prototype, E.prototype.constructor = E, ir.prototype = Vo(ol.prototype), ir.prototype.constructor = ir;
      function et(s) {
        this.__wrapped__ = s, this.__actions__ = [], this.__dir__ = 1, this.__filtered__ = !1, this.__iteratees__ = [], this.__takeCount__ = Oe, this.__views__ = [];
      }
      function pS() {
        var s = new et(this.__wrapped__);
        return s.__actions__ = Rn(this.__actions__), s.__dir__ = this.__dir__, s.__filtered__ = this.__filtered__, s.__iteratees__ = Rn(this.__iteratees__), s.__takeCount__ = this.__takeCount__, s.__views__ = Rn(this.__views__), s;
      }
      function gS() {
        if (this.__filtered__) {
          var s = new et(this);
          s.__dir__ = -1, s.__filtered__ = !0;
        } else
          s = this.clone(), s.__dir__ *= -1;
        return s;
      }
      function mS() {
        var s = this.__wrapped__.value(), c = this.__dir__, f = Ye(s), y = c < 0, S = f ? s.length : 0, O = M2(0, S, this.__views__), I = O.start, L = O.end, B = L - I, X = y ? L : I - 1, J = this.__iteratees__, ne = J.length, he = 0, Me = an(B, this.__takeCount__);
        if (!f || !y && S == B && Me == B)
          return rg(s, this.__actions__);
        var Ve = [];
        e:
          for (; B-- && he < Me; ) {
            X += c;
            for (var Ke = -1, We = s[X]; ++Ke < ne; ) {
              var Qe = J[Ke], nt = Qe.iteratee, Zn = Qe.type, Sn = nt(We);
              if (Zn == ie)
                We = Sn;
              else if (!Sn) {
                if (Zn == ee)
                  continue e;
                break e;
              }
            }
            Ve[he++] = We;
          }
        return Ve;
      }
      et.prototype = Vo(ol.prototype), et.prototype.constructor = et;
      function eo(s) {
        var c = -1, f = s == null ? 0 : s.length;
        for (this.clear(); ++c < f; ) {
          var y = s[c];
          this.set(y[0], y[1]);
        }
      }
      function vS() {
        this.__data__ = Os ? Os(null) : {}, this.size = 0;
      }
      function yS(s) {
        var c = this.has(s) && delete this.__data__[s];
        return this.size -= c ? 1 : 0, c;
      }
      function wS(s) {
        var c = this.__data__;
        if (Os) {
          var f = c[s];
          return f === u ? t : f;
        }
        return mt.call(c, s) ? c[s] : t;
      }
      function bS(s) {
        var c = this.__data__;
        return Os ? c[s] !== t : mt.call(c, s);
      }
      function xS(s, c) {
        var f = this.__data__;
        return this.size += this.has(s) ? 0 : 1, f[s] = Os && c === t ? u : c, this;
      }
      eo.prototype.clear = vS, eo.prototype.delete = yS, eo.prototype.get = wS, eo.prototype.has = bS, eo.prototype.set = xS;
      function Yr(s) {
        var c = -1, f = s == null ? 0 : s.length;
        for (this.clear(); ++c < f; ) {
          var y = s[c];
          this.set(y[0], y[1]);
        }
      }
      function SS() {
        this.__data__ = [], this.size = 0;
      }
      function CS(s) {
        var c = this.__data__, f = sl(c, s);
        if (f < 0)
          return !1;
        var y = c.length - 1;
        return f == y ? c.pop() : Qa.call(c, f, 1), --this.size, !0;
      }
      function ES(s) {
        var c = this.__data__, f = sl(c, s);
        return f < 0 ? t : c[f][1];
      }
      function kS(s) {
        return sl(this.__data__, s) > -1;
      }
      function OS(s, c) {
        var f = this.__data__, y = sl(f, s);
        return y < 0 ? (++this.size, f.push([s, c])) : f[y][1] = c, this;
      }
      Yr.prototype.clear = SS, Yr.prototype.delete = CS, Yr.prototype.get = ES, Yr.prototype.has = kS, Yr.prototype.set = OS;
      function qr(s) {
        var c = -1, f = s == null ? 0 : s.length;
        for (this.clear(); ++c < f; ) {
          var y = s[c];
          this.set(y[0], y[1]);
        }
      }
      function TS() {
        this.size = 0, this.__data__ = {
          hash: new eo(),
          map: new (Es || Yr)(),
          string: new eo()
        };
      }
      function MS(s) {
        var c = yl(this, s).delete(s);
        return this.size -= c ? 1 : 0, c;
      }
      function RS(s) {
        return yl(this, s).get(s);
      }
      function DS(s) {
        return yl(this, s).has(s);
      }
      function IS(s, c) {
        var f = yl(this, s), y = f.size;
        return f.set(s, c), this.size += f.size == y ? 0 : 1, this;
      }
      qr.prototype.clear = TS, qr.prototype.delete = MS, qr.prototype.get = RS, qr.prototype.has = DS, qr.prototype.set = IS;
      function to(s) {
        var c = -1, f = s == null ? 0 : s.length;
        for (this.__data__ = new qr(); ++c < f; )
          this.add(s[c]);
      }
      function AS(s) {
        return this.__data__.set(s, u), this;
      }
      function LS(s) {
        return this.__data__.has(s);
      }
      to.prototype.add = to.prototype.push = AS, to.prototype.has = LS;
      function wr(s) {
        var c = this.__data__ = new Yr(s);
        this.size = c.size;
      }
      function PS() {
        this.__data__ = new Yr(), this.size = 0;
      }
      function _S(s) {
        var c = this.__data__, f = c.delete(s);
        return this.size = c.size, f;
      }
      function NS(s) {
        return this.__data__.get(s);
      }
      function zS(s) {
        return this.__data__.has(s);
      }
      function BS(s, c) {
        var f = this.__data__;
        if (f instanceof Yr) {
          var y = f.__data__;
          if (!Es || y.length < i - 1)
            return y.push([s, c]), this.size = ++f.size, this;
          f = this.__data__ = new qr(y);
        }
        return f.set(s, c), this.size = f.size, this;
      }
      wr.prototype.clear = PS, wr.prototype.delete = _S, wr.prototype.get = NS, wr.prototype.has = zS, wr.prototype.set = BS;
      function Pp(s, c) {
        var f = Ye(s), y = !f && so(s), S = !f && !y && Ci(s), O = !f && !y && !S && Uo(s), I = f || y || S || O, L = I ? Cu(s.length, qx) : [], B = L.length;
        for (var X in s)
          (c || mt.call(s, X)) && !(I && // Safari 9 has enumerable `arguments.length` in strict mode.
          (X == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
          S && (X == "offset" || X == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
          O && (X == "buffer" || X == "byteLength" || X == "byteOffset") || // Skip index properties.
          Jr(X, B))) && L.push(X);
        return L;
      }
      function _p(s) {
        var c = s.length;
        return c ? s[Vu(0, c - 1)] : t;
      }
      function FS(s, c) {
        return wl(Rn(s), no(c, 0, s.length));
      }
      function VS(s) {
        return wl(Rn(s));
      }
      function Du(s, c, f) {
        (f !== t && !br(s[c], f) || f === t && !(c in s)) && Gr(s, c, f);
      }
      function Ms(s, c, f) {
        var y = s[c];
        (!(mt.call(s, c) && br(y, f)) || f === t && !(c in s)) && Gr(s, c, f);
      }
      function sl(s, c) {
        for (var f = s.length; f--; )
          if (br(s[f][0], c))
            return f;
        return -1;
      }
      function WS(s, c, f, y) {
        return wi(s, function(S, O, I) {
          c(y, S, f(S), I);
        }), y;
      }
      function Np(s, c) {
        return s && Ir(c, qt(c), s);
      }
      function HS(s, c) {
        return s && Ir(c, In(c), s);
      }
      function Gr(s, c, f) {
        c == "__proto__" && el ? el(s, c, {
          configurable: !0,
          enumerable: !0,
          value: f,
          writable: !0
        }) : s[c] = f;
      }
      function Iu(s, c) {
        for (var f = -1, y = c.length, S = V(y), O = s == null; ++f < y; )
          S[f] = O ? t : dd(s, c[f]);
        return S;
      }
      function no(s, c, f) {
        return s === s && (f !== t && (s = s <= f ? s : f), c !== t && (s = s >= c ? s : c)), s;
      }
      function or(s, c, f, y, S, O) {
        var I, L = c & p, B = c & g, X = c & v;
        if (f && (I = S ? f(s, y, S, O) : f(s)), I !== t)
          return I;
        if (!Rt(s))
          return s;
        var J = Ye(s);
        if (J) {
          if (I = D2(s), !L)
            return Rn(s, I);
        } else {
          var ne = ln(s), he = ne == te || ne == $e;
          if (Ci(s))
            return sg(s, L);
          if (ne == A || ne == me || he && !S) {
            if (I = B || he ? {} : kg(s), !L)
              return B ? w2(s, HS(I, s)) : y2(s, Np(I, s));
          } else {
            if (!xt[ne])
              return S ? s : {};
            I = I2(s, ne, L);
          }
        }
        O || (O = new wr());
        var Me = O.get(s);
        if (Me)
          return Me;
        O.set(s, I), e0(s) ? s.forEach(function(We) {
          I.add(or(We, c, f, We, s, O));
        }) : Jg(s) && s.forEach(function(We, Qe) {
          I.set(Qe, or(We, c, f, Qe, s, O));
        });
        var Ve = X ? B ? Xu : Ku : B ? In : qt, Ke = J ? t : Ve(s);
        return nr(Ke || s, function(We, Qe) {
          Ke && (Qe = We, We = s[Qe]), Ms(I, Qe, or(We, c, f, Qe, s, O));
        }), I;
      }
      function $S(s) {
        var c = qt(s);
        return function(f) {
          return zp(f, s, c);
        };
      }
      function zp(s, c, f) {
        var y = f.length;
        if (s == null)
          return !y;
        for (s = wt(s); y--; ) {
          var S = f[y], O = c[S], I = s[S];
          if (I === t && !(S in s) || !O(I))
            return !1;
        }
        return !0;
      }
      function Bp(s, c, f) {
        if (typeof s != "function")
          throw new rr(a);
        return _s(function() {
          s.apply(t, f);
        }, c);
      }
      function Rs(s, c, f, y) {
        var S = -1, O = $a, I = !0, L = s.length, B = [], X = c.length;
        if (!L)
          return B;
        f && (c = Ot(c, Hn(f))), y ? (O = vu, I = !1) : c.length >= i && (O = Ss, I = !1, c = new to(c));
        e:
          for (; ++S < L; ) {
            var J = s[S], ne = f == null ? J : f(J);
            if (J = y || J !== 0 ? J : 0, I && ne === ne) {
              for (var he = X; he--; )
                if (c[he] === ne)
                  continue e;
              B.push(J);
            } else
              O(c, ne, y) || B.push(J);
          }
        return B;
      }
      var wi = dg(Dr), Fp = dg(Lu, !0);
      function US(s, c) {
        var f = !0;
        return wi(s, function(y, S, O) {
          return f = !!c(y, S, O), f;
        }), f;
      }
      function al(s, c, f) {
        for (var y = -1, S = s.length; ++y < S; ) {
          var O = s[y], I = c(O);
          if (I != null && (L === t ? I === I && !Un(I) : f(I, L)))
            var L = I, B = O;
        }
        return B;
      }
      function ZS(s, c, f, y) {
        var S = s.length;
        for (f = Ge(f), f < 0 && (f = -f > S ? 0 : S + f), y = y === t || y > S ? S : Ge(y), y < 0 && (y += S), y = f > y ? 0 : n0(y); f < y; )
          s[f++] = c;
        return s;
      }
      function Vp(s, c) {
        var f = [];
        return wi(s, function(y, S, O) {
          c(y, S, O) && f.push(y);
        }), f;
      }
      function Jt(s, c, f, y, S) {
        var O = -1, I = s.length;
        for (f || (f = L2), S || (S = []); ++O < I; ) {
          var L = s[O];
          c > 0 && f(L) ? c > 1 ? Jt(L, c - 1, f, y, S) : gi(S, L) : y || (S[S.length] = L);
        }
        return S;
      }
      var Au = fg(), Wp = fg(!0);
      function Dr(s, c) {
        return s && Au(s, c, qt);
      }
      function Lu(s, c) {
        return s && Wp(s, c, qt);
      }
      function ll(s, c) {
        return pi(c, function(f) {
          return Qr(s[f]);
        });
      }
      function ro(s, c) {
        c = xi(c, s);
        for (var f = 0, y = c.length; s != null && f < y; )
          s = s[Ar(c[f++])];
        return f && f == y ? s : t;
      }
      function Hp(s, c, f) {
        var y = c(s);
        return Ye(s) ? y : gi(y, f(s));
      }
      function bn(s) {
        return s == null ? s === t ? Mt : P : Qi && Qi in wt(s) ? T2(s) : V2(s);
      }
      function Pu(s, c) {
        return s > c;
      }
      function jS(s, c) {
        return s != null && mt.call(s, c);
      }
      function YS(s, c) {
        return s != null && c in wt(s);
      }
      function qS(s, c, f) {
        return s >= an(c, f) && s < $t(c, f);
      }
      function _u(s, c, f) {
        for (var y = f ? vu : $a, S = s[0].length, O = s.length, I = O, L = V(O), B = 1 / 0, X = []; I--; ) {
          var J = s[I];
          I && c && (J = Ot(J, Hn(c))), B = an(J.length, B), L[I] = !f && (c || S >= 120 && J.length >= 120) ? new to(I && J) : t;
        }
        J = s[0];
        var ne = -1, he = L[0];
        e:
          for (; ++ne < S && X.length < B; ) {
            var Me = J[ne], Ve = c ? c(Me) : Me;
            if (Me = f || Me !== 0 ? Me : 0, !(he ? Ss(he, Ve) : y(X, Ve, f))) {
              for (I = O; --I; ) {
                var Ke = L[I];
                if (!(Ke ? Ss(Ke, Ve) : y(s[I], Ve, f)))
                  continue e;
              }
              he && he.push(Ve), X.push(Me);
            }
          }
        return X;
      }
      function GS(s, c, f, y) {
        return Dr(s, function(S, O, I) {
          c(y, f(S), O, I);
        }), y;
      }
      function Ds(s, c, f) {
        c = xi(c, s), s = Rg(s, c);
        var y = s == null ? s : s[Ar(ar(c))];
        return y == null ? t : Wn(y, s, f);
      }
      function $p(s) {
        return At(s) && bn(s) == me;
      }
      function KS(s) {
        return At(s) && bn(s) == ve;
      }
      function XS(s) {
        return At(s) && bn(s) == xe;
      }
      function Is(s, c, f, y, S) {
        return s === c ? !0 : s == null || c == null || !At(s) && !At(c) ? s !== s && c !== c : JS(s, c, f, y, Is, S);
      }
      function JS(s, c, f, y, S, O) {
        var I = Ye(s), L = Ye(c), B = I ? U : ln(s), X = L ? U : ln(c);
        B = B == me ? A : B, X = X == me ? A : X;
        var J = B == A, ne = X == A, he = B == X;
        if (he && Ci(s)) {
          if (!Ci(c))
            return !1;
          I = !0, J = !1;
        }
        if (he && !J)
          return O || (O = new wr()), I || Uo(s) ? Sg(s, c, f, y, S, O) : k2(s, c, B, f, y, S, O);
        if (!(f & m)) {
          var Me = J && mt.call(s, "__wrapped__"), Ve = ne && mt.call(c, "__wrapped__");
          if (Me || Ve) {
            var Ke = Me ? s.value() : s, We = Ve ? c.value() : c;
            return O || (O = new wr()), S(Ke, We, f, y, O);
          }
        }
        return he ? (O || (O = new wr()), O2(s, c, f, y, S, O)) : !1;
      }
      function QS(s) {
        return At(s) && ln(s) == Be;
      }
      function Nu(s, c, f, y) {
        var S = f.length, O = S, I = !y;
        if (s == null)
          return !O;
        for (s = wt(s); S--; ) {
          var L = f[S];
          if (I && L[2] ? L[1] !== s[L[0]] : !(L[0] in s))
            return !1;
        }
        for (; ++S < O; ) {
          L = f[S];
          var B = L[0], X = s[B], J = L[1];
          if (I && L[2]) {
            if (X === t && !(B in s))
              return !1;
          } else {
            var ne = new wr();
            if (y)
              var he = y(X, J, B, s, c, ne);
            if (!(he === t ? Is(J, X, m | w, y, ne) : he))
              return !1;
          }
        }
        return !0;
      }
      function Up(s) {
        if (!Rt(s) || _2(s))
          return !1;
        var c = Qr(s) ? Qx : $b;
        return c.test(oo(s));
      }
      function e2(s) {
        return At(s) && bn(s) == ce;
      }
      function t2(s) {
        return At(s) && ln(s) == fe;
      }
      function n2(s) {
        return At(s) && kl(s.length) && !!Et[bn(s)];
      }
      function Zp(s) {
        return typeof s == "function" ? s : s == null ? An : typeof s == "object" ? Ye(s) ? qp(s[0], s[1]) : Yp(s) : h0(s);
      }
      function zu(s) {
        if (!Ps(s))
          return oS(s);
        var c = [];
        for (var f in wt(s))
          mt.call(s, f) && f != "constructor" && c.push(f);
        return c;
      }
      function r2(s) {
        if (!Rt(s))
          return F2(s);
        var c = Ps(s), f = [];
        for (var y in s)
          y == "constructor" && (c || !mt.call(s, y)) || f.push(y);
        return f;
      }
      function Bu(s, c) {
        return s < c;
      }
      function jp(s, c) {
        var f = -1, y = Dn(s) ? V(s.length) : [];
        return wi(s, function(S, O, I) {
          y[++f] = c(S, O, I);
        }), y;
      }
      function Yp(s) {
        var c = Qu(s);
        return c.length == 1 && c[0][2] ? Tg(c[0][0], c[0][1]) : function(f) {
          return f === s || Nu(f, s, c);
        };
      }
      function qp(s, c) {
        return td(s) && Og(c) ? Tg(Ar(s), c) : function(f) {
          var y = dd(f, s);
          return y === t && y === c ? fd(f, s) : Is(c, y, m | w);
        };
      }
      function cl(s, c, f, y, S) {
        s !== c && Au(c, function(O, I) {
          if (S || (S = new wr()), Rt(O))
            i2(s, c, I, f, cl, y, S);
          else {
            var L = y ? y(rd(s, I), O, I + "", s, c, S) : t;
            L === t && (L = O), Du(s, I, L);
          }
        }, In);
      }
      function i2(s, c, f, y, S, O, I) {
        var L = rd(s, f), B = rd(c, f), X = I.get(B);
        if (X) {
          Du(s, f, X);
          return;
        }
        var J = O ? O(L, B, f + "", s, c, I) : t, ne = J === t;
        if (ne) {
          var he = Ye(B), Me = !he && Ci(B), Ve = !he && !Me && Uo(B);
          J = B, he || Me || Ve ? Ye(L) ? J = L : Pt(L) ? J = Rn(L) : Me ? (ne = !1, J = sg(B, !0)) : Ve ? (ne = !1, J = ag(B, !0)) : J = [] : Ns(B) || so(B) ? (J = L, so(L) ? J = r0(L) : (!Rt(L) || Qr(L)) && (J = kg(B))) : ne = !1;
        }
        ne && (I.set(B, J), S(J, B, y, O, I), I.delete(B)), Du(s, f, J);
      }
      function Gp(s, c) {
        var f = s.length;
        if (f)
          return c += c < 0 ? f : 0, Jr(c, f) ? s[c] : t;
      }
      function Kp(s, c, f) {
        c.length ? c = Ot(c, function(O) {
          return Ye(O) ? function(I) {
            return ro(I, O.length === 1 ? O[0] : O);
          } : O;
        }) : c = [An];
        var y = -1;
        c = Ot(c, Hn(ze()));
        var S = jp(s, function(O, I, L) {
          var B = Ot(c, function(X) {
            return X(O);
          });
          return { criteria: B, index: ++y, value: O };
        });
        return Ix(S, function(O, I) {
          return v2(O, I, f);
        });
      }
      function o2(s, c) {
        return Xp(s, c, function(f, y) {
          return fd(s, y);
        });
      }
      function Xp(s, c, f) {
        for (var y = -1, S = c.length, O = {}; ++y < S; ) {
          var I = c[y], L = ro(s, I);
          f(L, I) && As(O, xi(I, s), L);
        }
        return O;
      }
      function s2(s) {
        return function(c) {
          return ro(c, s);
        };
      }
      function Fu(s, c, f, y) {
        var S = y ? Dx : Lo, O = -1, I = c.length, L = s;
        for (s === c && (c = Rn(c)), f && (L = Ot(s, Hn(f))); ++O < I; )
          for (var B = 0, X = c[O], J = f ? f(X) : X; (B = S(L, J, B, y)) > -1; )
            L !== s && Qa.call(L, B, 1), Qa.call(s, B, 1);
        return s;
      }
      function Jp(s, c) {
        for (var f = s ? c.length : 0, y = f - 1; f--; ) {
          var S = c[f];
          if (f == y || S !== O) {
            var O = S;
            Jr(S) ? Qa.call(s, S, 1) : $u(s, S);
          }
        }
        return s;
      }
      function Vu(s, c) {
        return s + nl(Ap() * (c - s + 1));
      }
      function a2(s, c, f, y) {
        for (var S = -1, O = $t(tl((c - s) / (f || 1)), 0), I = V(O); O--; )
          I[y ? O : ++S] = s, s += f;
        return I;
      }
      function Wu(s, c) {
        var f = "";
        if (!s || c < 1 || c > de)
          return f;
        do
          c % 2 && (f += s), c = nl(c / 2), c && (s += s);
        while (c);
        return f;
      }
      function Xe(s, c) {
        return id(Mg(s, c, An), s + "");
      }
      function l2(s) {
        return _p(Zo(s));
      }
      function c2(s, c) {
        var f = Zo(s);
        return wl(f, no(c, 0, f.length));
      }
      function As(s, c, f, y) {
        if (!Rt(s))
          return s;
        c = xi(c, s);
        for (var S = -1, O = c.length, I = O - 1, L = s; L != null && ++S < O; ) {
          var B = Ar(c[S]), X = f;
          if (B === "__proto__" || B === "constructor" || B === "prototype")
            return s;
          if (S != I) {
            var J = L[B];
            X = y ? y(J, B, L) : t, X === t && (X = Rt(J) ? J : Jr(c[S + 1]) ? [] : {});
          }
          Ms(L, B, X), L = L[B];
        }
        return s;
      }
      var Qp = rl ? function(s, c) {
        return rl.set(s, c), s;
      } : An, u2 = el ? function(s, c) {
        return el(s, "toString", {
          configurable: !0,
          enumerable: !1,
          value: pd(c),
          writable: !0
        });
      } : An;
      function d2(s) {
        return wl(Zo(s));
      }
      function sr(s, c, f) {
        var y = -1, S = s.length;
        c < 0 && (c = -c > S ? 0 : S + c), f = f > S ? S : f, f < 0 && (f += S), S = c > f ? 0 : f - c >>> 0, c >>>= 0;
        for (var O = V(S); ++y < S; )
          O[y] = s[y + c];
        return O;
      }
      function f2(s, c) {
        var f;
        return wi(s, function(y, S, O) {
          return f = c(y, S, O), !f;
        }), !!f;
      }
      function ul(s, c, f) {
        var y = 0, S = s == null ? y : s.length;
        if (typeof c == "number" && c === c && S <= Ce) {
          for (; y < S; ) {
            var O = y + S >>> 1, I = s[O];
            I !== null && !Un(I) && (f ? I <= c : I < c) ? y = O + 1 : S = O;
          }
          return S;
        }
        return Hu(s, c, An, f);
      }
      function Hu(s, c, f, y) {
        var S = 0, O = s == null ? 0 : s.length;
        if (O === 0)
          return 0;
        c = f(c);
        for (var I = c !== c, L = c === null, B = Un(c), X = c === t; S < O; ) {
          var J = nl((S + O) / 2), ne = f(s[J]), he = ne !== t, Me = ne === null, Ve = ne === ne, Ke = Un(ne);
          if (I)
            var We = y || Ve;
          else
            X ? We = Ve && (y || he) : L ? We = Ve && he && (y || !Me) : B ? We = Ve && he && !Me && (y || !Ke) : Me || Ke ? We = !1 : We = y ? ne <= c : ne < c;
          We ? S = J + 1 : O = J;
        }
        return an(O, le);
      }
      function eg(s, c) {
        for (var f = -1, y = s.length, S = 0, O = []; ++f < y; ) {
          var I = s[f], L = c ? c(I) : I;
          if (!f || !br(L, B)) {
            var B = L;
            O[S++] = I === 0 ? 0 : I;
          }
        }
        return O;
      }
      function tg(s) {
        return typeof s == "number" ? s : Un(s) ? we : +s;
      }
      function $n(s) {
        if (typeof s == "string")
          return s;
        if (Ye(s))
          return Ot(s, $n) + "";
        if (Un(s))
          return Lp ? Lp.call(s) : "";
        var c = s + "";
        return c == "0" && 1 / s == -oe ? "-0" : c;
      }
      function bi(s, c, f) {
        var y = -1, S = $a, O = s.length, I = !0, L = [], B = L;
        if (f)
          I = !1, S = vu;
        else if (O >= i) {
          var X = c ? null : C2(s);
          if (X)
            return Za(X);
          I = !1, S = Ss, B = new to();
        } else
          B = c ? [] : L;
        e:
          for (; ++y < O; ) {
            var J = s[y], ne = c ? c(J) : J;
            if (J = f || J !== 0 ? J : 0, I && ne === ne) {
              for (var he = B.length; he--; )
                if (B[he] === ne)
                  continue e;
              c && B.push(ne), L.push(J);
            } else
              S(B, ne, f) || (B !== L && B.push(ne), L.push(J));
          }
        return L;
      }
      function $u(s, c) {
        return c = xi(c, s), s = Rg(s, c), s == null || delete s[Ar(ar(c))];
      }
      function ng(s, c, f, y) {
        return As(s, c, f(ro(s, c)), y);
      }
      function dl(s, c, f, y) {
        for (var S = s.length, O = y ? S : -1; (y ? O-- : ++O < S) && c(s[O], O, s); )
          ;
        return f ? sr(s, y ? 0 : O, y ? O + 1 : S) : sr(s, y ? O + 1 : 0, y ? S : O);
      }
      function rg(s, c) {
        var f = s;
        return f instanceof et && (f = f.value()), yu(c, function(y, S) {
          return S.func.apply(S.thisArg, gi([y], S.args));
        }, f);
      }
      function Uu(s, c, f) {
        var y = s.length;
        if (y < 2)
          return y ? bi(s[0]) : [];
        for (var S = -1, O = V(y); ++S < y; )
          for (var I = s[S], L = -1; ++L < y; )
            L != S && (O[S] = Rs(O[S] || I, s[L], c, f));
        return bi(Jt(O, 1), c, f);
      }
      function ig(s, c, f) {
        for (var y = -1, S = s.length, O = c.length, I = {}; ++y < S; ) {
          var L = y < O ? c[y] : t;
          f(I, s[y], L);
        }
        return I;
      }
      function Zu(s) {
        return Pt(s) ? s : [];
      }
      function ju(s) {
        return typeof s == "function" ? s : An;
      }
      function xi(s, c) {
        return Ye(s) ? s : td(s, c) ? [s] : Lg(dt(s));
      }
      var h2 = Xe;
      function Si(s, c, f) {
        var y = s.length;
        return f = f === t ? y : f, !c && f >= y ? s : sr(s, c, f);
      }
      var og = eS || function(s) {
        return Xt.clearTimeout(s);
      };
      function sg(s, c) {
        if (c)
          return s.slice();
        var f = s.length, y = Tp ? Tp(f) : new s.constructor(f);
        return s.copy(y), y;
      }
      function Yu(s) {
        var c = new s.constructor(s.byteLength);
        return new Xa(c).set(new Xa(s)), c;
      }
      function p2(s, c) {
        var f = c ? Yu(s.buffer) : s.buffer;
        return new s.constructor(f, s.byteOffset, s.byteLength);
      }
      function g2(s) {
        var c = new s.constructor(s.source, $h.exec(s));
        return c.lastIndex = s.lastIndex, c;
      }
      function m2(s) {
        return Ts ? wt(Ts.call(s)) : {};
      }
      function ag(s, c) {
        var f = c ? Yu(s.buffer) : s.buffer;
        return new s.constructor(f, s.byteOffset, s.length);
      }
      function lg(s, c) {
        if (s !== c) {
          var f = s !== t, y = s === null, S = s === s, O = Un(s), I = c !== t, L = c === null, B = c === c, X = Un(c);
          if (!L && !X && !O && s > c || O && I && B && !L && !X || y && I && B || !f && B || !S)
            return 1;
          if (!y && !O && !X && s < c || X && f && S && !y && !O || L && f && S || !I && S || !B)
            return -1;
        }
        return 0;
      }
      function v2(s, c, f) {
        for (var y = -1, S = s.criteria, O = c.criteria, I = S.length, L = f.length; ++y < I; ) {
          var B = lg(S[y], O[y]);
          if (B) {
            if (y >= L)
              return B;
            var X = f[y];
            return B * (X == "desc" ? -1 : 1);
          }
        }
        return s.index - c.index;
      }
      function cg(s, c, f, y) {
        for (var S = -1, O = s.length, I = f.length, L = -1, B = c.length, X = $t(O - I, 0), J = V(B + X), ne = !y; ++L < B; )
          J[L] = c[L];
        for (; ++S < I; )
          (ne || S < O) && (J[f[S]] = s[S]);
        for (; X--; )
          J[L++] = s[S++];
        return J;
      }
      function ug(s, c, f, y) {
        for (var S = -1, O = s.length, I = -1, L = f.length, B = -1, X = c.length, J = $t(O - L, 0), ne = V(J + X), he = !y; ++S < J; )
          ne[S] = s[S];
        for (var Me = S; ++B < X; )
          ne[Me + B] = c[B];
        for (; ++I < L; )
          (he || S < O) && (ne[Me + f[I]] = s[S++]);
        return ne;
      }
      function Rn(s, c) {
        var f = -1, y = s.length;
        for (c || (c = V(y)); ++f < y; )
          c[f] = s[f];
        return c;
      }
      function Ir(s, c, f, y) {
        var S = !f;
        f || (f = {});
        for (var O = -1, I = c.length; ++O < I; ) {
          var L = c[O], B = y ? y(f[L], s[L], L, f, s) : t;
          B === t && (B = s[L]), S ? Gr(f, L, B) : Ms(f, L, B);
        }
        return f;
      }
      function y2(s, c) {
        return Ir(s, ed(s), c);
      }
      function w2(s, c) {
        return Ir(s, Cg(s), c);
      }
      function fl(s, c) {
        return function(f, y) {
          var S = Ye(f) ? Ex : WS, O = c ? c() : {};
          return S(f, s, ze(y, 2), O);
        };
      }
      function Wo(s) {
        return Xe(function(c, f) {
          var y = -1, S = f.length, O = S > 1 ? f[S - 1] : t, I = S > 2 ? f[2] : t;
          for (O = s.length > 3 && typeof O == "function" ? (S--, O) : t, I && xn(f[0], f[1], I) && (O = S < 3 ? t : O, S = 1), c = wt(c); ++y < S; ) {
            var L = f[y];
            L && s(c, L, y, O);
          }
          return c;
        });
      }
      function dg(s, c) {
        return function(f, y) {
          if (f == null)
            return f;
          if (!Dn(f))
            return s(f, y);
          for (var S = f.length, O = c ? S : -1, I = wt(f); (c ? O-- : ++O < S) && y(I[O], O, I) !== !1; )
            ;
          return f;
        };
      }
      function fg(s) {
        return function(c, f, y) {
          for (var S = -1, O = wt(c), I = y(c), L = I.length; L--; ) {
            var B = I[s ? L : ++S];
            if (f(O[B], B, O) === !1)
              break;
          }
          return c;
        };
      }
      function b2(s, c, f) {
        var y = c & b, S = Ls(s);
        function O() {
          var I = this && this !== Xt && this instanceof O ? S : s;
          return I.apply(y ? f : this, arguments);
        }
        return O;
      }
      function hg(s) {
        return function(c) {
          c = dt(c);
          var f = Po(c) ? yr(c) : t, y = f ? f[0] : c.charAt(0), S = f ? Si(f, 1).join("") : c.slice(1);
          return y[s]() + S;
        };
      }
      function Ho(s) {
        return function(c) {
          return yu(d0(u0(c).replace(ux, "")), s, "");
        };
      }
      function Ls(s) {
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return new s();
            case 1:
              return new s(c[0]);
            case 2:
              return new s(c[0], c[1]);
            case 3:
              return new s(c[0], c[1], c[2]);
            case 4:
              return new s(c[0], c[1], c[2], c[3]);
            case 5:
              return new s(c[0], c[1], c[2], c[3], c[4]);
            case 6:
              return new s(c[0], c[1], c[2], c[3], c[4], c[5]);
            case 7:
              return new s(c[0], c[1], c[2], c[3], c[4], c[5], c[6]);
          }
          var f = Vo(s.prototype), y = s.apply(f, c);
          return Rt(y) ? y : f;
        };
      }
      function x2(s, c, f) {
        var y = Ls(s);
        function S() {
          for (var O = arguments.length, I = V(O), L = O, B = $o(S); L--; )
            I[L] = arguments[L];
          var X = O < 3 && I[0] !== B && I[O - 1] !== B ? [] : mi(I, B);
          if (O -= X.length, O < f)
            return yg(
              s,
              c,
              hl,
              S.placeholder,
              t,
              I,
              X,
              t,
              t,
              f - O
            );
          var J = this && this !== Xt && this instanceof S ? y : s;
          return Wn(J, this, I);
        }
        return S;
      }
      function pg(s) {
        return function(c, f, y) {
          var S = wt(c);
          if (!Dn(c)) {
            var O = ze(f, 3);
            c = qt(c), f = function(L) {
              return O(S[L], L, S);
            };
          }
          var I = s(c, f, y);
          return I > -1 ? S[O ? c[I] : I] : t;
        };
      }
      function gg(s) {
        return Xr(function(c) {
          var f = c.length, y = f, S = ir.prototype.thru;
          for (s && c.reverse(); y--; ) {
            var O = c[y];
            if (typeof O != "function")
              throw new rr(a);
            if (S && !I && vl(O) == "wrapper")
              var I = new ir([], !0);
          }
          for (y = I ? y : f; ++y < f; ) {
            O = c[y];
            var L = vl(O), B = L == "wrapper" ? Ju(O) : t;
            B && nd(B[0]) && B[1] == (_ | k | T | Z) && !B[4].length && B[9] == 1 ? I = I[vl(B[0])].apply(I, B[3]) : I = O.length == 1 && nd(O) ? I[L]() : I.thru(O);
          }
          return function() {
            var X = arguments, J = X[0];
            if (I && X.length == 1 && Ye(J))
              return I.plant(J).value();
            for (var ne = 0, he = f ? c[ne].apply(this, X) : J; ++ne < f; )
              he = c[ne].call(this, he);
            return he;
          };
        });
      }
      function hl(s, c, f, y, S, O, I, L, B, X) {
        var J = c & _, ne = c & b, he = c & C, Me = c & (k | D), Ve = c & K, Ke = he ? t : Ls(s);
        function We() {
          for (var Qe = arguments.length, nt = V(Qe), Zn = Qe; Zn--; )
            nt[Zn] = arguments[Zn];
          if (Me)
            var Sn = $o(We), jn = Lx(nt, Sn);
          if (y && (nt = cg(nt, y, S, Me)), O && (nt = ug(nt, O, I, Me)), Qe -= jn, Me && Qe < X) {
            var _t = mi(nt, Sn);
            return yg(
              s,
              c,
              hl,
              We.placeholder,
              f,
              nt,
              _t,
              L,
              B,
              X - Qe
            );
          }
          var xr = ne ? f : this, ti = he ? xr[s] : s;
          return Qe = nt.length, L ? nt = W2(nt, L) : Ve && Qe > 1 && nt.reverse(), J && B < Qe && (nt.length = B), this && this !== Xt && this instanceof We && (ti = Ke || Ls(ti)), ti.apply(xr, nt);
        }
        return We;
      }
      function mg(s, c) {
        return function(f, y) {
          return GS(f, s, c(y), {});
        };
      }
      function pl(s, c) {
        return function(f, y) {
          var S;
          if (f === t && y === t)
            return c;
          if (f !== t && (S = f), y !== t) {
            if (S === t)
              return y;
            typeof f == "string" || typeof y == "string" ? (f = $n(f), y = $n(y)) : (f = tg(f), y = tg(y)), S = s(f, y);
          }
          return S;
        };
      }
      function qu(s) {
        return Xr(function(c) {
          return c = Ot(c, Hn(ze())), Xe(function(f) {
            var y = this;
            return s(c, function(S) {
              return Wn(S, y, f);
            });
          });
        });
      }
      function gl(s, c) {
        c = c === t ? " " : $n(c);
        var f = c.length;
        if (f < 2)
          return f ? Wu(c, s) : c;
        var y = Wu(c, tl(s / _o(c)));
        return Po(c) ? Si(yr(y), 0, s).join("") : y.slice(0, s);
      }
      function S2(s, c, f, y) {
        var S = c & b, O = Ls(s);
        function I() {
          for (var L = -1, B = arguments.length, X = -1, J = y.length, ne = V(J + B), he = this && this !== Xt && this instanceof I ? O : s; ++X < J; )
            ne[X] = y[X];
          for (; B--; )
            ne[X++] = arguments[++L];
          return Wn(he, S ? f : this, ne);
        }
        return I;
      }
      function vg(s) {
        return function(c, f, y) {
          return y && typeof y != "number" && xn(c, f, y) && (f = y = t), c = ei(c), f === t ? (f = c, c = 0) : f = ei(f), y = y === t ? c < f ? 1 : -1 : ei(y), a2(c, f, y, s);
        };
      }
      function ml(s) {
        return function(c, f) {
          return typeof c == "string" && typeof f == "string" || (c = lr(c), f = lr(f)), s(c, f);
        };
      }
      function yg(s, c, f, y, S, O, I, L, B, X) {
        var J = c & k, ne = J ? I : t, he = J ? t : I, Me = J ? O : t, Ve = J ? t : O;
        c |= J ? T : R, c &= ~(J ? R : T), c & M || (c &= ~(b | C));
        var Ke = [
          s,
          c,
          S,
          Me,
          ne,
          Ve,
          he,
          L,
          B,
          X
        ], We = f.apply(t, Ke);
        return nd(s) && Dg(We, Ke), We.placeholder = y, Ig(We, s, c);
      }
      function Gu(s) {
        var c = Ht[s];
        return function(f, y) {
          if (f = lr(f), y = y == null ? 0 : an(Ge(y), 292), y && Ip(f)) {
            var S = (dt(f) + "e").split("e"), O = c(S[0] + "e" + (+S[1] + y));
            return S = (dt(O) + "e").split("e"), +(S[0] + "e" + (+S[1] - y));
          }
          return c(f);
        };
      }
      var C2 = Bo && 1 / Za(new Bo([, -0]))[1] == oe ? function(s) {
        return new Bo(s);
      } : vd;
      function wg(s) {
        return function(c) {
          var f = ln(c);
          return f == Be ? ku(c) : f == fe ? Vx(c) : Ax(c, s(c));
        };
      }
      function Kr(s, c, f, y, S, O, I, L) {
        var B = c & C;
        if (!B && typeof s != "function")
          throw new rr(a);
        var X = y ? y.length : 0;
        if (X || (c &= ~(T | R), y = S = t), I = I === t ? I : $t(Ge(I), 0), L = L === t ? L : Ge(L), X -= S ? S.length : 0, c & R) {
          var J = y, ne = S;
          y = S = t;
        }
        var he = B ? t : Ju(s), Me = [
          s,
          c,
          f,
          y,
          S,
          J,
          ne,
          O,
          I,
          L
        ];
        if (he && B2(Me, he), s = Me[0], c = Me[1], f = Me[2], y = Me[3], S = Me[4], L = Me[9] = Me[9] === t ? B ? 0 : s.length : $t(Me[9] - X, 0), !L && c & (k | D) && (c &= ~(k | D)), !c || c == b)
          var Ve = b2(s, c, f);
        else
          c == k || c == D ? Ve = x2(s, c, L) : (c == T || c == (b | T)) && !S.length ? Ve = S2(s, c, f, y) : Ve = hl.apply(t, Me);
        var Ke = he ? Qp : Dg;
        return Ig(Ke(Ve, Me), s, c);
      }
      function bg(s, c, f, y) {
        return s === t || br(s, zo[f]) && !mt.call(y, f) ? c : s;
      }
      function xg(s, c, f, y, S, O) {
        return Rt(s) && Rt(c) && (O.set(c, s), cl(s, c, t, xg, O), O.delete(c)), s;
      }
      function E2(s) {
        return Ns(s) ? t : s;
      }
      function Sg(s, c, f, y, S, O) {
        var I = f & m, L = s.length, B = c.length;
        if (L != B && !(I && B > L))
          return !1;
        var X = O.get(s), J = O.get(c);
        if (X && J)
          return X == c && J == s;
        var ne = -1, he = !0, Me = f & w ? new to() : t;
        for (O.set(s, c), O.set(c, s); ++ne < L; ) {
          var Ve = s[ne], Ke = c[ne];
          if (y)
            var We = I ? y(Ke, Ve, ne, c, s, O) : y(Ve, Ke, ne, s, c, O);
          if (We !== t) {
            if (We)
              continue;
            he = !1;
            break;
          }
          if (Me) {
            if (!wu(c, function(Qe, nt) {
              if (!Ss(Me, nt) && (Ve === Qe || S(Ve, Qe, f, y, O)))
                return Me.push(nt);
            })) {
              he = !1;
              break;
            }
          } else if (!(Ve === Ke || S(Ve, Ke, f, y, O))) {
            he = !1;
            break;
          }
        }
        return O.delete(s), O.delete(c), he;
      }
      function k2(s, c, f, y, S, O, I) {
        switch (f) {
          case Ae:
            if (s.byteLength != c.byteLength || s.byteOffset != c.byteOffset)
              return !1;
            s = s.buffer, c = c.buffer;
          case ve:
            return !(s.byteLength != c.byteLength || !O(new Xa(s), new Xa(c)));
          case G:
          case xe:
          case vt:
            return br(+s, +c);
          case Je:
            return s.name == c.name && s.message == c.message;
          case ce:
          case _e:
            return s == c + "";
          case Be:
            var L = ku;
          case fe:
            var B = y & m;
            if (L || (L = Za), s.size != c.size && !B)
              return !1;
            var X = I.get(s);
            if (X)
              return X == c;
            y |= w, I.set(s, c);
            var J = Sg(L(s), L(c), y, S, O, I);
            return I.delete(s), J;
          case tt:
            if (Ts)
              return Ts.call(s) == Ts.call(c);
        }
        return !1;
      }
      function O2(s, c, f, y, S, O) {
        var I = f & m, L = Ku(s), B = L.length, X = Ku(c), J = X.length;
        if (B != J && !I)
          return !1;
        for (var ne = B; ne--; ) {
          var he = L[ne];
          if (!(I ? he in c : mt.call(c, he)))
            return !1;
        }
        var Me = O.get(s), Ve = O.get(c);
        if (Me && Ve)
          return Me == c && Ve == s;
        var Ke = !0;
        O.set(s, c), O.set(c, s);
        for (var We = I; ++ne < B; ) {
          he = L[ne];
          var Qe = s[he], nt = c[he];
          if (y)
            var Zn = I ? y(nt, Qe, he, c, s, O) : y(Qe, nt, he, s, c, O);
          if (!(Zn === t ? Qe === nt || S(Qe, nt, f, y, O) : Zn)) {
            Ke = !1;
            break;
          }
          We || (We = he == "constructor");
        }
        if (Ke && !We) {
          var Sn = s.constructor, jn = c.constructor;
          Sn != jn && "constructor" in s && "constructor" in c && !(typeof Sn == "function" && Sn instanceof Sn && typeof jn == "function" && jn instanceof jn) && (Ke = !1);
        }
        return O.delete(s), O.delete(c), Ke;
      }
      function Xr(s) {
        return id(Mg(s, t, zg), s + "");
      }
      function Ku(s) {
        return Hp(s, qt, ed);
      }
      function Xu(s) {
        return Hp(s, In, Cg);
      }
      var Ju = rl ? function(s) {
        return rl.get(s);
      } : vd;
      function vl(s) {
        for (var c = s.name + "", f = Fo[c], y = mt.call(Fo, c) ? f.length : 0; y--; ) {
          var S = f[y], O = S.func;
          if (O == null || O == s)
            return S.name;
        }
        return c;
      }
      function $o(s) {
        var c = mt.call(E, "placeholder") ? E : s;
        return c.placeholder;
      }
      function ze() {
        var s = E.iteratee || gd;
        return s = s === gd ? Zp : s, arguments.length ? s(arguments[0], arguments[1]) : s;
      }
      function yl(s, c) {
        var f = s.__data__;
        return P2(c) ? f[typeof c == "string" ? "string" : "hash"] : f.map;
      }
      function Qu(s) {
        for (var c = qt(s), f = c.length; f--; ) {
          var y = c[f], S = s[y];
          c[f] = [y, S, Og(S)];
        }
        return c;
      }
      function io(s, c) {
        var f = zx(s, c);
        return Up(f) ? f : t;
      }
      function T2(s) {
        var c = mt.call(s, Qi), f = s[Qi];
        try {
          s[Qi] = t;
          var y = !0;
        } catch {
        }
        var S = Ga.call(s);
        return y && (c ? s[Qi] = f : delete s[Qi]), S;
      }
      var ed = Tu ? function(s) {
        return s == null ? [] : (s = wt(s), pi(Tu(s), function(c) {
          return Rp.call(s, c);
        }));
      } : yd, Cg = Tu ? function(s) {
        for (var c = []; s; )
          gi(c, ed(s)), s = Ja(s);
        return c;
      } : yd, ln = bn;
      (Mu && ln(new Mu(new ArrayBuffer(1))) != Ae || Es && ln(new Es()) != Be || Ru && ln(Ru.resolve()) != z || Bo && ln(new Bo()) != fe || ks && ln(new ks()) != Pe) && (ln = function(s) {
        var c = bn(s), f = c == A ? s.constructor : t, y = f ? oo(f) : "";
        if (y)
          switch (y) {
            case cS:
              return Ae;
            case uS:
              return Be;
            case dS:
              return z;
            case fS:
              return fe;
            case hS:
              return Pe;
          }
        return c;
      });
      function M2(s, c, f) {
        for (var y = -1, S = f.length; ++y < S; ) {
          var O = f[y], I = O.size;
          switch (O.type) {
            case "drop":
              s += I;
              break;
            case "dropRight":
              c -= I;
              break;
            case "take":
              c = an(c, s + I);
              break;
            case "takeRight":
              s = $t(s, c - I);
              break;
          }
        }
        return { start: s, end: c };
      }
      function R2(s) {
        var c = s.match(Xi);
        return c ? c[1].split(xs) : [];
      }
      function Eg(s, c, f) {
        c = xi(c, s);
        for (var y = -1, S = c.length, O = !1; ++y < S; ) {
          var I = Ar(c[y]);
          if (!(O = s != null && f(s, I)))
            break;
          s = s[I];
        }
        return O || ++y != S ? O : (S = s == null ? 0 : s.length, !!S && kl(S) && Jr(I, S) && (Ye(s) || so(s)));
      }
      function D2(s) {
        var c = s.length, f = new s.constructor(c);
        return c && typeof s[0] == "string" && mt.call(s, "index") && (f.index = s.index, f.input = s.input), f;
      }
      function kg(s) {
        return typeof s.constructor == "function" && !Ps(s) ? Vo(Ja(s)) : {};
      }
      function I2(s, c, f) {
        var y = s.constructor;
        switch (c) {
          case ve:
            return Yu(s);
          case G:
          case xe:
            return new y(+s);
          case Ae:
            return p2(s, f);
          case ot:
          case Ct:
          case Fe:
          case De:
          case on:
          case Ur:
          case Zr:
          case bs:
          case Do:
            return ag(s, f);
          case Be:
            return new y();
          case vt:
          case _e:
            return new y(s);
          case ce:
            return g2(s);
          case fe:
            return new y();
          case tt:
            return m2(s);
        }
      }
      function A2(s, c) {
        var f = c.length;
        if (!f)
          return s;
        var y = f - 1;
        return c[y] = (f > 1 ? "& " : "") + c[y], c = c.join(f > 2 ? ", " : " "), s.replace(Ki, `{
/* [wrapped with ` + c + `] */
`);
      }
      function L2(s) {
        return Ye(s) || so(s) || !!(Dp && s && s[Dp]);
      }
      function Jr(s, c) {
        var f = typeof s;
        return c = c ?? de, !!c && (f == "number" || f != "symbol" && Zb.test(s)) && s > -1 && s % 1 == 0 && s < c;
      }
      function xn(s, c, f) {
        if (!Rt(f))
          return !1;
        var y = typeof c;
        return (y == "number" ? Dn(f) && Jr(c, f.length) : y == "string" && c in f) ? br(f[c], s) : !1;
      }
      function td(s, c) {
        if (Ye(s))
          return !1;
        var f = typeof s;
        return f == "number" || f == "symbol" || f == "boolean" || s == null || Un(s) ? !0 : Vn.test(s) || !fi.test(s) || c != null && s in wt(c);
      }
      function P2(s) {
        var c = typeof s;
        return c == "string" || c == "number" || c == "symbol" || c == "boolean" ? s !== "__proto__" : s === null;
      }
      function nd(s) {
        var c = vl(s), f = E[c];
        if (typeof f != "function" || !(c in et.prototype))
          return !1;
        if (s === f)
          return !0;
        var y = Ju(f);
        return !!y && s === y[0];
      }
      function _2(s) {
        return !!Op && Op in s;
      }
      var N2 = Ya ? Qr : wd;
      function Ps(s) {
        var c = s && s.constructor, f = typeof c == "function" && c.prototype || zo;
        return s === f;
      }
      function Og(s) {
        return s === s && !Rt(s);
      }
      function Tg(s, c) {
        return function(f) {
          return f == null ? !1 : f[s] === c && (c !== t || s in wt(f));
        };
      }
      function z2(s) {
        var c = Cl(s, function(y) {
          return f.size === d && f.clear(), y;
        }), f = c.cache;
        return c;
      }
      function B2(s, c) {
        var f = s[1], y = c[1], S = f | y, O = S < (b | C | _), I = y == _ && f == k || y == _ && f == Z && s[7].length <= c[8] || y == (_ | Z) && c[7].length <= c[8] && f == k;
        if (!(O || I))
          return s;
        y & b && (s[2] = c[2], S |= f & b ? 0 : M);
        var L = c[3];
        if (L) {
          var B = s[3];
          s[3] = B ? cg(B, L, c[4]) : L, s[4] = B ? mi(s[3], h) : c[4];
        }
        return L = c[5], L && (B = s[5], s[5] = B ? ug(B, L, c[6]) : L, s[6] = B ? mi(s[5], h) : c[6]), L = c[7], L && (s[7] = L), y & _ && (s[8] = s[8] == null ? c[8] : an(s[8], c[8])), s[9] == null && (s[9] = c[9]), s[0] = c[0], s[1] = S, s;
      }
      function F2(s) {
        var c = [];
        if (s != null)
          for (var f in wt(s))
            c.push(f);
        return c;
      }
      function V2(s) {
        return Ga.call(s);
      }
      function Mg(s, c, f) {
        return c = $t(c === t ? s.length - 1 : c, 0), function() {
          for (var y = arguments, S = -1, O = $t(y.length - c, 0), I = V(O); ++S < O; )
            I[S] = y[c + S];
          S = -1;
          for (var L = V(c + 1); ++S < c; )
            L[S] = y[S];
          return L[c] = f(I), Wn(s, this, L);
        };
      }
      function Rg(s, c) {
        return c.length < 2 ? s : ro(s, sr(c, 0, -1));
      }
      function W2(s, c) {
        for (var f = s.length, y = an(c.length, f), S = Rn(s); y--; ) {
          var O = c[y];
          s[y] = Jr(O, f) ? S[O] : t;
        }
        return s;
      }
      function rd(s, c) {
        if (!(c === "constructor" && typeof s[c] == "function") && c != "__proto__")
          return s[c];
      }
      var Dg = Ag(Qp), _s = nS || function(s, c) {
        return Xt.setTimeout(s, c);
      }, id = Ag(u2);
      function Ig(s, c, f) {
        var y = c + "";
        return id(s, A2(y, H2(R2(y), f)));
      }
      function Ag(s) {
        var c = 0, f = 0;
        return function() {
          var y = sS(), S = Q - (y - f);
          if (f = y, S > 0) {
            if (++c >= Y)
              return arguments[0];
          } else
            c = 0;
          return s.apply(t, arguments);
        };
      }
      function wl(s, c) {
        var f = -1, y = s.length, S = y - 1;
        for (c = c === t ? y : c; ++f < c; ) {
          var O = Vu(f, S), I = s[O];
          s[O] = s[f], s[f] = I;
        }
        return s.length = c, s;
      }
      var Lg = z2(function(s) {
        var c = [];
        return s.charCodeAt(0) === 46 && c.push(""), s.replace(Gi, function(f, y, S, O) {
          c.push(S ? O.replace(Fb, "$1") : y || f);
        }), c;
      });
      function Ar(s) {
        if (typeof s == "string" || Un(s))
          return s;
        var c = s + "";
        return c == "0" && 1 / s == -oe ? "-0" : c;
      }
      function oo(s) {
        if (s != null) {
          try {
            return qa.call(s);
          } catch {
          }
          try {
            return s + "";
          } catch {
          }
        }
        return "";
      }
      function H2(s, c) {
        return nr(Ne, function(f) {
          var y = "_." + f[0];
          c & f[1] && !$a(s, y) && s.push(y);
        }), s.sort();
      }
      function Pg(s) {
        if (s instanceof et)
          return s.clone();
        var c = new ir(s.__wrapped__, s.__chain__);
        return c.__actions__ = Rn(s.__actions__), c.__index__ = s.__index__, c.__values__ = s.__values__, c;
      }
      function $2(s, c, f) {
        (f ? xn(s, c, f) : c === t) ? c = 1 : c = $t(Ge(c), 0);
        var y = s == null ? 0 : s.length;
        if (!y || c < 1)
          return [];
        for (var S = 0, O = 0, I = V(tl(y / c)); S < y; )
          I[O++] = sr(s, S, S += c);
        return I;
      }
      function U2(s) {
        for (var c = -1, f = s == null ? 0 : s.length, y = 0, S = []; ++c < f; ) {
          var O = s[c];
          O && (S[y++] = O);
        }
        return S;
      }
      function Z2() {
        var s = arguments.length;
        if (!s)
          return [];
        for (var c = V(s - 1), f = arguments[0], y = s; y--; )
          c[y - 1] = arguments[y];
        return gi(Ye(f) ? Rn(f) : [f], Jt(c, 1));
      }
      var j2 = Xe(function(s, c) {
        return Pt(s) ? Rs(s, Jt(c, 1, Pt, !0)) : [];
      }), Y2 = Xe(function(s, c) {
        var f = ar(c);
        return Pt(f) && (f = t), Pt(s) ? Rs(s, Jt(c, 1, Pt, !0), ze(f, 2)) : [];
      }), q2 = Xe(function(s, c) {
        var f = ar(c);
        return Pt(f) && (f = t), Pt(s) ? Rs(s, Jt(c, 1, Pt, !0), t, f) : [];
      });
      function G2(s, c, f) {
        var y = s == null ? 0 : s.length;
        return y ? (c = f || c === t ? 1 : Ge(c), sr(s, c < 0 ? 0 : c, y)) : [];
      }
      function K2(s, c, f) {
        var y = s == null ? 0 : s.length;
        return y ? (c = f || c === t ? 1 : Ge(c), c = y - c, sr(s, 0, c < 0 ? 0 : c)) : [];
      }
      function X2(s, c) {
        return s && s.length ? dl(s, ze(c, 3), !0, !0) : [];
      }
      function J2(s, c) {
        return s && s.length ? dl(s, ze(c, 3), !0) : [];
      }
      function Q2(s, c, f, y) {
        var S = s == null ? 0 : s.length;
        return S ? (f && typeof f != "number" && xn(s, c, f) && (f = 0, y = S), ZS(s, c, f, y)) : [];
      }
      function _g(s, c, f) {
        var y = s == null ? 0 : s.length;
        if (!y)
          return -1;
        var S = f == null ? 0 : Ge(f);
        return S < 0 && (S = $t(y + S, 0)), Ua(s, ze(c, 3), S);
      }
      function Ng(s, c, f) {
        var y = s == null ? 0 : s.length;
        if (!y)
          return -1;
        var S = y - 1;
        return f !== t && (S = Ge(f), S = f < 0 ? $t(y + S, 0) : an(S, y - 1)), Ua(s, ze(c, 3), S, !0);
      }
      function zg(s) {
        var c = s == null ? 0 : s.length;
        return c ? Jt(s, 1) : [];
      }
      function eC(s) {
        var c = s == null ? 0 : s.length;
        return c ? Jt(s, oe) : [];
      }
      function tC(s, c) {
        var f = s == null ? 0 : s.length;
        return f ? (c = c === t ? 1 : Ge(c), Jt(s, c)) : [];
      }
      function nC(s) {
        for (var c = -1, f = s == null ? 0 : s.length, y = {}; ++c < f; ) {
          var S = s[c];
          y[S[0]] = S[1];
        }
        return y;
      }
      function Bg(s) {
        return s && s.length ? s[0] : t;
      }
      function rC(s, c, f) {
        var y = s == null ? 0 : s.length;
        if (!y)
          return -1;
        var S = f == null ? 0 : Ge(f);
        return S < 0 && (S = $t(y + S, 0)), Lo(s, c, S);
      }
      function iC(s) {
        var c = s == null ? 0 : s.length;
        return c ? sr(s, 0, -1) : [];
      }
      var oC = Xe(function(s) {
        var c = Ot(s, Zu);
        return c.length && c[0] === s[0] ? _u(c) : [];
      }), sC = Xe(function(s) {
        var c = ar(s), f = Ot(s, Zu);
        return c === ar(f) ? c = t : f.pop(), f.length && f[0] === s[0] ? _u(f, ze(c, 2)) : [];
      }), aC = Xe(function(s) {
        var c = ar(s), f = Ot(s, Zu);
        return c = typeof c == "function" ? c : t, c && f.pop(), f.length && f[0] === s[0] ? _u(f, t, c) : [];
      });
      function lC(s, c) {
        return s == null ? "" : iS.call(s, c);
      }
      function ar(s) {
        var c = s == null ? 0 : s.length;
        return c ? s[c - 1] : t;
      }
      function cC(s, c, f) {
        var y = s == null ? 0 : s.length;
        if (!y)
          return -1;
        var S = y;
        return f !== t && (S = Ge(f), S = S < 0 ? $t(y + S, 0) : an(S, y - 1)), c === c ? Hx(s, c, S) : Ua(s, yp, S, !0);
      }
      function uC(s, c) {
        return s && s.length ? Gp(s, Ge(c)) : t;
      }
      var dC = Xe(Fg);
      function Fg(s, c) {
        return s && s.length && c && c.length ? Fu(s, c) : s;
      }
      function fC(s, c, f) {
        return s && s.length && c && c.length ? Fu(s, c, ze(f, 2)) : s;
      }
      function hC(s, c, f) {
        return s && s.length && c && c.length ? Fu(s, c, t, f) : s;
      }
      var pC = Xr(function(s, c) {
        var f = s == null ? 0 : s.length, y = Iu(s, c);
        return Jp(s, Ot(c, function(S) {
          return Jr(S, f) ? +S : S;
        }).sort(lg)), y;
      });
      function gC(s, c) {
        var f = [];
        if (!(s && s.length))
          return f;
        var y = -1, S = [], O = s.length;
        for (c = ze(c, 3); ++y < O; ) {
          var I = s[y];
          c(I, y, s) && (f.push(I), S.push(y));
        }
        return Jp(s, S), f;
      }
      function od(s) {
        return s == null ? s : lS.call(s);
      }
      function mC(s, c, f) {
        var y = s == null ? 0 : s.length;
        return y ? (f && typeof f != "number" && xn(s, c, f) ? (c = 0, f = y) : (c = c == null ? 0 : Ge(c), f = f === t ? y : Ge(f)), sr(s, c, f)) : [];
      }
      function vC(s, c) {
        return ul(s, c);
      }
      function yC(s, c, f) {
        return Hu(s, c, ze(f, 2));
      }
      function wC(s, c) {
        var f = s == null ? 0 : s.length;
        if (f) {
          var y = ul(s, c);
          if (y < f && br(s[y], c))
            return y;
        }
        return -1;
      }
      function bC(s, c) {
        return ul(s, c, !0);
      }
      function xC(s, c, f) {
        return Hu(s, c, ze(f, 2), !0);
      }
      function SC(s, c) {
        var f = s == null ? 0 : s.length;
        if (f) {
          var y = ul(s, c, !0) - 1;
          if (br(s[y], c))
            return y;
        }
        return -1;
      }
      function CC(s) {
        return s && s.length ? eg(s) : [];
      }
      function EC(s, c) {
        return s && s.length ? eg(s, ze(c, 2)) : [];
      }
      function kC(s) {
        var c = s == null ? 0 : s.length;
        return c ? sr(s, 1, c) : [];
      }
      function OC(s, c, f) {
        return s && s.length ? (c = f || c === t ? 1 : Ge(c), sr(s, 0, c < 0 ? 0 : c)) : [];
      }
      function TC(s, c, f) {
        var y = s == null ? 0 : s.length;
        return y ? (c = f || c === t ? 1 : Ge(c), c = y - c, sr(s, c < 0 ? 0 : c, y)) : [];
      }
      function MC(s, c) {
        return s && s.length ? dl(s, ze(c, 3), !1, !0) : [];
      }
      function RC(s, c) {
        return s && s.length ? dl(s, ze(c, 3)) : [];
      }
      var DC = Xe(function(s) {
        return bi(Jt(s, 1, Pt, !0));
      }), IC = Xe(function(s) {
        var c = ar(s);
        return Pt(c) && (c = t), bi(Jt(s, 1, Pt, !0), ze(c, 2));
      }), AC = Xe(function(s) {
        var c = ar(s);
        return c = typeof c == "function" ? c : t, bi(Jt(s, 1, Pt, !0), t, c);
      });
      function LC(s) {
        return s && s.length ? bi(s) : [];
      }
      function PC(s, c) {
        return s && s.length ? bi(s, ze(c, 2)) : [];
      }
      function _C(s, c) {
        return c = typeof c == "function" ? c : t, s && s.length ? bi(s, t, c) : [];
      }
      function sd(s) {
        if (!(s && s.length))
          return [];
        var c = 0;
        return s = pi(s, function(f) {
          if (Pt(f))
            return c = $t(f.length, c), !0;
        }), Cu(c, function(f) {
          return Ot(s, bu(f));
        });
      }
      function Vg(s, c) {
        if (!(s && s.length))
          return [];
        var f = sd(s);
        return c == null ? f : Ot(f, function(y) {
          return Wn(c, t, y);
        });
      }
      var NC = Xe(function(s, c) {
        return Pt(s) ? Rs(s, c) : [];
      }), zC = Xe(function(s) {
        return Uu(pi(s, Pt));
      }), BC = Xe(function(s) {
        var c = ar(s);
        return Pt(c) && (c = t), Uu(pi(s, Pt), ze(c, 2));
      }), FC = Xe(function(s) {
        var c = ar(s);
        return c = typeof c == "function" ? c : t, Uu(pi(s, Pt), t, c);
      }), VC = Xe(sd);
      function WC(s, c) {
        return ig(s || [], c || [], Ms);
      }
      function HC(s, c) {
        return ig(s || [], c || [], As);
      }
      var $C = Xe(function(s) {
        var c = s.length, f = c > 1 ? s[c - 1] : t;
        return f = typeof f == "function" ? (s.pop(), f) : t, Vg(s, f);
      });
      function Wg(s) {
        var c = E(s);
        return c.__chain__ = !0, c;
      }
      function UC(s, c) {
        return c(s), s;
      }
      function bl(s, c) {
        return c(s);
      }
      var ZC = Xr(function(s) {
        var c = s.length, f = c ? s[0] : 0, y = this.__wrapped__, S = function(O) {
          return Iu(O, s);
        };
        return c > 1 || this.__actions__.length || !(y instanceof et) || !Jr(f) ? this.thru(S) : (y = y.slice(f, +f + (c ? 1 : 0)), y.__actions__.push({
          func: bl,
          args: [S],
          thisArg: t
        }), new ir(y, this.__chain__).thru(function(O) {
          return c && !O.length && O.push(t), O;
        }));
      });
      function jC() {
        return Wg(this);
      }
      function YC() {
        return new ir(this.value(), this.__chain__);
      }
      function qC() {
        this.__values__ === t && (this.__values__ = t0(this.value()));
        var s = this.__index__ >= this.__values__.length, c = s ? t : this.__values__[this.__index__++];
        return { done: s, value: c };
      }
      function GC() {
        return this;
      }
      function KC(s) {
        for (var c, f = this; f instanceof ol; ) {
          var y = Pg(f);
          y.__index__ = 0, y.__values__ = t, c ? S.__wrapped__ = y : c = y;
          var S = y;
          f = f.__wrapped__;
        }
        return S.__wrapped__ = s, c;
      }
      function XC() {
        var s = this.__wrapped__;
        if (s instanceof et) {
          var c = s;
          return this.__actions__.length && (c = new et(this)), c = c.reverse(), c.__actions__.push({
            func: bl,
            args: [od],
            thisArg: t
          }), new ir(c, this.__chain__);
        }
        return this.thru(od);
      }
      function JC() {
        return rg(this.__wrapped__, this.__actions__);
      }
      var QC = fl(function(s, c, f) {
        mt.call(s, f) ? ++s[f] : Gr(s, f, 1);
      });
      function e6(s, c, f) {
        var y = Ye(s) ? mp : US;
        return f && xn(s, c, f) && (c = t), y(s, ze(c, 3));
      }
      function t6(s, c) {
        var f = Ye(s) ? pi : Vp;
        return f(s, ze(c, 3));
      }
      var n6 = pg(_g), r6 = pg(Ng);
      function i6(s, c) {
        return Jt(xl(s, c), 1);
      }
      function o6(s, c) {
        return Jt(xl(s, c), oe);
      }
      function s6(s, c, f) {
        return f = f === t ? 1 : Ge(f), Jt(xl(s, c), f);
      }
      function Hg(s, c) {
        var f = Ye(s) ? nr : wi;
        return f(s, ze(c, 3));
      }
      function $g(s, c) {
        var f = Ye(s) ? kx : Fp;
        return f(s, ze(c, 3));
      }
      var a6 = fl(function(s, c, f) {
        mt.call(s, f) ? s[f].push(c) : Gr(s, f, [c]);
      });
      function l6(s, c, f, y) {
        s = Dn(s) ? s : Zo(s), f = f && !y ? Ge(f) : 0;
        var S = s.length;
        return f < 0 && (f = $t(S + f, 0)), Ol(s) ? f <= S && s.indexOf(c, f) > -1 : !!S && Lo(s, c, f) > -1;
      }
      var c6 = Xe(function(s, c, f) {
        var y = -1, S = typeof c == "function", O = Dn(s) ? V(s.length) : [];
        return wi(s, function(I) {
          O[++y] = S ? Wn(c, I, f) : Ds(I, c, f);
        }), O;
      }), u6 = fl(function(s, c, f) {
        Gr(s, f, c);
      });
      function xl(s, c) {
        var f = Ye(s) ? Ot : jp;
        return f(s, ze(c, 3));
      }
      function d6(s, c, f, y) {
        return s == null ? [] : (Ye(c) || (c = c == null ? [] : [c]), f = y ? t : f, Ye(f) || (f = f == null ? [] : [f]), Kp(s, c, f));
      }
      var f6 = fl(function(s, c, f) {
        s[f ? 0 : 1].push(c);
      }, function() {
        return [[], []];
      });
      function h6(s, c, f) {
        var y = Ye(s) ? yu : bp, S = arguments.length < 3;
        return y(s, ze(c, 4), f, S, wi);
      }
      function p6(s, c, f) {
        var y = Ye(s) ? Ox : bp, S = arguments.length < 3;
        return y(s, ze(c, 4), f, S, Fp);
      }
      function g6(s, c) {
        var f = Ye(s) ? pi : Vp;
        return f(s, El(ze(c, 3)));
      }
      function m6(s) {
        var c = Ye(s) ? _p : l2;
        return c(s);
      }
      function v6(s, c, f) {
        (f ? xn(s, c, f) : c === t) ? c = 1 : c = Ge(c);
        var y = Ye(s) ? FS : c2;
        return y(s, c);
      }
      function y6(s) {
        var c = Ye(s) ? VS : d2;
        return c(s);
      }
      function w6(s) {
        if (s == null)
          return 0;
        if (Dn(s))
          return Ol(s) ? _o(s) : s.length;
        var c = ln(s);
        return c == Be || c == fe ? s.size : zu(s).length;
      }
      function b6(s, c, f) {
        var y = Ye(s) ? wu : f2;
        return f && xn(s, c, f) && (c = t), y(s, ze(c, 3));
      }
      var x6 = Xe(function(s, c) {
        if (s == null)
          return [];
        var f = c.length;
        return f > 1 && xn(s, c[0], c[1]) ? c = [] : f > 2 && xn(c[0], c[1], c[2]) && (c = [c[0]]), Kp(s, Jt(c, 1), []);
      }), Sl = tS || function() {
        return Xt.Date.now();
      };
      function S6(s, c) {
        if (typeof c != "function")
          throw new rr(a);
        return s = Ge(s), function() {
          if (--s < 1)
            return c.apply(this, arguments);
        };
      }
      function Ug(s, c, f) {
        return c = f ? t : c, c = s && c == null ? s.length : c, Kr(s, _, t, t, t, t, c);
      }
      function Zg(s, c) {
        var f;
        if (typeof c != "function")
          throw new rr(a);
        return s = Ge(s), function() {
          return --s > 0 && (f = c.apply(this, arguments)), s <= 1 && (c = t), f;
        };
      }
      var ad = Xe(function(s, c, f) {
        var y = b;
        if (f.length) {
          var S = mi(f, $o(ad));
          y |= T;
        }
        return Kr(s, y, c, f, S);
      }), jg = Xe(function(s, c, f) {
        var y = b | C;
        if (f.length) {
          var S = mi(f, $o(jg));
          y |= T;
        }
        return Kr(c, y, s, f, S);
      });
      function Yg(s, c, f) {
        c = f ? t : c;
        var y = Kr(s, k, t, t, t, t, t, c);
        return y.placeholder = Yg.placeholder, y;
      }
      function qg(s, c, f) {
        c = f ? t : c;
        var y = Kr(s, D, t, t, t, t, t, c);
        return y.placeholder = qg.placeholder, y;
      }
      function Gg(s, c, f) {
        var y, S, O, I, L, B, X = 0, J = !1, ne = !1, he = !0;
        if (typeof s != "function")
          throw new rr(a);
        c = lr(c) || 0, Rt(f) && (J = !!f.leading, ne = "maxWait" in f, O = ne ? $t(lr(f.maxWait) || 0, c) : O, he = "trailing" in f ? !!f.trailing : he);
        function Me(_t) {
          var xr = y, ti = S;
          return y = S = t, X = _t, I = s.apply(ti, xr), I;
        }
        function Ve(_t) {
          return X = _t, L = _s(Qe, c), J ? Me(_t) : I;
        }
        function Ke(_t) {
          var xr = _t - B, ti = _t - X, p0 = c - xr;
          return ne ? an(p0, O - ti) : p0;
        }
        function We(_t) {
          var xr = _t - B, ti = _t - X;
          return B === t || xr >= c || xr < 0 || ne && ti >= O;
        }
        function Qe() {
          var _t = Sl();
          if (We(_t))
            return nt(_t);
          L = _s(Qe, Ke(_t));
        }
        function nt(_t) {
          return L = t, he && y ? Me(_t) : (y = S = t, I);
        }
        function Zn() {
          L !== t && og(L), X = 0, y = B = S = L = t;
        }
        function Sn() {
          return L === t ? I : nt(Sl());
        }
        function jn() {
          var _t = Sl(), xr = We(_t);
          if (y = arguments, S = this, B = _t, xr) {
            if (L === t)
              return Ve(B);
            if (ne)
              return og(L), L = _s(Qe, c), Me(B);
          }
          return L === t && (L = _s(Qe, c)), I;
        }
        return jn.cancel = Zn, jn.flush = Sn, jn;
      }
      var C6 = Xe(function(s, c) {
        return Bp(s, 1, c);
      }), E6 = Xe(function(s, c, f) {
        return Bp(s, lr(c) || 0, f);
      });
      function k6(s) {
        return Kr(s, K);
      }
      function Cl(s, c) {
        if (typeof s != "function" || c != null && typeof c != "function")
          throw new rr(a);
        var f = function() {
          var y = arguments, S = c ? c.apply(this, y) : y[0], O = f.cache;
          if (O.has(S))
            return O.get(S);
          var I = s.apply(this, y);
          return f.cache = O.set(S, I) || O, I;
        };
        return f.cache = new (Cl.Cache || qr)(), f;
      }
      Cl.Cache = qr;
      function El(s) {
        if (typeof s != "function")
          throw new rr(a);
        return function() {
          var c = arguments;
          switch (c.length) {
            case 0:
              return !s.call(this);
            case 1:
              return !s.call(this, c[0]);
            case 2:
              return !s.call(this, c[0], c[1]);
            case 3:
              return !s.call(this, c[0], c[1], c[2]);
          }
          return !s.apply(this, c);
        };
      }
      function O6(s) {
        return Zg(2, s);
      }
      var T6 = h2(function(s, c) {
        c = c.length == 1 && Ye(c[0]) ? Ot(c[0], Hn(ze())) : Ot(Jt(c, 1), Hn(ze()));
        var f = c.length;
        return Xe(function(y) {
          for (var S = -1, O = an(y.length, f); ++S < O; )
            y[S] = c[S].call(this, y[S]);
          return Wn(s, this, y);
        });
      }), ld = Xe(function(s, c) {
        var f = mi(c, $o(ld));
        return Kr(s, T, t, c, f);
      }), Kg = Xe(function(s, c) {
        var f = mi(c, $o(Kg));
        return Kr(s, R, t, c, f);
      }), M6 = Xr(function(s, c) {
        return Kr(s, Z, t, t, t, c);
      });
      function R6(s, c) {
        if (typeof s != "function")
          throw new rr(a);
        return c = c === t ? c : Ge(c), Xe(s, c);
      }
      function D6(s, c) {
        if (typeof s != "function")
          throw new rr(a);
        return c = c == null ? 0 : $t(Ge(c), 0), Xe(function(f) {
          var y = f[c], S = Si(f, 0, c);
          return y && gi(S, y), Wn(s, this, S);
        });
      }
      function I6(s, c, f) {
        var y = !0, S = !0;
        if (typeof s != "function")
          throw new rr(a);
        return Rt(f) && (y = "leading" in f ? !!f.leading : y, S = "trailing" in f ? !!f.trailing : S), Gg(s, c, {
          leading: y,
          maxWait: c,
          trailing: S
        });
      }
      function A6(s) {
        return Ug(s, 1);
      }
      function L6(s, c) {
        return ld(ju(c), s);
      }
      function P6() {
        if (!arguments.length)
          return [];
        var s = arguments[0];
        return Ye(s) ? s : [s];
      }
      function _6(s) {
        return or(s, v);
      }
      function N6(s, c) {
        return c = typeof c == "function" ? c : t, or(s, v, c);
      }
      function z6(s) {
        return or(s, p | v);
      }
      function B6(s, c) {
        return c = typeof c == "function" ? c : t, or(s, p | v, c);
      }
      function F6(s, c) {
        return c == null || zp(s, c, qt(c));
      }
      function br(s, c) {
        return s === c || s !== s && c !== c;
      }
      var V6 = ml(Pu), W6 = ml(function(s, c) {
        return s >= c;
      }), so = $p(function() {
        return arguments;
      }()) ? $p : function(s) {
        return At(s) && mt.call(s, "callee") && !Rp.call(s, "callee");
      }, Ye = V.isArray, H6 = up ? Hn(up) : KS;
      function Dn(s) {
        return s != null && kl(s.length) && !Qr(s);
      }
      function Pt(s) {
        return At(s) && Dn(s);
      }
      function $6(s) {
        return s === !0 || s === !1 || At(s) && bn(s) == G;
      }
      var Ci = rS || wd, U6 = dp ? Hn(dp) : XS;
      function Z6(s) {
        return At(s) && s.nodeType === 1 && !Ns(s);
      }
      function j6(s) {
        if (s == null)
          return !0;
        if (Dn(s) && (Ye(s) || typeof s == "string" || typeof s.splice == "function" || Ci(s) || Uo(s) || so(s)))
          return !s.length;
        var c = ln(s);
        if (c == Be || c == fe)
          return !s.size;
        if (Ps(s))
          return !zu(s).length;
        for (var f in s)
          if (mt.call(s, f))
            return !1;
        return !0;
      }
      function Y6(s, c) {
        return Is(s, c);
      }
      function q6(s, c, f) {
        f = typeof f == "function" ? f : t;
        var y = f ? f(s, c) : t;
        return y === t ? Is(s, c, t, f) : !!y;
      }
      function cd(s) {
        if (!At(s))
          return !1;
        var c = bn(s);
        return c == Je || c == ye || typeof s.message == "string" && typeof s.name == "string" && !Ns(s);
      }
      function G6(s) {
        return typeof s == "number" && Ip(s);
      }
      function Qr(s) {
        if (!Rt(s))
          return !1;
        var c = bn(s);
        return c == te || c == $e || c == ae || c == H;
      }
      function Xg(s) {
        return typeof s == "number" && s == Ge(s);
      }
      function kl(s) {
        return typeof s == "number" && s > -1 && s % 1 == 0 && s <= de;
      }
      function Rt(s) {
        var c = typeof s;
        return s != null && (c == "object" || c == "function");
      }
      function At(s) {
        return s != null && typeof s == "object";
      }
      var Jg = fp ? Hn(fp) : QS;
      function K6(s, c) {
        return s === c || Nu(s, c, Qu(c));
      }
      function X6(s, c, f) {
        return f = typeof f == "function" ? f : t, Nu(s, c, Qu(c), f);
      }
      function J6(s) {
        return Qg(s) && s != +s;
      }
      function Q6(s) {
        if (N2(s))
          throw new Ze(o);
        return Up(s);
      }
      function eE(s) {
        return s === null;
      }
      function tE(s) {
        return s == null;
      }
      function Qg(s) {
        return typeof s == "number" || At(s) && bn(s) == vt;
      }
      function Ns(s) {
        if (!At(s) || bn(s) != A)
          return !1;
        var c = Ja(s);
        if (c === null)
          return !0;
        var f = mt.call(c, "constructor") && c.constructor;
        return typeof f == "function" && f instanceof f && qa.call(f) == Xx;
      }
      var ud = hp ? Hn(hp) : e2;
      function nE(s) {
        return Xg(s) && s >= -de && s <= de;
      }
      var e0 = pp ? Hn(pp) : t2;
      function Ol(s) {
        return typeof s == "string" || !Ye(s) && At(s) && bn(s) == _e;
      }
      function Un(s) {
        return typeof s == "symbol" || At(s) && bn(s) == tt;
      }
      var Uo = gp ? Hn(gp) : n2;
      function rE(s) {
        return s === t;
      }
      function iE(s) {
        return At(s) && ln(s) == Pe;
      }
      function oE(s) {
        return At(s) && bn(s) == qe;
      }
      var sE = ml(Bu), aE = ml(function(s, c) {
        return s <= c;
      });
      function t0(s) {
        if (!s)
          return [];
        if (Dn(s))
          return Ol(s) ? yr(s) : Rn(s);
        if (Cs && s[Cs])
          return Fx(s[Cs]());
        var c = ln(s), f = c == Be ? ku : c == fe ? Za : Zo;
        return f(s);
      }
      function ei(s) {
        if (!s)
          return s === 0 ? s : 0;
        if (s = lr(s), s === oe || s === -oe) {
          var c = s < 0 ? -1 : 1;
          return c * se;
        }
        return s === s ? s : 0;
      }
      function Ge(s) {
        var c = ei(s), f = c % 1;
        return c === c ? f ? c - f : c : 0;
      }
      function n0(s) {
        return s ? no(Ge(s), 0, Oe) : 0;
      }
      function lr(s) {
        if (typeof s == "number")
          return s;
        if (Un(s))
          return we;
        if (Rt(s)) {
          var c = typeof s.valueOf == "function" ? s.valueOf() : s;
          s = Rt(c) ? c + "" : c;
        }
        if (typeof s != "string")
          return s === 0 ? s : +s;
        s = xp(s);
        var f = Hb.test(s);
        return f || Ub.test(s) ? Sx(s.slice(2), f ? 2 : 8) : Wb.test(s) ? we : +s;
      }
      function r0(s) {
        return Ir(s, In(s));
      }
      function lE(s) {
        return s ? no(Ge(s), -de, de) : s === 0 ? s : 0;
      }
      function dt(s) {
        return s == null ? "" : $n(s);
      }
      var cE = Wo(function(s, c) {
        if (Ps(c) || Dn(c)) {
          Ir(c, qt(c), s);
          return;
        }
        for (var f in c)
          mt.call(c, f) && Ms(s, f, c[f]);
      }), i0 = Wo(function(s, c) {
        Ir(c, In(c), s);
      }), Tl = Wo(function(s, c, f, y) {
        Ir(c, In(c), s, y);
      }), uE = Wo(function(s, c, f, y) {
        Ir(c, qt(c), s, y);
      }), dE = Xr(Iu);
      function fE(s, c) {
        var f = Vo(s);
        return c == null ? f : Np(f, c);
      }
      var hE = Xe(function(s, c) {
        s = wt(s);
        var f = -1, y = c.length, S = y > 2 ? c[2] : t;
        for (S && xn(c[0], c[1], S) && (y = 1); ++f < y; )
          for (var O = c[f], I = In(O), L = -1, B = I.length; ++L < B; ) {
            var X = I[L], J = s[X];
            (J === t || br(J, zo[X]) && !mt.call(s, X)) && (s[X] = O[X]);
          }
        return s;
      }), pE = Xe(function(s) {
        return s.push(t, xg), Wn(o0, t, s);
      });
      function gE(s, c) {
        return vp(s, ze(c, 3), Dr);
      }
      function mE(s, c) {
        return vp(s, ze(c, 3), Lu);
      }
      function vE(s, c) {
        return s == null ? s : Au(s, ze(c, 3), In);
      }
      function yE(s, c) {
        return s == null ? s : Wp(s, ze(c, 3), In);
      }
      function wE(s, c) {
        return s && Dr(s, ze(c, 3));
      }
      function bE(s, c) {
        return s && Lu(s, ze(c, 3));
      }
      function xE(s) {
        return s == null ? [] : ll(s, qt(s));
      }
      function SE(s) {
        return s == null ? [] : ll(s, In(s));
      }
      function dd(s, c, f) {
        var y = s == null ? t : ro(s, c);
        return y === t ? f : y;
      }
      function CE(s, c) {
        return s != null && Eg(s, c, jS);
      }
      function fd(s, c) {
        return s != null && Eg(s, c, YS);
      }
      var EE = mg(function(s, c, f) {
        c != null && typeof c.toString != "function" && (c = Ga.call(c)), s[c] = f;
      }, pd(An)), kE = mg(function(s, c, f) {
        c != null && typeof c.toString != "function" && (c = Ga.call(c)), mt.call(s, c) ? s[c].push(f) : s[c] = [f];
      }, ze), OE = Xe(Ds);
      function qt(s) {
        return Dn(s) ? Pp(s) : zu(s);
      }
      function In(s) {
        return Dn(s) ? Pp(s, !0) : r2(s);
      }
      function TE(s, c) {
        var f = {};
        return c = ze(c, 3), Dr(s, function(y, S, O) {
          Gr(f, c(y, S, O), y);
        }), f;
      }
      function ME(s, c) {
        var f = {};
        return c = ze(c, 3), Dr(s, function(y, S, O) {
          Gr(f, S, c(y, S, O));
        }), f;
      }
      var RE = Wo(function(s, c, f) {
        cl(s, c, f);
      }), o0 = Wo(function(s, c, f, y) {
        cl(s, c, f, y);
      }), DE = Xr(function(s, c) {
        var f = {};
        if (s == null)
          return f;
        var y = !1;
        c = Ot(c, function(O) {
          return O = xi(O, s), y || (y = O.length > 1), O;
        }), Ir(s, Xu(s), f), y && (f = or(f, p | g | v, E2));
        for (var S = c.length; S--; )
          $u(f, c[S]);
        return f;
      });
      function IE(s, c) {
        return s0(s, El(ze(c)));
      }
      var AE = Xr(function(s, c) {
        return s == null ? {} : o2(s, c);
      });
      function s0(s, c) {
        if (s == null)
          return {};
        var f = Ot(Xu(s), function(y) {
          return [y];
        });
        return c = ze(c), Xp(s, f, function(y, S) {
          return c(y, S[0]);
        });
      }
      function LE(s, c, f) {
        c = xi(c, s);
        var y = -1, S = c.length;
        for (S || (S = 1, s = t); ++y < S; ) {
          var O = s == null ? t : s[Ar(c[y])];
          O === t && (y = S, O = f), s = Qr(O) ? O.call(s) : O;
        }
        return s;
      }
      function PE(s, c, f) {
        return s == null ? s : As(s, c, f);
      }
      function _E(s, c, f, y) {
        return y = typeof y == "function" ? y : t, s == null ? s : As(s, c, f, y);
      }
      var a0 = wg(qt), l0 = wg(In);
      function NE(s, c, f) {
        var y = Ye(s), S = y || Ci(s) || Uo(s);
        if (c = ze(c, 4), f == null) {
          var O = s && s.constructor;
          S ? f = y ? new O() : [] : Rt(s) ? f = Qr(O) ? Vo(Ja(s)) : {} : f = {};
        }
        return (S ? nr : Dr)(s, function(I, L, B) {
          return c(f, I, L, B);
        }), f;
      }
      function zE(s, c) {
        return s == null ? !0 : $u(s, c);
      }
      function BE(s, c, f) {
        return s == null ? s : ng(s, c, ju(f));
      }
      function FE(s, c, f, y) {
        return y = typeof y == "function" ? y : t, s == null ? s : ng(s, c, ju(f), y);
      }
      function Zo(s) {
        return s == null ? [] : Eu(s, qt(s));
      }
      function VE(s) {
        return s == null ? [] : Eu(s, In(s));
      }
      function WE(s, c, f) {
        return f === t && (f = c, c = t), f !== t && (f = lr(f), f = f === f ? f : 0), c !== t && (c = lr(c), c = c === c ? c : 0), no(lr(s), c, f);
      }
      function HE(s, c, f) {
        return c = ei(c), f === t ? (f = c, c = 0) : f = ei(f), s = lr(s), qS(s, c, f);
      }
      function $E(s, c, f) {
        if (f && typeof f != "boolean" && xn(s, c, f) && (c = f = t), f === t && (typeof c == "boolean" ? (f = c, c = t) : typeof s == "boolean" && (f = s, s = t)), s === t && c === t ? (s = 0, c = 1) : (s = ei(s), c === t ? (c = s, s = 0) : c = ei(c)), s > c) {
          var y = s;
          s = c, c = y;
        }
        if (f || s % 1 || c % 1) {
          var S = Ap();
          return an(s + S * (c - s + xx("1e-" + ((S + "").length - 1))), c);
        }
        return Vu(s, c);
      }
      var UE = Ho(function(s, c, f) {
        return c = c.toLowerCase(), s + (f ? c0(c) : c);
      });
      function c0(s) {
        return hd(dt(s).toLowerCase());
      }
      function u0(s) {
        return s = dt(s), s && s.replace(jb, Px).replace(dx, "");
      }
      function ZE(s, c, f) {
        s = dt(s), c = $n(c);
        var y = s.length;
        f = f === t ? y : no(Ge(f), 0, y);
        var S = f;
        return f -= c.length, f >= 0 && s.slice(f, S) == c;
      }
      function jE(s) {
        return s = dt(s), s && Rr.test(s) ? s.replace(sn, _x) : s;
      }
      function YE(s) {
        return s = dt(s), s && Io.test(s) ? s.replace(jr, "\\$&") : s;
      }
      var qE = Ho(function(s, c, f) {
        return s + (f ? "-" : "") + c.toLowerCase();
      }), GE = Ho(function(s, c, f) {
        return s + (f ? " " : "") + c.toLowerCase();
      }), KE = hg("toLowerCase");
      function XE(s, c, f) {
        s = dt(s), c = Ge(c);
        var y = c ? _o(s) : 0;
        if (!c || y >= c)
          return s;
        var S = (c - y) / 2;
        return gl(nl(S), f) + s + gl(tl(S), f);
      }
      function JE(s, c, f) {
        s = dt(s), c = Ge(c);
        var y = c ? _o(s) : 0;
        return c && y < c ? s + gl(c - y, f) : s;
      }
      function QE(s, c, f) {
        s = dt(s), c = Ge(c);
        var y = c ? _o(s) : 0;
        return c && y < c ? gl(c - y, f) + s : s;
      }
      function ek(s, c, f) {
        return f || c == null ? c = 0 : c && (c = +c), aS(dt(s).replace(hi, ""), c || 0);
      }
      function tk(s, c, f) {
        return (f ? xn(s, c, f) : c === t) ? c = 1 : c = Ge(c), Wu(dt(s), c);
      }
      function nk() {
        var s = arguments, c = dt(s[0]);
        return s.length < 3 ? c : c.replace(s[1], s[2]);
      }
      var rk = Ho(function(s, c, f) {
        return s + (f ? "_" : "") + c.toLowerCase();
      });
      function ik(s, c, f) {
        return f && typeof f != "number" && xn(s, c, f) && (c = f = t), f = f === t ? Oe : f >>> 0, f ? (s = dt(s), s && (typeof c == "string" || c != null && !ud(c)) && (c = $n(c), !c && Po(s)) ? Si(yr(s), 0, f) : s.split(c, f)) : [];
      }
      var ok = Ho(function(s, c, f) {
        return s + (f ? " " : "") + hd(c);
      });
      function sk(s, c, f) {
        return s = dt(s), f = f == null ? 0 : no(Ge(f), 0, s.length), c = $n(c), s.slice(f, f + c.length) == c;
      }
      function ak(s, c, f) {
        var y = E.templateSettings;
        f && xn(s, c, f) && (c = t), s = dt(s), c = Tl({}, c, y, bg);
        var S = Tl({}, c.imports, y.imports, bg), O = qt(S), I = Eu(S, O), L, B, X = 0, J = c.interpolate || Va, ne = "__p += '", he = Ou(
          (c.escape || Va).source + "|" + J.source + "|" + (J === Fn ? Vb : Va).source + "|" + (c.evaluate || Va).source + "|$",
          "g"
        ), Me = "//# sourceURL=" + (mt.call(c, "sourceURL") ? (c.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++mx + "]") + `
`;
        s.replace(he, function(We, Qe, nt, Zn, Sn, jn) {
          return nt || (nt = Zn), ne += s.slice(X, jn).replace(Yb, Nx), Qe && (L = !0, ne += `' +
__e(` + Qe + `) +
'`), Sn && (B = !0, ne += `';
` + Sn + `;
__p += '`), nt && (ne += `' +
((__t = (` + nt + `)) == null ? '' : __t) +
'`), X = jn + We.length, We;
        }), ne += `';
`;
        var Ve = mt.call(c, "variable") && c.variable;
        if (!Ve)
          ne = `with (obj) {
` + ne + `
}
`;
        else if (Bb.test(Ve))
          throw new Ze(l);
        ne = (B ? ne.replace(au, "") : ne).replace(lu, "$1").replace(cu, "$1;"), ne = "function(" + (Ve || "obj") + `) {
` + (Ve ? "" : `obj || (obj = {});
`) + "var __t, __p = ''" + (L ? ", __e = _.escape" : "") + (B ? `, __j = Array.prototype.join;
function print() { __p += __j.call(arguments, '') }
` : `;
`) + ne + `return __p
}`;
        var Ke = f0(function() {
          return st(O, Me + "return " + ne).apply(t, I);
        });
        if (Ke.source = ne, cd(Ke))
          throw Ke;
        return Ke;
      }
      function lk(s) {
        return dt(s).toLowerCase();
      }
      function ck(s) {
        return dt(s).toUpperCase();
      }
      function uk(s, c, f) {
        if (s = dt(s), s && (f || c === t))
          return xp(s);
        if (!s || !(c = $n(c)))
          return s;
        var y = yr(s), S = yr(c), O = Sp(y, S), I = Cp(y, S) + 1;
        return Si(y, O, I).join("");
      }
      function dk(s, c, f) {
        if (s = dt(s), s && (f || c === t))
          return s.slice(0, kp(s) + 1);
        if (!s || !(c = $n(c)))
          return s;
        var y = yr(s), S = Cp(y, yr(c)) + 1;
        return Si(y, 0, S).join("");
      }
      function fk(s, c, f) {
        if (s = dt(s), s && (f || c === t))
          return s.replace(hi, "");
        if (!s || !(c = $n(c)))
          return s;
        var y = yr(s), S = Sp(y, yr(c));
        return Si(y, S).join("");
      }
      function hk(s, c) {
        var f = $, y = F;
        if (Rt(c)) {
          var S = "separator" in c ? c.separator : S;
          f = "length" in c ? Ge(c.length) : f, y = "omission" in c ? $n(c.omission) : y;
        }
        s = dt(s);
        var O = s.length;
        if (Po(s)) {
          var I = yr(s);
          O = I.length;
        }
        if (f >= O)
          return s;
        var L = f - _o(y);
        if (L < 1)
          return y;
        var B = I ? Si(I, 0, L).join("") : s.slice(0, L);
        if (S === t)
          return B + y;
        if (I && (L += B.length - L), ud(S)) {
          if (s.slice(L).search(S)) {
            var X, J = B;
            for (S.global || (S = Ou(S.source, dt($h.exec(S)) + "g")), S.lastIndex = 0; X = S.exec(J); )
              var ne = X.index;
            B = B.slice(0, ne === t ? L : ne);
          }
        } else if (s.indexOf($n(S), L) != L) {
          var he = B.lastIndexOf(S);
          he > -1 && (B = B.slice(0, he));
        }
        return B + y;
      }
      function pk(s) {
        return s = dt(s), s && wn.test(s) ? s.replace(zt, $x) : s;
      }
      var gk = Ho(function(s, c, f) {
        return s + (f ? " " : "") + c.toUpperCase();
      }), hd = hg("toUpperCase");
      function d0(s, c, f) {
        return s = dt(s), c = f ? t : c, c === t ? Bx(s) ? jx(s) : Rx(s) : s.match(c) || [];
      }
      var f0 = Xe(function(s, c) {
        try {
          return Wn(s, t, c);
        } catch (f) {
          return cd(f) ? f : new Ze(f);
        }
      }), mk = Xr(function(s, c) {
        return nr(c, function(f) {
          f = Ar(f), Gr(s, f, ad(s[f], s));
        }), s;
      });
      function vk(s) {
        var c = s == null ? 0 : s.length, f = ze();
        return s = c ? Ot(s, function(y) {
          if (typeof y[1] != "function")
            throw new rr(a);
          return [f(y[0]), y[1]];
        }) : [], Xe(function(y) {
          for (var S = -1; ++S < c; ) {
            var O = s[S];
            if (Wn(O[0], this, y))
              return Wn(O[1], this, y);
          }
        });
      }
      function yk(s) {
        return $S(or(s, p));
      }
      function pd(s) {
        return function() {
          return s;
        };
      }
      function wk(s, c) {
        return s == null || s !== s ? c : s;
      }
      var bk = gg(), xk = gg(!0);
      function An(s) {
        return s;
      }
      function gd(s) {
        return Zp(typeof s == "function" ? s : or(s, p));
      }
      function Sk(s) {
        return Yp(or(s, p));
      }
      function Ck(s, c) {
        return qp(s, or(c, p));
      }
      var Ek = Xe(function(s, c) {
        return function(f) {
          return Ds(f, s, c);
        };
      }), kk = Xe(function(s, c) {
        return function(f) {
          return Ds(s, f, c);
        };
      });
      function md(s, c, f) {
        var y = qt(c), S = ll(c, y);
        f == null && !(Rt(c) && (S.length || !y.length)) && (f = c, c = s, s = this, S = ll(c, qt(c)));
        var O = !(Rt(f) && "chain" in f) || !!f.chain, I = Qr(s);
        return nr(S, function(L) {
          var B = c[L];
          s[L] = B, I && (s.prototype[L] = function() {
            var X = this.__chain__;
            if (O || X) {
              var J = s(this.__wrapped__), ne = J.__actions__ = Rn(this.__actions__);
              return ne.push({ func: B, args: arguments, thisArg: s }), J.__chain__ = X, J;
            }
            return B.apply(s, gi([this.value()], arguments));
          });
        }), s;
      }
      function Ok() {
        return Xt._ === this && (Xt._ = Jx), this;
      }
      function vd() {
      }
      function Tk(s) {
        return s = Ge(s), Xe(function(c) {
          return Gp(c, s);
        });
      }
      var Mk = qu(Ot), Rk = qu(mp), Dk = qu(wu);
      function h0(s) {
        return td(s) ? bu(Ar(s)) : s2(s);
      }
      function Ik(s) {
        return function(c) {
          return s == null ? t : ro(s, c);
        };
      }
      var Ak = vg(), Lk = vg(!0);
      function yd() {
        return [];
      }
      function wd() {
        return !1;
      }
      function Pk() {
        return {};
      }
      function _k() {
        return "";
      }
      function Nk() {
        return !0;
      }
      function zk(s, c) {
        if (s = Ge(s), s < 1 || s > de)
          return [];
        var f = Oe, y = an(s, Oe);
        c = ze(c), s -= Oe;
        for (var S = Cu(y, c); ++f < s; )
          c(f);
        return S;
      }
      function Bk(s) {
        return Ye(s) ? Ot(s, Ar) : Un(s) ? [s] : Rn(Lg(dt(s)));
      }
      function Fk(s) {
        var c = ++Kx;
        return dt(s) + c;
      }
      var Vk = pl(function(s, c) {
        return s + c;
      }, 0), Wk = Gu("ceil"), Hk = pl(function(s, c) {
        return s / c;
      }, 1), $k = Gu("floor");
      function Uk(s) {
        return s && s.length ? al(s, An, Pu) : t;
      }
      function Zk(s, c) {
        return s && s.length ? al(s, ze(c, 2), Pu) : t;
      }
      function jk(s) {
        return wp(s, An);
      }
      function Yk(s, c) {
        return wp(s, ze(c, 2));
      }
      function qk(s) {
        return s && s.length ? al(s, An, Bu) : t;
      }
      function Gk(s, c) {
        return s && s.length ? al(s, ze(c, 2), Bu) : t;
      }
      var Kk = pl(function(s, c) {
        return s * c;
      }, 1), Xk = Gu("round"), Jk = pl(function(s, c) {
        return s - c;
      }, 0);
      function Qk(s) {
        return s && s.length ? Su(s, An) : 0;
      }
      function e8(s, c) {
        return s && s.length ? Su(s, ze(c, 2)) : 0;
      }
      return E.after = S6, E.ary = Ug, E.assign = cE, E.assignIn = i0, E.assignInWith = Tl, E.assignWith = uE, E.at = dE, E.before = Zg, E.bind = ad, E.bindAll = mk, E.bindKey = jg, E.castArray = P6, E.chain = Wg, E.chunk = $2, E.compact = U2, E.concat = Z2, E.cond = vk, E.conforms = yk, E.constant = pd, E.countBy = QC, E.create = fE, E.curry = Yg, E.curryRight = qg, E.debounce = Gg, E.defaults = hE, E.defaultsDeep = pE, E.defer = C6, E.delay = E6, E.difference = j2, E.differenceBy = Y2, E.differenceWith = q2, E.drop = G2, E.dropRight = K2, E.dropRightWhile = X2, E.dropWhile = J2, E.fill = Q2, E.filter = t6, E.flatMap = i6, E.flatMapDeep = o6, E.flatMapDepth = s6, E.flatten = zg, E.flattenDeep = eC, E.flattenDepth = tC, E.flip = k6, E.flow = bk, E.flowRight = xk, E.fromPairs = nC, E.functions = xE, E.functionsIn = SE, E.groupBy = a6, E.initial = iC, E.intersection = oC, E.intersectionBy = sC, E.intersectionWith = aC, E.invert = EE, E.invertBy = kE, E.invokeMap = c6, E.iteratee = gd, E.keyBy = u6, E.keys = qt, E.keysIn = In, E.map = xl, E.mapKeys = TE, E.mapValues = ME, E.matches = Sk, E.matchesProperty = Ck, E.memoize = Cl, E.merge = RE, E.mergeWith = o0, E.method = Ek, E.methodOf = kk, E.mixin = md, E.negate = El, E.nthArg = Tk, E.omit = DE, E.omitBy = IE, E.once = O6, E.orderBy = d6, E.over = Mk, E.overArgs = T6, E.overEvery = Rk, E.overSome = Dk, E.partial = ld, E.partialRight = Kg, E.partition = f6, E.pick = AE, E.pickBy = s0, E.property = h0, E.propertyOf = Ik, E.pull = dC, E.pullAll = Fg, E.pullAllBy = fC, E.pullAllWith = hC, E.pullAt = pC, E.range = Ak, E.rangeRight = Lk, E.rearg = M6, E.reject = g6, E.remove = gC, E.rest = R6, E.reverse = od, E.sampleSize = v6, E.set = PE, E.setWith = _E, E.shuffle = y6, E.slice = mC, E.sortBy = x6, E.sortedUniq = CC, E.sortedUniqBy = EC, E.split = ik, E.spread = D6, E.tail = kC, E.take = OC, E.takeRight = TC, E.takeRightWhile = MC, E.takeWhile = RC, E.tap = UC, E.throttle = I6, E.thru = bl, E.toArray = t0, E.toPairs = a0, E.toPairsIn = l0, E.toPath = Bk, E.toPlainObject = r0, E.transform = NE, E.unary = A6, E.union = DC, E.unionBy = IC, E.unionWith = AC, E.uniq = LC, E.uniqBy = PC, E.uniqWith = _C, E.unset = zE, E.unzip = sd, E.unzipWith = Vg, E.update = BE, E.updateWith = FE, E.values = Zo, E.valuesIn = VE, E.without = NC, E.words = d0, E.wrap = L6, E.xor = zC, E.xorBy = BC, E.xorWith = FC, E.zip = VC, E.zipObject = WC, E.zipObjectDeep = HC, E.zipWith = $C, E.entries = a0, E.entriesIn = l0, E.extend = i0, E.extendWith = Tl, md(E, E), E.add = Vk, E.attempt = f0, E.camelCase = UE, E.capitalize = c0, E.ceil = Wk, E.clamp = WE, E.clone = _6, E.cloneDeep = z6, E.cloneDeepWith = B6, E.cloneWith = N6, E.conformsTo = F6, E.deburr = u0, E.defaultTo = wk, E.divide = Hk, E.endsWith = ZE, E.eq = br, E.escape = jE, E.escapeRegExp = YE, E.every = e6, E.find = n6, E.findIndex = _g, E.findKey = gE, E.findLast = r6, E.findLastIndex = Ng, E.findLastKey = mE, E.floor = $k, E.forEach = Hg, E.forEachRight = $g, E.forIn = vE, E.forInRight = yE, E.forOwn = wE, E.forOwnRight = bE, E.get = dd, E.gt = V6, E.gte = W6, E.has = CE, E.hasIn = fd, E.head = Bg, E.identity = An, E.includes = l6, E.indexOf = rC, E.inRange = HE, E.invoke = OE, E.isArguments = so, E.isArray = Ye, E.isArrayBuffer = H6, E.isArrayLike = Dn, E.isArrayLikeObject = Pt, E.isBoolean = $6, E.isBuffer = Ci, E.isDate = U6, E.isElement = Z6, E.isEmpty = j6, E.isEqual = Y6, E.isEqualWith = q6, E.isError = cd, E.isFinite = G6, E.isFunction = Qr, E.isInteger = Xg, E.isLength = kl, E.isMap = Jg, E.isMatch = K6, E.isMatchWith = X6, E.isNaN = J6, E.isNative = Q6, E.isNil = tE, E.isNull = eE, E.isNumber = Qg, E.isObject = Rt, E.isObjectLike = At, E.isPlainObject = Ns, E.isRegExp = ud, E.isSafeInteger = nE, E.isSet = e0, E.isString = Ol, E.isSymbol = Un, E.isTypedArray = Uo, E.isUndefined = rE, E.isWeakMap = iE, E.isWeakSet = oE, E.join = lC, E.kebabCase = qE, E.last = ar, E.lastIndexOf = cC, E.lowerCase = GE, E.lowerFirst = KE, E.lt = sE, E.lte = aE, E.max = Uk, E.maxBy = Zk, E.mean = jk, E.meanBy = Yk, E.min = qk, E.minBy = Gk, E.stubArray = yd, E.stubFalse = wd, E.stubObject = Pk, E.stubString = _k, E.stubTrue = Nk, E.multiply = Kk, E.nth = uC, E.noConflict = Ok, E.noop = vd, E.now = Sl, E.pad = XE, E.padEnd = JE, E.padStart = QE, E.parseInt = ek, E.random = $E, E.reduce = h6, E.reduceRight = p6, E.repeat = tk, E.replace = nk, E.result = LE, E.round = Xk, E.runInContext = N, E.sample = m6, E.size = w6, E.snakeCase = rk, E.some = b6, E.sortedIndex = vC, E.sortedIndexBy = yC, E.sortedIndexOf = wC, E.sortedLastIndex = bC, E.sortedLastIndexBy = xC, E.sortedLastIndexOf = SC, E.startCase = ok, E.startsWith = sk, E.subtract = Jk, E.sum = Qk, E.sumBy = e8, E.template = ak, E.times = zk, E.toFinite = ei, E.toInteger = Ge, E.toLength = n0, E.toLower = lk, E.toNumber = lr, E.toSafeInteger = lE, E.toString = dt, E.toUpper = ck, E.trim = uk, E.trimEnd = dk, E.trimStart = fk, E.truncate = hk, E.unescape = pk, E.uniqueId = Fk, E.upperCase = gk, E.upperFirst = hd, E.each = Hg, E.eachRight = $g, E.first = Bg, md(E, function() {
        var s = {};
        return Dr(E, function(c, f) {
          mt.call(E.prototype, f) || (s[f] = c);
        }), s;
      }(), { chain: !1 }), E.VERSION = r, nr(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(s) {
        E[s].placeholder = E;
      }), nr(["drop", "take"], function(s, c) {
        et.prototype[s] = function(f) {
          f = f === t ? 1 : $t(Ge(f), 0);
          var y = this.__filtered__ && !c ? new et(this) : this.clone();
          return y.__filtered__ ? y.__takeCount__ = an(f, y.__takeCount__) : y.__views__.push({
            size: an(f, Oe),
            type: s + (y.__dir__ < 0 ? "Right" : "")
          }), y;
        }, et.prototype[s + "Right"] = function(f) {
          return this.reverse()[s](f).reverse();
        };
      }), nr(["filter", "map", "takeWhile"], function(s, c) {
        var f = c + 1, y = f == ee || f == re;
        et.prototype[s] = function(S) {
          var O = this.clone();
          return O.__iteratees__.push({
            iteratee: ze(S, 3),
            type: f
          }), O.__filtered__ = O.__filtered__ || y, O;
        };
      }), nr(["head", "last"], function(s, c) {
        var f = "take" + (c ? "Right" : "");
        et.prototype[s] = function() {
          return this[f](1).value()[0];
        };
      }), nr(["initial", "tail"], function(s, c) {
        var f = "drop" + (c ? "" : "Right");
        et.prototype[s] = function() {
          return this.__filtered__ ? new et(this) : this[f](1);
        };
      }), et.prototype.compact = function() {
        return this.filter(An);
      }, et.prototype.find = function(s) {
        return this.filter(s).head();
      }, et.prototype.findLast = function(s) {
        return this.reverse().find(s);
      }, et.prototype.invokeMap = Xe(function(s, c) {
        return typeof s == "function" ? new et(this) : this.map(function(f) {
          return Ds(f, s, c);
        });
      }), et.prototype.reject = function(s) {
        return this.filter(El(ze(s)));
      }, et.prototype.slice = function(s, c) {
        s = Ge(s);
        var f = this;
        return f.__filtered__ && (s > 0 || c < 0) ? new et(f) : (s < 0 ? f = f.takeRight(-s) : s && (f = f.drop(s)), c !== t && (c = Ge(c), f = c < 0 ? f.dropRight(-c) : f.take(c - s)), f);
      }, et.prototype.takeRightWhile = function(s) {
        return this.reverse().takeWhile(s).reverse();
      }, et.prototype.toArray = function() {
        return this.take(Oe);
      }, Dr(et.prototype, function(s, c) {
        var f = /^(?:filter|find|map|reject)|While$/.test(c), y = /^(?:head|last)$/.test(c), S = E[y ? "take" + (c == "last" ? "Right" : "") : c], O = y || /^find/.test(c);
        S && (E.prototype[c] = function() {
          var I = this.__wrapped__, L = y ? [1] : arguments, B = I instanceof et, X = L[0], J = B || Ye(I), ne = function(Qe) {
            var nt = S.apply(E, gi([Qe], L));
            return y && he ? nt[0] : nt;
          };
          J && f && typeof X == "function" && X.length != 1 && (B = J = !1);
          var he = this.__chain__, Me = !!this.__actions__.length, Ve = O && !he, Ke = B && !Me;
          if (!O && J) {
            I = Ke ? I : new et(this);
            var We = s.apply(I, L);
            return We.__actions__.push({ func: bl, args: [ne], thisArg: t }), new ir(We, he);
          }
          return Ve && Ke ? s.apply(this, L) : (We = this.thru(ne), Ve ? y ? We.value()[0] : We.value() : We);
        });
      }), nr(["pop", "push", "shift", "sort", "splice", "unshift"], function(s) {
        var c = ja[s], f = /^(?:push|sort|unshift)$/.test(s) ? "tap" : "thru", y = /^(?:pop|shift)$/.test(s);
        E.prototype[s] = function() {
          var S = arguments;
          if (y && !this.__chain__) {
            var O = this.value();
            return c.apply(Ye(O) ? O : [], S);
          }
          return this[f](function(I) {
            return c.apply(Ye(I) ? I : [], S);
          });
        };
      }), Dr(et.prototype, function(s, c) {
        var f = E[c];
        if (f) {
          var y = f.name + "";
          mt.call(Fo, y) || (Fo[y] = []), Fo[y].push({ name: c, func: f });
        }
      }), Fo[hl(t, C).name] = [{
        name: "wrapper",
        func: t
      }], et.prototype.clone = pS, et.prototype.reverse = gS, et.prototype.value = mS, E.prototype.at = ZC, E.prototype.chain = jC, E.prototype.commit = YC, E.prototype.next = qC, E.prototype.plant = KC, E.prototype.reverse = XC, E.prototype.toJSON = E.prototype.valueOf = E.prototype.value = JC, E.prototype.first = E.prototype.head, Cs && (E.prototype[Cs] = GC), E;
    }, No = Yx();
    Ji ? ((Ji.exports = No)._ = No, gu._ = No) : Xt._ = No;
  }).call(qo);
})(oc, oc.exports);
var Te = oc.exports, qT = Array.prototype, GT = qT.reverse;
function KT(n) {
  return n == null ? n : GT.call(n);
}
var XT = KT;
const ey = /* @__PURE__ */ iO(XT);
let Rl;
const JT = new Uint8Array(16);
function QT() {
  if (!Rl && (Rl = typeof crypto < "u" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto), !Rl))
    throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
  return Rl(JT);
}
const Qt = [];
for (let n = 0; n < 256; ++n)
  Qt.push((n + 256).toString(16).slice(1));
function eM(n, e = 0) {
  return Qt[n[e + 0]] + Qt[n[e + 1]] + Qt[n[e + 2]] + Qt[n[e + 3]] + "-" + Qt[n[e + 4]] + Qt[n[e + 5]] + "-" + Qt[n[e + 6]] + Qt[n[e + 7]] + "-" + Qt[n[e + 8]] + Qt[n[e + 9]] + "-" + Qt[n[e + 10]] + Qt[n[e + 11]] + Qt[n[e + 12]] + Qt[n[e + 13]] + Qt[n[e + 14]] + Qt[n[e + 15]];
}
const tM = typeof crypto < "u" && crypto.randomUUID && crypto.randomUUID.bind(crypto), z0 = {
  randomUUID: tM
};
function nM(n, e, t) {
  if (z0.randomUUID && !e && !n)
    return z0.randomUUID();
  n = n || {};
  const r = n.random || (n.rng || QT)();
  if (r[6] = r[6] & 15 | 64, r[8] = r[8] & 63 | 128, e) {
    t = t || 0;
    for (let i = 0; i < 16; ++i)
      e[t + i] = r[i];
    return e;
  }
  return eM(r);
}
const ty = ({
  layerId: n,
  clipPath: e,
  image: t,
  color: r,
  gradientBackground: i,
  boxSize: o,
  position: a,
  rotate: l,
  scale: u
}) => {
  const { config: d } = It(di), { actions: h, pageIndex: p, id: g } = gs(), { selectedLayerIds: v } = rn(), { imageEditor: m } = je((M) => ({
    imageEditor: M.imageEditor
  })), [w, b] = Le(null);
  be(() => {
    if (t) {
      const M = new Image();
      M.onload = () => {
        b((k) => k && { ...k, url: M.src });
      }, M.src = t.url;
    }
  }, [t]), be(() => {
    b(!t && !r && !i ? (() => {
      const k = d.frame.defaultImage.width / d.frame.defaultImage.height, D = o.width / o.height, T = k > D ? o.height / u * k : o.width / u, R = k > D ? o.height / u : o.width / u * k;
      return {
        boxSize: {
          width: T,
          height: R
        },
        position: {
          x: -(T - o.width / u) / 2,
          y: -(R - o.height / u) / 2
        },
        rotate: 0,
        url: d.frame.defaultImage.url,
        thumb: d.frame.defaultImage.url
      };
    })() : t);
  }, [
    t,
    r,
    i,
    d.frame.defaultImage.width,
    d.frame.defaultImage.height,
    d.frame.defaultImage.url,
    o.width,
    o.height,
    u
  ]);
  const C = () => {
    t && v.includes(g) && h.openImageEditor({
      boxSize: o,
      position: a,
      rotate: l,
      image: {
        boxSize: {
          width: t.boxSize.width * u,
          height: t.boxSize.height * u
        },
        position: {
          x: t.position.x * u,
          y: t.position.y * u
        },
        rotate: t.rotate || 0,
        url: t.url
      }
    });
  };
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        transformOrigin: "0 0"
      },
      style: {
        width: o.width / u,
        height: o.height / u,
        transform: `scale(${u})`,
        visibility: m && m.pageIndex === p && m.layerId === g ? "hidden" : void 0
      },
      onDoubleClick: C,
      children: /* @__PURE__ */ x(
        i8,
        {
          boxSize: o,
          clipPath: e,
          color: r,
          gradientBackground: i,
          image: w,
          layerId: n,
          position: a,
          rotate: l,
          scale: u
        }
      )
    }
  );
};
ty.info = {
  name: "Frame",
  type: "Frame"
};
const ny = ({
  boxSize: n,
  scale: e,
  children: t
}) => /* @__PURE__ */ x(
  "div",
  {
    css: {
      transformOrigin: "0 0"
    },
    style: {
      width: n.width / e,
      height: n.height / e,
      transform: `scale(${e})`
    },
    children: t
  }
);
ny.info = {
  name: "Group",
  type: "Group"
};
const ry = ({
  layerId: n,
  image: e,
  boxSize: t,
  position: r,
  rotate: i
}) => {
  const { actions: o, pageIndex: a, id: l } = gs(), { selectedLayerIds: u } = rn(), { imageEditor: d } = je((g) => ({
    imageEditor: g.imageEditor
  })), [h, p] = Le({
    ...e,
    url: e.thumb
  });
  return be(() => {
    const g = new Image();
    g.onload = () => {
      p((v) => ({ ...v, url: e.url }));
    }, g.src = e.url;
  }, [e, p]), be(() => {
    p(e);
  }, [e]), /* @__PURE__ */ x(
    "div",
    {
      css: {
        pointerEvents: "auto",
        visibility: d && d.pageIndex === a && d.layerId === l ? "hidden" : void 0
      },
      onDoubleClick: () => u.includes(l) && o.openImageEditor({ position: r, rotate: i, boxSize: t, image: e }),
      children: /* @__PURE__ */ x(
        o8,
        {
          boxSize: t,
          image: h,
          layerId: n,
          position: r,
          rotate: i
        }
      )
    }
  );
};
ry.info = {
  name: "Image",
  type: "Image"
};
const iy = ({
  layerId: n,
  boxSize: e,
  color: t,
  scale: r = 1,
  rotate: i,
  position: o,
  style: a,
  ...l
}) => /* @__PURE__ */ W(J1, { children: [
  e.height < 32 && /* @__PURE__ */ x(
    "div",
    {
      css: {
        top: -(32 - e.height) / 2,
        height: 32,
        width: e.width,
        position: "absolute"
      }
    }
  ),
  /* @__PURE__ */ x(
    s8,
    {
      boxSize: e,
      color: t,
      layerId: n,
      position: o,
      rotate: i,
      scale: r,
      style: a,
      ...l
    }
  )
] });
iy.info = {
  name: "Line",
  type: "Line"
};
const oy = ({
  layerId: n,
  boxSize: e,
  children: t,
  color: r,
  gradientBackground: i,
  image: o,
  video: a,
  position: l,
  rotate: u,
  scale: d
}) => {
  const { actions: h } = gs();
  return /* @__PURE__ */ W(Tt, { children: [
    /* @__PURE__ */ x(
      a8,
      {
        boxSize: e,
        color: r,
        gradientBackground: i,
        image: o,
        layerId: n,
        position: l,
        rotate: u,
        scale: d,
        video: a,
        onDoubleClick: () => (o || a) && h.openImageEditor({ boxSize: e, position: l, rotate: u, image: o, video: a })
      }
    ),
    t
  ] });
};
oy.info = {
  name: "Main",
  type: "Root"
};
const sy = ({
  layerId: n,
  boxSize: e,
  shape: t,
  color: r,
  gradientBackground: i,
  roundedCorners: o = 0,
  scale: a = 1,
  rotate: l,
  position: u,
  border: d
}) => /* @__PURE__ */ x(
  "div",
  {
    css: {
      transformOrigin: "0 0"
    },
    style: {
      width: e.width / (a || 1),
      height: e.height / (a || 1),
      transform: `scale(${a || 1})`
    },
    children: /* @__PURE__ */ x(
      l8,
      {
        border: d,
        boxSize: e,
        color: r,
        gradientBackground: i,
        layerId: n,
        position: u,
        rotate: l,
        roundedCorners: o,
        scale: a,
        shape: t
      }
    )
  }
);
sy.info = {
  name: "Shape",
  type: "Shape"
};
const ay = ({ boxSize: n, ...e }) => /* @__PURE__ */ x(
  "div",
  {
    css: {
      transformOrigin: "0 0"
    },
    style: {
      width: n.width,
      height: n.height
    },
    children: /* @__PURE__ */ x(c8, { boxSize: n, ...e })
  }
);
ay.info = {
  name: "Svg",
  type: "Svg"
};
function en(n) {
  this.content = n;
}
en.prototype = {
  constructor: en,
  find: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      if (this.content[e] === n)
        return e;
    return -1;
  },
  // :: (string) → ?any
  // Retrieve the value stored under `key`, or return undefined when
  // no such key exists.
  get: function(n) {
    var e = this.find(n);
    return e == -1 ? void 0 : this.content[e + 1];
  },
  // :: (string, any, ?string) → OrderedMap
  // Create a new map by replacing the value of `key` with a new
  // value, or adding a binding to the end of the map. If `newKey` is
  // given, the key of the binding will be replaced with that key.
  update: function(n, e, t) {
    var r = t && t != n ? this.remove(t) : this, i = r.find(n), o = r.content.slice();
    return i == -1 ? o.push(t || n, e) : (o[i + 1] = e, t && (o[i] = t)), new en(o);
  },
  // :: (string) → OrderedMap
  // Return a map with the given key removed, if it existed.
  remove: function(n) {
    var e = this.find(n);
    if (e == -1)
      return this;
    var t = this.content.slice();
    return t.splice(e, 2), new en(t);
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the start of the map.
  addToStart: function(n, e) {
    return new en([n, e].concat(this.remove(n).content));
  },
  // :: (string, any) → OrderedMap
  // Add a new key to the end of the map.
  addToEnd: function(n, e) {
    var t = this.remove(n).content.slice();
    return t.push(n, e), new en(t);
  },
  // :: (string, string, any) → OrderedMap
  // Add a key after the given key. If `place` is not found, the new
  // key is added to the end.
  addBefore: function(n, e, t) {
    var r = this.remove(e), i = r.content.slice(), o = r.find(n);
    return i.splice(o == -1 ? i.length : o, 0, e, t), new en(i);
  },
  // :: ((key: string, value: any))
  // Call the given function for each key/value pair in the map, in
  // order.
  forEach: function(n) {
    for (var e = 0; e < this.content.length; e += 2)
      n(this.content[e], this.content[e + 1]);
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by prepending the keys in this map that don't
  // appear in `map` before the keys in `map`.
  prepend: function(n) {
    return n = en.from(n), n.size ? new en(n.content.concat(this.subtract(n).content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a new map by appending the keys in this map that don't
  // appear in `map` after the keys in `map`.
  append: function(n) {
    return n = en.from(n), n.size ? new en(this.subtract(n).content.concat(n.content)) : this;
  },
  // :: (union<Object, OrderedMap>) → OrderedMap
  // Create a map containing all the keys in this map that don't
  // appear in `map`.
  subtract: function(n) {
    var e = this;
    n = en.from(n);
    for (var t = 0; t < n.content.length; t += 2)
      e = e.remove(n.content[t]);
    return e;
  },
  // :: () → Object
  // Turn ordered map into a plain object.
  toObject: function() {
    var n = {};
    return this.forEach(function(e, t) {
      n[e] = t;
    }), n;
  },
  // :: number
  // The amount of keys in this map.
  get size() {
    return this.content.length >> 1;
  }
};
en.from = function(n) {
  if (n instanceof en)
    return n;
  var e = [];
  if (n)
    for (var t in n)
      e.push(t, n[t]);
  return new en(e);
};
function ly(n, e, t) {
  for (let r = 0; ; r++) {
    if (r == n.childCount || r == e.childCount)
      return n.childCount == e.childCount ? null : t;
    let i = n.child(r), o = e.child(r);
    if (i == o) {
      t += i.nodeSize;
      continue;
    }
    if (!i.sameMarkup(o))
      return t;
    if (i.isText && i.text != o.text) {
      for (let a = 0; i.text[a] == o.text[a]; a++)
        t++;
      return t;
    }
    if (i.content.size || o.content.size) {
      let a = ly(i.content, o.content, t + 1);
      if (a != null)
        return a;
    }
    t += i.nodeSize;
  }
}
function cy(n, e, t, r) {
  for (let i = n.childCount, o = e.childCount; ; ) {
    if (i == 0 || o == 0)
      return i == o ? null : { a: t, b: r };
    let a = n.child(--i), l = e.child(--o), u = a.nodeSize;
    if (a == l) {
      t -= u, r -= u;
      continue;
    }
    if (!a.sameMarkup(l))
      return { a: t, b: r };
    if (a.isText && a.text != l.text) {
      let d = 0, h = Math.min(a.text.length, l.text.length);
      for (; d < h && a.text[a.text.length - d - 1] == l.text[l.text.length - d - 1]; )
        d++, t--, r--;
      return { a: t, b: r };
    }
    if (a.content.size || l.content.size) {
      let d = cy(a.content, l.content, t - 1, r - 1);
      if (d)
        return d;
    }
    t -= u, r -= u;
  }
}
class ue {
  /**
  @internal
  */
  constructor(e, t) {
    if (this.content = e, this.size = t || 0, t == null)
      for (let r = 0; r < e.length; r++)
        this.size += e[r].nodeSize;
  }
  /**
  Invoke a callback for all descendant nodes between the given two
  positions (relative to start of this fragment). Doesn't descend
  into a node when the callback returns `false`.
  */
  nodesBetween(e, t, r, i = 0, o) {
    for (let a = 0, l = 0; l < t; a++) {
      let u = this.content[a], d = l + u.nodeSize;
      if (d > e && r(u, i + l, o || null, a) !== !1 && u.content.size) {
        let h = l + 1;
        u.nodesBetween(Math.max(0, e - h), Math.min(u.content.size, t - h), r, i + h);
      }
      l = d;
    }
  }
  /**
  Call the given callback for every descendant node. `pos` will be
  relative to the start of the fragment. The callback may return
  `false` to prevent traversal of a given node's children.
  */
  descendants(e) {
    this.nodesBetween(0, this.size, e);
  }
  /**
  Extract the text between `from` and `to`. See the same method on
  [`Node`](https://prosemirror.net/docs/ref/#model.Node.textBetween).
  */
  textBetween(e, t, r, i) {
    let o = "", a = !0;
    return this.nodesBetween(e, t, (l, u) => {
      l.isText ? (o += l.text.slice(Math.max(e, u) - u, t - u), a = !r) : l.isLeaf ? (i ? o += typeof i == "function" ? i(l) : i : l.type.spec.leafText && (o += l.type.spec.leafText(l)), a = !r) : !a && l.isBlock && (o += r, a = !0);
    }, 0), o;
  }
  /**
  Create a new fragment containing the combined content of this
  fragment and the other.
  */
  append(e) {
    if (!e.size)
      return this;
    if (!this.size)
      return e;
    let t = this.lastChild, r = e.firstChild, i = this.content.slice(), o = 0;
    for (t.isText && t.sameMarkup(r) && (i[i.length - 1] = t.withText(t.text + r.text), o = 1); o < e.content.length; o++)
      i.push(e.content[o]);
    return new ue(i, this.size + e.size);
  }
  /**
  Cut out the sub-fragment between the two given positions.
  */
  cut(e, t = this.size) {
    if (e == 0 && t == this.size)
      return this;
    let r = [], i = 0;
    if (t > e)
      for (let o = 0, a = 0; a < t; o++) {
        let l = this.content[o], u = a + l.nodeSize;
        u > e && ((a < e || u > t) && (l.isText ? l = l.cut(Math.max(0, e - a), Math.min(l.text.length, t - a)) : l = l.cut(Math.max(0, e - a - 1), Math.min(l.content.size, t - a - 1))), r.push(l), i += l.nodeSize), a = u;
      }
    return new ue(r, i);
  }
  /**
  @internal
  */
  cutByIndex(e, t) {
    return e == t ? ue.empty : e == 0 && t == this.content.length ? this : new ue(this.content.slice(e, t));
  }
  /**
  Create a new fragment in which the node at the given index is
  replaced by the given node.
  */
  replaceChild(e, t) {
    let r = this.content[e];
    if (r == t)
      return this;
    let i = this.content.slice(), o = this.size + t.nodeSize - r.nodeSize;
    return i[e] = t, new ue(i, o);
  }
  /**
  Create a new fragment by prepending the given node to this
  fragment.
  */
  addToStart(e) {
    return new ue([e].concat(this.content), this.size + e.nodeSize);
  }
  /**
  Create a new fragment by appending the given node to this
  fragment.
  */
  addToEnd(e) {
    return new ue(this.content.concat(e), this.size + e.nodeSize);
  }
  /**
  Compare this fragment to another one.
  */
  eq(e) {
    if (this.content.length != e.content.length)
      return !1;
    for (let t = 0; t < this.content.length; t++)
      if (!this.content[t].eq(e.content[t]))
        return !1;
    return !0;
  }
  /**
  The first child of the fragment, or `null` if it is empty.
  */
  get firstChild() {
    return this.content.length ? this.content[0] : null;
  }
  /**
  The last child of the fragment, or `null` if it is empty.
  */
  get lastChild() {
    return this.content.length ? this.content[this.content.length - 1] : null;
  }
  /**
  The number of child nodes in this fragment.
  */
  get childCount() {
    return this.content.length;
  }
  /**
  Get the child node at the given index. Raise an error when the
  index is out of range.
  */
  child(e) {
    let t = this.content[e];
    if (!t)
      throw new RangeError("Index " + e + " out of range for " + this);
    return t;
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content[e] || null;
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    for (let t = 0, r = 0; t < this.content.length; t++) {
      let i = this.content[t];
      e(i, r, t), r += i.nodeSize;
    }
  }
  /**
  Find the first position at which this fragment and another
  fragment differ, or `null` if they are the same.
  */
  findDiffStart(e, t = 0) {
    return ly(this, e, t);
  }
  /**
  Find the first position, searching from the end, at which this
  fragment and the given fragment differ, or `null` if they are
  the same. Since this position will not be the same in both
  nodes, an object with two separate positions is returned.
  */
  findDiffEnd(e, t = this.size, r = e.size) {
    return cy(this, e, t, r);
  }
  /**
  Find the index and inner offset corresponding to a given relative
  position in this fragment. The result object will be reused
  (overwritten) the next time the function is called. (Not public.)
  */
  findIndex(e, t = -1) {
    if (e == 0)
      return Dl(0, e);
    if (e == this.size)
      return Dl(this.content.length, e);
    if (e > this.size || e < 0)
      throw new RangeError(`Position ${e} outside of fragment (${this})`);
    for (let r = 0, i = 0; ; r++) {
      let o = this.child(r), a = i + o.nodeSize;
      if (a >= e)
        return a == e || t > 0 ? Dl(r + 1, a) : Dl(r, i);
      i = a;
    }
  }
  /**
  Return a debugging string that describes this fragment.
  */
  toString() {
    return "<" + this.toStringInner() + ">";
  }
  /**
  @internal
  */
  toStringInner() {
    return this.content.join(", ");
  }
  /**
  Create a JSON-serializeable representation of this fragment.
  */
  toJSON() {
    return this.content.length ? this.content.map((e) => e.toJSON()) : null;
  }
  /**
  Deserialize a fragment from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return ue.empty;
    if (!Array.isArray(t))
      throw new RangeError("Invalid input for Fragment.fromJSON");
    return new ue(t.map(e.nodeFromJSON));
  }
  /**
  Build a fragment from an array of nodes. Ensures that adjacent
  text nodes with the same marks are joined together.
  */
  static fromArray(e) {
    if (!e.length)
      return ue.empty;
    let t, r = 0;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      r += o.nodeSize, i && o.isText && e[i - 1].sameMarkup(o) ? (t || (t = e.slice(0, i)), t[t.length - 1] = o.withText(t[t.length - 1].text + o.text)) : t && t.push(o);
    }
    return new ue(t || e, r);
  }
  /**
  Create a fragment from something that can be interpreted as a
  set of nodes. For `null`, it returns the empty fragment. For a
  fragment, the fragment itself. For a node or array of nodes, a
  fragment containing those nodes.
  */
  static from(e) {
    if (!e)
      return ue.empty;
    if (e instanceof ue)
      return e;
    if (Array.isArray(e))
      return this.fromArray(e);
    if (e.attrs)
      return new ue([e], e.nodeSize);
    throw new RangeError("Can not convert " + e + " to a Fragment" + (e.nodesBetween ? " (looks like multiple versions of prosemirror-model were loaded)" : ""));
  }
}
ue.empty = new ue([], 0);
const xd = { index: 0, offset: 0 };
function Dl(n, e) {
  return xd.index = n, xd.offset = e, xd;
}
function sc(n, e) {
  if (n === e)
    return !0;
  if (!(n && typeof n == "object") || !(e && typeof e == "object"))
    return !1;
  let t = Array.isArray(n);
  if (Array.isArray(e) != t)
    return !1;
  if (t) {
    if (n.length != e.length)
      return !1;
    for (let r = 0; r < n.length; r++)
      if (!sc(n[r], e[r]))
        return !1;
  } else {
    for (let r in n)
      if (!(r in e) || !sc(n[r], e[r]))
        return !1;
    for (let r in e)
      if (!(r in n))
        return !1;
  }
  return !0;
}
class ct {
  /**
  @internal
  */
  constructor(e, t) {
    this.type = e, this.attrs = t;
  }
  /**
  Given a set of marks, create a new set which contains this one as
  well, in the right position. If this mark is already in the set,
  the set itself is returned. If any marks that are set to be
  [exclusive](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) with this mark are present,
  those are replaced by this one.
  */
  addToSet(e) {
    let t, r = !1;
    for (let i = 0; i < e.length; i++) {
      let o = e[i];
      if (this.eq(o))
        return e;
      if (this.type.excludes(o.type))
        t || (t = e.slice(0, i));
      else {
        if (o.type.excludes(this.type))
          return e;
        !r && o.type.rank > this.type.rank && (t || (t = e.slice(0, i)), t.push(this), r = !0), t && t.push(o);
      }
    }
    return t || (t = e.slice()), r || t.push(this), t;
  }
  /**
  Remove this mark from the given set, returning a new set. If this
  mark is not in the set, the set itself is returned.
  */
  removeFromSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return e.slice(0, t).concat(e.slice(t + 1));
    return e;
  }
  /**
  Test whether this mark is in the given set of marks.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (this.eq(e[t]))
        return !0;
    return !1;
  }
  /**
  Test whether this mark has the same type and attributes as
  another mark.
  */
  eq(e) {
    return this == e || this.type == e.type && sc(this.attrs, e.attrs);
  }
  /**
  Convert this mark to a JSON-serializeable representation.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return e;
  }
  /**
  Deserialize a mark from JSON.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Mark.fromJSON");
    let r = e.marks[t.type];
    if (!r)
      throw new RangeError(`There is no mark type ${t.type} in this schema`);
    return r.create(t.attrs);
  }
  /**
  Test whether two sets of marks are identical.
  */
  static sameSet(e, t) {
    if (e == t)
      return !0;
    if (e.length != t.length)
      return !1;
    for (let r = 0; r < e.length; r++)
      if (!e[r].eq(t[r]))
        return !1;
    return !0;
  }
  /**
  Create a properly sorted mark set from null, a single mark, or an
  unsorted array of marks.
  */
  static setFrom(e) {
    if (!e || Array.isArray(e) && e.length == 0)
      return ct.none;
    if (e instanceof ct)
      return [e];
    let t = e.slice();
    return t.sort((r, i) => r.type.rank - i.type.rank), t;
  }
}
ct.none = [];
class ac extends Error {
}
class ke {
  /**
  Create a slice. When specifying a non-zero open depth, you must
  make sure that there are nodes of at least that depth at the
  appropriate side of the fragment—i.e. if the fragment is an
  empty paragraph node, `openStart` and `openEnd` can't be greater
  than 1.
  
  It is not necessary for the content of open nodes to conform to
  the schema's content constraints, though it should be a valid
  start/end/middle for such a node, depending on which sides are
  open.
  */
  constructor(e, t, r) {
    this.content = e, this.openStart = t, this.openEnd = r;
  }
  /**
  The size this slice would add when inserted into a document.
  */
  get size() {
    return this.content.size - this.openStart - this.openEnd;
  }
  /**
  @internal
  */
  insertAt(e, t) {
    let r = dy(this.content, e + this.openStart, t);
    return r && new ke(r, this.openStart, this.openEnd);
  }
  /**
  @internal
  */
  removeBetween(e, t) {
    return new ke(uy(this.content, e + this.openStart, t + this.openStart), this.openStart, this.openEnd);
  }
  /**
  Tests whether this slice is equal to another slice.
  */
  eq(e) {
    return this.content.eq(e.content) && this.openStart == e.openStart && this.openEnd == e.openEnd;
  }
  /**
  @internal
  */
  toString() {
    return this.content + "(" + this.openStart + "," + this.openEnd + ")";
  }
  /**
  Convert a slice to a JSON-serializable representation.
  */
  toJSON() {
    if (!this.content.size)
      return null;
    let e = { content: this.content.toJSON() };
    return this.openStart > 0 && (e.openStart = this.openStart), this.openEnd > 0 && (e.openEnd = this.openEnd), e;
  }
  /**
  Deserialize a slice from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      return ke.empty;
    let r = t.openStart || 0, i = t.openEnd || 0;
    if (typeof r != "number" || typeof i != "number")
      throw new RangeError("Invalid input for Slice.fromJSON");
    return new ke(ue.fromJSON(e, t.content), r, i);
  }
  /**
  Create a slice from a fragment by taking the maximum possible
  open value on both side of the fragment.
  */
  static maxOpen(e, t = !0) {
    let r = 0, i = 0;
    for (let o = e.firstChild; o && !o.isLeaf && (t || !o.type.spec.isolating); o = o.firstChild)
      r++;
    for (let o = e.lastChild; o && !o.isLeaf && (t || !o.type.spec.isolating); o = o.lastChild)
      i++;
    return new ke(e, r, i);
  }
}
ke.empty = new ke(ue.empty, 0, 0);
function uy(n, e, t) {
  let { index: r, offset: i } = n.findIndex(e), o = n.maybeChild(r), { index: a, offset: l } = n.findIndex(t);
  if (i == e || o.isText) {
    if (l != t && !n.child(a).isText)
      throw new RangeError("Removing non-flat range");
    return n.cut(0, e).append(n.cut(t));
  }
  if (r != a)
    throw new RangeError("Removing non-flat range");
  return n.replaceChild(r, o.copy(uy(o.content, e - i - 1, t - i - 1)));
}
function dy(n, e, t, r) {
  let { index: i, offset: o } = n.findIndex(e), a = n.maybeChild(i);
  if (o == e || a.isText)
    return r && !r.canReplace(i, i, t) ? null : n.cut(0, e).append(t).append(n.cut(e));
  let l = dy(a.content, e - o - 1, t);
  return l && n.replaceChild(i, a.copy(l));
}
function rM(n, e, t) {
  if (t.openStart > n.depth)
    throw new ac("Inserted content deeper than insertion position");
  if (n.depth - t.openStart != e.depth - t.openEnd)
    throw new ac("Inconsistent open depths");
  return fy(n, e, t, 0);
}
function fy(n, e, t, r) {
  let i = n.index(r), o = n.node(r);
  if (i == e.index(r) && r < n.depth - t.openStart) {
    let a = fy(n, e, t, r + 1);
    return o.copy(o.content.replaceChild(i, a));
  } else if (t.content.size)
    if (!t.openStart && !t.openEnd && n.depth == r && e.depth == r) {
      let a = n.parent, l = a.content;
      return mo(a, l.cut(0, n.parentOffset).append(t.content).append(l.cut(e.parentOffset)));
    } else {
      let { start: a, end: l } = iM(t, n);
      return mo(o, py(n, a, l, e, r));
    }
  else
    return mo(o, lc(n, e, r));
}
function hy(n, e) {
  if (!e.type.compatibleContent(n.type))
    throw new ac("Cannot join " + e.type.name + " onto " + n.type.name);
}
function Ef(n, e, t) {
  let r = n.node(t);
  return hy(r, e.node(t)), r;
}
function go(n, e) {
  let t = e.length - 1;
  t >= 0 && n.isText && n.sameMarkup(e[t]) ? e[t] = n.withText(e[t].text + n.text) : e.push(n);
}
function Ks(n, e, t, r) {
  let i = (e || n).node(t), o = 0, a = e ? e.index(t) : i.childCount;
  n && (o = n.index(t), n.depth > t ? o++ : n.textOffset && (go(n.nodeAfter, r), o++));
  for (let l = o; l < a; l++)
    go(i.child(l), r);
  e && e.depth == t && e.textOffset && go(e.nodeBefore, r);
}
function mo(n, e) {
  return n.type.checkContent(e), n.copy(e);
}
function py(n, e, t, r, i) {
  let o = n.depth > i && Ef(n, e, i + 1), a = r.depth > i && Ef(t, r, i + 1), l = [];
  return Ks(null, n, i, l), o && a && e.index(i) == t.index(i) ? (hy(o, a), go(mo(o, py(n, e, t, r, i + 1)), l)) : (o && go(mo(o, lc(n, e, i + 1)), l), Ks(e, t, i, l), a && go(mo(a, lc(t, r, i + 1)), l)), Ks(r, null, i, l), new ue(l);
}
function lc(n, e, t) {
  let r = [];
  if (Ks(null, n, t, r), n.depth > t) {
    let i = Ef(n, e, t + 1);
    go(mo(i, lc(n, e, t + 1)), r);
  }
  return Ks(e, null, t, r), new ue(r);
}
function iM(n, e) {
  let t = e.depth - n.openStart, i = e.node(t).copy(n.content);
  for (let o = t - 1; o >= 0; o--)
    i = e.node(o).copy(ue.from(i));
  return {
    start: i.resolveNoCache(n.openStart + t),
    end: i.resolveNoCache(i.content.size - n.openEnd - t)
  };
}
class da {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.path = t, this.parentOffset = r, this.depth = t.length / 3 - 1;
  }
  /**
  @internal
  */
  resolveDepth(e) {
    return e == null ? this.depth : e < 0 ? this.depth + e : e;
  }
  /**
  The parent node that the position points into. Note that even if
  a position points into a text node, that node is not considered
  the parent—text nodes are ‘flat’ in this model, and have no content.
  */
  get parent() {
    return this.node(this.depth);
  }
  /**
  The root node in which the position was resolved.
  */
  get doc() {
    return this.node(0);
  }
  /**
  The ancestor node at the given level. `p.node(p.depth)` is the
  same as `p.parent`.
  */
  node(e) {
    return this.path[this.resolveDepth(e) * 3];
  }
  /**
  The index into the ancestor at the given level. If this points
  at the 3rd node in the 2nd paragraph on the top level, for
  example, `p.index(0)` is 1 and `p.index(1)` is 2.
  */
  index(e) {
    return this.path[this.resolveDepth(e) * 3 + 1];
  }
  /**
  The index pointing after this position into the ancestor at the
  given level.
  */
  indexAfter(e) {
    return e = this.resolveDepth(e), this.index(e) + (e == this.depth && !this.textOffset ? 0 : 1);
  }
  /**
  The (absolute) position at the start of the node at the given
  level.
  */
  start(e) {
    return e = this.resolveDepth(e), e == 0 ? 0 : this.path[e * 3 - 1] + 1;
  }
  /**
  The (absolute) position at the end of the node at the given
  level.
  */
  end(e) {
    return e = this.resolveDepth(e), this.start(e) + this.node(e).content.size;
  }
  /**
  The (absolute) position directly before the wrapping node at the
  given level, or, when `depth` is `this.depth + 1`, the original
  position.
  */
  before(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position before the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1];
  }
  /**
  The (absolute) position directly after the wrapping node at the
  given level, or the original position when `depth` is `this.depth + 1`.
  */
  after(e) {
    if (e = this.resolveDepth(e), !e)
      throw new RangeError("There is no position after the top-level node");
    return e == this.depth + 1 ? this.pos : this.path[e * 3 - 1] + this.path[e * 3].nodeSize;
  }
  /**
  When this position points into a text node, this returns the
  distance between the position and the start of the text node.
  Will be zero for positions that point between nodes.
  */
  get textOffset() {
    return this.pos - this.path[this.path.length - 1];
  }
  /**
  Get the node directly after the position, if any. If the position
  points into a text node, only the part of that node after the
  position is returned.
  */
  get nodeAfter() {
    let e = this.parent, t = this.index(this.depth);
    if (t == e.childCount)
      return null;
    let r = this.pos - this.path[this.path.length - 1], i = e.child(t);
    return r ? e.child(t).cut(r) : i;
  }
  /**
  Get the node directly before the position, if any. If the
  position points into a text node, only the part of that node
  before the position is returned.
  */
  get nodeBefore() {
    let e = this.index(this.depth), t = this.pos - this.path[this.path.length - 1];
    return t ? this.parent.child(e).cut(0, t) : e == 0 ? null : this.parent.child(e - 1);
  }
  /**
  Get the position at the given index in the parent node at the
  given depth (which defaults to `this.depth`).
  */
  posAtIndex(e, t) {
    t = this.resolveDepth(t);
    let r = this.path[t * 3], i = t == 0 ? 0 : this.path[t * 3 - 1] + 1;
    for (let o = 0; o < e; o++)
      i += r.child(o).nodeSize;
    return i;
  }
  /**
  Get the marks at this position, factoring in the surrounding
  marks' [`inclusive`](https://prosemirror.net/docs/ref/#model.MarkSpec.inclusive) property. If the
  position is at the start of a non-empty node, the marks of the
  node after it (if any) are returned.
  */
  marks() {
    let e = this.parent, t = this.index();
    if (e.content.size == 0)
      return ct.none;
    if (this.textOffset)
      return e.child(t).marks;
    let r = e.maybeChild(t - 1), i = e.maybeChild(t);
    if (!r) {
      let l = r;
      r = i, i = l;
    }
    let o = r.marks;
    for (var a = 0; a < o.length; a++)
      o[a].type.spec.inclusive === !1 && (!i || !o[a].isInSet(i.marks)) && (o = o[a--].removeFromSet(o));
    return o;
  }
  /**
  Get the marks after the current position, if any, except those
  that are non-inclusive and not present at position `$end`. This
  is mostly useful for getting the set of marks to preserve after a
  deletion. Will return `null` if this position is at the end of
  its parent node or its parent node isn't a textblock (in which
  case no marks should be preserved).
  */
  marksAcross(e) {
    let t = this.parent.maybeChild(this.index());
    if (!t || !t.isInline)
      return null;
    let r = t.marks, i = e.parent.maybeChild(e.index());
    for (var o = 0; o < r.length; o++)
      r[o].type.spec.inclusive === !1 && (!i || !r[o].isInSet(i.marks)) && (r = r[o--].removeFromSet(r));
    return r;
  }
  /**
  The depth up to which this position and the given (non-resolved)
  position share the same parent nodes.
  */
  sharedDepth(e) {
    for (let t = this.depth; t > 0; t--)
      if (this.start(t) <= e && this.end(t) >= e)
        return t;
    return 0;
  }
  /**
  Returns a range based on the place where this position and the
  given position diverge around block content. If both point into
  the same textblock, for example, a range around that textblock
  will be returned. If they point into different blocks, the range
  around those blocks in their shared ancestor is returned. You can
  pass in an optional predicate that will be called with a parent
  node to see if a range into that parent is acceptable.
  */
  blockRange(e = this, t) {
    if (e.pos < this.pos)
      return e.blockRange(this);
    for (let r = this.depth - (this.parent.inlineContent || this.pos == e.pos ? 1 : 0); r >= 0; r--)
      if (e.pos <= this.end(r) && (!t || t(this.node(r))))
        return new sM(this, e, r);
    return null;
  }
  /**
  Query whether the given position shares the same parent node.
  */
  sameParent(e) {
    return this.pos - this.parentOffset == e.pos - e.parentOffset;
  }
  /**
  Return the greater of this and the given position.
  */
  max(e) {
    return e.pos > this.pos ? e : this;
  }
  /**
  Return the smaller of this and the given position.
  */
  min(e) {
    return e.pos < this.pos ? e : this;
  }
  /**
  @internal
  */
  toString() {
    let e = "";
    for (let t = 1; t <= this.depth; t++)
      e += (e ? "/" : "") + this.node(t).type.name + "_" + this.index(t - 1);
    return e + ":" + this.parentOffset;
  }
  /**
  @internal
  */
  static resolve(e, t) {
    if (!(t >= 0 && t <= e.content.size))
      throw new RangeError("Position " + t + " out of range");
    let r = [], i = 0, o = t;
    for (let a = e; ; ) {
      let { index: l, offset: u } = a.content.findIndex(o), d = o - u;
      if (r.push(a, l, i + u), !d || (a = a.child(l), a.isText))
        break;
      o = d - 1, i += u + 1;
    }
    return new da(t, r, o);
  }
  /**
  @internal
  */
  static resolveCached(e, t) {
    for (let i = 0; i < Sd.length; i++) {
      let o = Sd[i];
      if (o.pos == t && o.doc == e)
        return o;
    }
    let r = Sd[Cd] = da.resolve(e, t);
    return Cd = (Cd + 1) % oM, r;
  }
}
let Sd = [], Cd = 0, oM = 12;
class sM {
  /**
  Construct a node range. `$from` and `$to` should point into the
  same node until at least the given `depth`, since a node range
  denotes an adjacent set of nodes in a single parent node.
  */
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.depth = r;
  }
  /**
  The position at the start of the range.
  */
  get start() {
    return this.$from.before(this.depth + 1);
  }
  /**
  The position at the end of the range.
  */
  get end() {
    return this.$to.after(this.depth + 1);
  }
  /**
  The parent node that the range points into.
  */
  get parent() {
    return this.$from.node(this.depth);
  }
  /**
  The start index of the range in the parent node.
  */
  get startIndex() {
    return this.$from.index(this.depth);
  }
  /**
  The end index of the range in the parent node.
  */
  get endIndex() {
    return this.$to.indexAfter(this.depth);
  }
}
const aM = /* @__PURE__ */ Object.create(null);
class Wr {
  /**
  @internal
  */
  constructor(e, t, r, i = ct.none) {
    this.type = e, this.attrs = t, this.marks = i, this.content = r || ue.empty;
  }
  /**
  The size of this node, as defined by the integer-based [indexing
  scheme](/docs/guide/#doc.indexing). For text nodes, this is the
  amount of characters. For other leaf nodes, it is one. For
  non-leaf nodes, it is the size of the content plus two (the
  start and end token).
  */
  get nodeSize() {
    return this.isLeaf ? 1 : 2 + this.content.size;
  }
  /**
  The number of children that the node has.
  */
  get childCount() {
    return this.content.childCount;
  }
  /**
  Get the child node at the given index. Raises an error when the
  index is out of range.
  */
  child(e) {
    return this.content.child(e);
  }
  /**
  Get the child node at the given index, if it exists.
  */
  maybeChild(e) {
    return this.content.maybeChild(e);
  }
  /**
  Call `f` for every child node, passing the node, its offset
  into this parent node, and its index.
  */
  forEach(e) {
    this.content.forEach(e);
  }
  /**
  Invoke a callback for all descendant nodes recursively between
  the given two positions that are relative to start of this
  node's content. The callback is invoked with the node, its
  position relative to the original node (method receiver),
  its parent node, and its child index. When the callback returns
  false for a given node, that node's children will not be
  recursed over. The last parameter can be used to specify a
  starting position to count from.
  */
  nodesBetween(e, t, r, i = 0) {
    this.content.nodesBetween(e, t, r, i, this);
  }
  /**
  Call the given callback for every descendant node. Doesn't
  descend into a node when the callback returns `false`.
  */
  descendants(e) {
    this.nodesBetween(0, this.content.size, e);
  }
  /**
  Concatenates all the text nodes found in this fragment and its
  children.
  */
  get textContent() {
    return this.isLeaf && this.type.spec.leafText ? this.type.spec.leafText(this) : this.textBetween(0, this.content.size, "");
  }
  /**
  Get all text between positions `from` and `to`. When
  `blockSeparator` is given, it will be inserted to separate text
  from different block nodes. If `leafText` is given, it'll be
  inserted for every non-text leaf node encountered, otherwise
  [`leafText`](https://prosemirror.net/docs/ref/#model.NodeSpec^leafText) will be used.
  */
  textBetween(e, t, r, i) {
    return this.content.textBetween(e, t, r, i);
  }
  /**
  Returns this node's first child, or `null` if there are no
  children.
  */
  get firstChild() {
    return this.content.firstChild;
  }
  /**
  Returns this node's last child, or `null` if there are no
  children.
  */
  get lastChild() {
    return this.content.lastChild;
  }
  /**
  Test whether two nodes represent the same piece of document.
  */
  eq(e) {
    return this == e || this.sameMarkup(e) && this.content.eq(e.content);
  }
  /**
  Compare the markup (type, attributes, and marks) of this node to
  those of another. Returns `true` if both have the same markup.
  */
  sameMarkup(e) {
    return this.hasMarkup(e.type, e.attrs, e.marks);
  }
  /**
  Check whether this node's markup correspond to the given type,
  attributes, and marks.
  */
  hasMarkup(e, t, r) {
    return this.type == e && sc(this.attrs, t || e.defaultAttrs || aM) && ct.sameSet(this.marks, r || ct.none);
  }
  /**
  Create a new node with the same markup as this node, containing
  the given content (or empty, if no content is given).
  */
  copy(e = null) {
    return e == this.content ? this : new Wr(this.type, this.attrs, e, this.marks);
  }
  /**
  Create a copy of this node, with the given set of marks instead
  of the node's own marks.
  */
  mark(e) {
    return e == this.marks ? this : new Wr(this.type, this.attrs, this.content, e);
  }
  /**
  Create a copy of this node with only the content between the
  given positions. If `to` is not given, it defaults to the end of
  the node.
  */
  cut(e, t = this.content.size) {
    return e == 0 && t == this.content.size ? this : this.copy(this.content.cut(e, t));
  }
  /**
  Cut out the part of the document between the given positions, and
  return it as a `Slice` object.
  */
  slice(e, t = this.content.size, r = !1) {
    if (e == t)
      return ke.empty;
    let i = this.resolve(e), o = this.resolve(t), a = r ? 0 : i.sharedDepth(t), l = i.start(a), d = i.node(a).content.cut(i.pos - l, o.pos - l);
    return new ke(d, i.depth - a, o.depth - a);
  }
  /**
  Replace the part of the document between the given positions with
  the given slice. The slice must 'fit', meaning its open sides
  must be able to connect to the surrounding content, and its
  content nodes must be valid children for the node they are placed
  into. If any of this is violated, an error of type
  [`ReplaceError`](https://prosemirror.net/docs/ref/#model.ReplaceError) is thrown.
  */
  replace(e, t, r) {
    return rM(this.resolve(e), this.resolve(t), r);
  }
  /**
  Find the node directly after the given position.
  */
  nodeAt(e) {
    for (let t = this; ; ) {
      let { index: r, offset: i } = t.content.findIndex(e);
      if (t = t.maybeChild(r), !t)
        return null;
      if (i == e || t.isText)
        return t;
      e -= i + 1;
    }
  }
  /**
  Find the (direct) child node after the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childAfter(e) {
    let { index: t, offset: r } = this.content.findIndex(e);
    return { node: this.content.maybeChild(t), index: t, offset: r };
  }
  /**
  Find the (direct) child node before the given offset, if any,
  and return it along with its index and offset relative to this
  node.
  */
  childBefore(e) {
    if (e == 0)
      return { node: null, index: 0, offset: 0 };
    let { index: t, offset: r } = this.content.findIndex(e);
    if (r < e)
      return { node: this.content.child(t), index: t, offset: r };
    let i = this.content.child(t - 1);
    return { node: i, index: t - 1, offset: r - i.nodeSize };
  }
  /**
  Resolve the given position in the document, returning an
  [object](https://prosemirror.net/docs/ref/#model.ResolvedPos) with information about its context.
  */
  resolve(e) {
    return da.resolveCached(this, e);
  }
  /**
  @internal
  */
  resolveNoCache(e) {
    return da.resolve(this, e);
  }
  /**
  Test whether a given mark or mark type occurs in this document
  between the two given positions.
  */
  rangeHasMark(e, t, r) {
    let i = !1;
    return t > e && this.nodesBetween(e, t, (o) => (r.isInSet(o.marks) && (i = !0), !i)), i;
  }
  /**
  True when this is a block (non-inline node)
  */
  get isBlock() {
    return this.type.isBlock;
  }
  /**
  True when this is a textblock node, a block node with inline
  content.
  */
  get isTextblock() {
    return this.type.isTextblock;
  }
  /**
  True when this node allows inline content.
  */
  get inlineContent() {
    return this.type.inlineContent;
  }
  /**
  True when this is an inline node (a text node or a node that can
  appear among text).
  */
  get isInline() {
    return this.type.isInline;
  }
  /**
  True when this is a text node.
  */
  get isText() {
    return this.type.isText;
  }
  /**
  True when this is a leaf node.
  */
  get isLeaf() {
    return this.type.isLeaf;
  }
  /**
  True when this is an atom, i.e. when it does not have directly
  editable content. This is usually the same as `isLeaf`, but can
  be configured with the [`atom` property](https://prosemirror.net/docs/ref/#model.NodeSpec.atom)
  on a node's spec (typically used when the node is displayed as
  an uneditable [node view](https://prosemirror.net/docs/ref/#view.NodeView)).
  */
  get isAtom() {
    return this.type.isAtom;
  }
  /**
  Return a string representation of this node for debugging
  purposes.
  */
  toString() {
    if (this.type.spec.toDebugString)
      return this.type.spec.toDebugString(this);
    let e = this.type.name;
    return this.content.size && (e += "(" + this.content.toStringInner() + ")"), gy(this.marks, e);
  }
  /**
  Get the content match in this node at the given index.
  */
  contentMatchAt(e) {
    let t = this.type.contentMatch.matchFragment(this.content, 0, e);
    if (!t)
      throw new Error("Called contentMatchAt on a node with invalid content");
    return t;
  }
  /**
  Test whether replacing the range between `from` and `to` (by
  child index) with the given replacement fragment (which defaults
  to the empty fragment) would leave the node's content valid. You
  can optionally pass `start` and `end` indices into the
  replacement fragment.
  */
  canReplace(e, t, r = ue.empty, i = 0, o = r.childCount) {
    let a = this.contentMatchAt(e).matchFragment(r, i, o), l = a && a.matchFragment(this.content, t);
    if (!l || !l.validEnd)
      return !1;
    for (let u = i; u < o; u++)
      if (!this.type.allowsMarks(r.child(u).marks))
        return !1;
    return !0;
  }
  /**
  Test whether replacing the range `from` to `to` (by index) with
  a node of the given type would leave the node's content valid.
  */
  canReplaceWith(e, t, r, i) {
    if (i && !this.type.allowsMarks(i))
      return !1;
    let o = this.contentMatchAt(e).matchType(r), a = o && o.matchFragment(this.content, t);
    return a ? a.validEnd : !1;
  }
  /**
  Test whether the given node's content could be appended to this
  node. If that node is empty, this will only return true if there
  is at least one node type that can appear in both nodes (to avoid
  merging completely incompatible nodes).
  */
  canAppend(e) {
    return e.content.size ? this.canReplace(this.childCount, this.childCount, e.content) : this.type.compatibleContent(e.type);
  }
  /**
  Check whether this node and its descendants conform to the
  schema, and raise error when they do not.
  */
  check() {
    this.type.checkContent(this.content);
    let e = ct.none;
    for (let t = 0; t < this.marks.length; t++)
      e = this.marks[t].addToSet(e);
    if (!ct.sameSet(e, this.marks))
      throw new RangeError(`Invalid collection of marks for node ${this.type.name}: ${this.marks.map((t) => t.type.name)}`);
    this.content.forEach((t) => t.check());
  }
  /**
  Return a JSON-serializeable representation of this node.
  */
  toJSON() {
    let e = { type: this.type.name };
    for (let t in this.attrs) {
      e.attrs = this.attrs;
      break;
    }
    return this.content.size && (e.content = this.content.toJSON()), this.marks.length && (e.marks = this.marks.map((t) => t.toJSON())), e;
  }
  /**
  Deserialize a node from its JSON representation.
  */
  static fromJSON(e, t) {
    if (!t)
      throw new RangeError("Invalid input for Node.fromJSON");
    let r = null;
    if (t.marks) {
      if (!Array.isArray(t.marks))
        throw new RangeError("Invalid mark data for Node.fromJSON");
      r = t.marks.map(e.markFromJSON);
    }
    if (t.type == "text") {
      if (typeof t.text != "string")
        throw new RangeError("Invalid text node in JSON");
      return e.text(t.text, r);
    }
    let i = ue.fromJSON(e, t.content);
    return e.nodeType(t.type).create(t.attrs, i, r);
  }
}
Wr.prototype.text = void 0;
class cc extends Wr {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    if (super(e, t, null, i), !r)
      throw new RangeError("Empty text nodes are not allowed");
    this.text = r;
  }
  toString() {
    return this.type.spec.toDebugString ? this.type.spec.toDebugString(this) : gy(this.marks, JSON.stringify(this.text));
  }
  get textContent() {
    return this.text;
  }
  textBetween(e, t) {
    return this.text.slice(e, t);
  }
  get nodeSize() {
    return this.text.length;
  }
  mark(e) {
    return e == this.marks ? this : new cc(this.type, this.attrs, this.text, e);
  }
  withText(e) {
    return e == this.text ? this : new cc(this.type, this.attrs, e, this.marks);
  }
  cut(e = 0, t = this.text.length) {
    return e == 0 && t == this.text.length ? this : this.withText(this.text.slice(e, t));
  }
  eq(e) {
    return this.sameMarkup(e) && this.text == e.text;
  }
  toJSON() {
    let e = super.toJSON();
    return e.text = this.text, e;
  }
}
function gy(n, e) {
  for (let t = n.length - 1; t >= 0; t--)
    e = n[t].type.name + "(" + e + ")";
  return e;
}
class bo {
  /**
  @internal
  */
  constructor(e) {
    this.validEnd = e, this.next = [], this.wrapCache = [];
  }
  /**
  @internal
  */
  static parse(e, t) {
    let r = new lM(e, t);
    if (r.next == null)
      return bo.empty;
    let i = my(r);
    r.next && r.err("Unexpected trailing text");
    let o = gM(pM(i));
    return mM(o, r), o;
  }
  /**
  Match a node type, returning a match after that node if
  successful.
  */
  matchType(e) {
    for (let t = 0; t < this.next.length; t++)
      if (this.next[t].type == e)
        return this.next[t].next;
    return null;
  }
  /**
  Try to match a fragment. Returns the resulting match when
  successful.
  */
  matchFragment(e, t = 0, r = e.childCount) {
    let i = this;
    for (let o = t; i && o < r; o++)
      i = i.matchType(e.child(o).type);
    return i;
  }
  /**
  @internal
  */
  get inlineContent() {
    return this.next.length != 0 && this.next[0].type.isInline;
  }
  /**
  Get the first matching node type at this match position that can
  be generated.
  */
  get defaultType() {
    for (let e = 0; e < this.next.length; e++) {
      let { type: t } = this.next[e];
      if (!(t.isText || t.hasRequiredAttrs()))
        return t;
    }
    return null;
  }
  /**
  @internal
  */
  compatible(e) {
    for (let t = 0; t < this.next.length; t++)
      for (let r = 0; r < e.next.length; r++)
        if (this.next[t].type == e.next[r].type)
          return !0;
    return !1;
  }
  /**
  Try to match the given fragment, and if that fails, see if it can
  be made to match by inserting nodes in front of it. When
  successful, return a fragment of inserted nodes (which may be
  empty if nothing had to be inserted). When `toEnd` is true, only
  return a fragment if the resulting match goes to the end of the
  content expression.
  */
  fillBefore(e, t = !1, r = 0) {
    let i = [this];
    function o(a, l) {
      let u = a.matchFragment(e, r);
      if (u && (!t || u.validEnd))
        return ue.from(l.map((d) => d.createAndFill()));
      for (let d = 0; d < a.next.length; d++) {
        let { type: h, next: p } = a.next[d];
        if (!(h.isText || h.hasRequiredAttrs()) && i.indexOf(p) == -1) {
          i.push(p);
          let g = o(p, l.concat(h));
          if (g)
            return g;
        }
      }
      return null;
    }
    return o(this, []);
  }
  /**
  Find a set of wrapping node types that would allow a node of the
  given type to appear at this position. The result may be empty
  (when it fits directly) and will be null when no such wrapping
  exists.
  */
  findWrapping(e) {
    for (let r = 0; r < this.wrapCache.length; r += 2)
      if (this.wrapCache[r] == e)
        return this.wrapCache[r + 1];
    let t = this.computeWrapping(e);
    return this.wrapCache.push(e, t), t;
  }
  /**
  @internal
  */
  computeWrapping(e) {
    let t = /* @__PURE__ */ Object.create(null), r = [{ match: this, type: null, via: null }];
    for (; r.length; ) {
      let i = r.shift(), o = i.match;
      if (o.matchType(e)) {
        let a = [];
        for (let l = i; l.type; l = l.via)
          a.push(l.type);
        return a.reverse();
      }
      for (let a = 0; a < o.next.length; a++) {
        let { type: l, next: u } = o.next[a];
        !l.isLeaf && !l.hasRequiredAttrs() && !(l.name in t) && (!i.type || u.validEnd) && (r.push({ match: l.contentMatch, type: l, via: i }), t[l.name] = !0);
      }
    }
    return null;
  }
  /**
  The number of outgoing edges this node has in the finite
  automaton that describes the content expression.
  */
  get edgeCount() {
    return this.next.length;
  }
  /**
  Get the _n_​th outgoing edge from this node in the finite
  automaton that describes the content expression.
  */
  edge(e) {
    if (e >= this.next.length)
      throw new RangeError(`There's no ${e}th edge in this content match`);
    return this.next[e];
  }
  /**
  @internal
  */
  toString() {
    let e = [];
    function t(r) {
      e.push(r);
      for (let i = 0; i < r.next.length; i++)
        e.indexOf(r.next[i].next) == -1 && t(r.next[i].next);
    }
    return t(this), e.map((r, i) => {
      let o = i + (r.validEnd ? "*" : " ") + " ";
      for (let a = 0; a < r.next.length; a++)
        o += (a ? ", " : "") + r.next[a].type.name + "->" + e.indexOf(r.next[a].next);
      return o;
    }).join(`
`);
  }
}
bo.empty = new bo(!0);
class lM {
  constructor(e, t) {
    this.string = e, this.nodeTypes = t, this.inline = null, this.pos = 0, this.tokens = e.split(/\s*(?=\b|\W|$)/), this.tokens[this.tokens.length - 1] == "" && this.tokens.pop(), this.tokens[0] == "" && this.tokens.shift();
  }
  get next() {
    return this.tokens[this.pos];
  }
  eat(e) {
    return this.next == e && (this.pos++ || !0);
  }
  err(e) {
    throw new SyntaxError(e + " (in content expression '" + this.string + "')");
  }
}
function my(n) {
  let e = [];
  do
    e.push(cM(n));
  while (n.eat("|"));
  return e.length == 1 ? e[0] : { type: "choice", exprs: e };
}
function cM(n) {
  let e = [];
  do
    e.push(uM(n));
  while (n.next && n.next != ")" && n.next != "|");
  return e.length == 1 ? e[0] : { type: "seq", exprs: e };
}
function uM(n) {
  let e = hM(n);
  for (; ; )
    if (n.eat("+"))
      e = { type: "plus", expr: e };
    else if (n.eat("*"))
      e = { type: "star", expr: e };
    else if (n.eat("?"))
      e = { type: "opt", expr: e };
    else if (n.eat("{"))
      e = dM(n, e);
    else
      break;
  return e;
}
function B0(n) {
  /\D/.test(n.next) && n.err("Expected number, got '" + n.next + "'");
  let e = Number(n.next);
  return n.pos++, e;
}
function dM(n, e) {
  let t = B0(n), r = t;
  return n.eat(",") && (n.next != "}" ? r = B0(n) : r = -1), n.eat("}") || n.err("Unclosed braced range"), { type: "range", min: t, max: r, expr: e };
}
function fM(n, e) {
  let t = n.nodeTypes, r = t[e];
  if (r)
    return [r];
  let i = [];
  for (let o in t) {
    let a = t[o];
    a.groups.indexOf(e) > -1 && i.push(a);
  }
  return i.length == 0 && n.err("No node type or group '" + e + "' found"), i;
}
function hM(n) {
  if (n.eat("(")) {
    let e = my(n);
    return n.eat(")") || n.err("Missing closing paren"), e;
  } else if (/\W/.test(n.next))
    n.err("Unexpected token '" + n.next + "'");
  else {
    let e = fM(n, n.next).map((t) => (n.inline == null ? n.inline = t.isInline : n.inline != t.isInline && n.err("Mixing inline and block content"), { type: "name", value: t }));
    return n.pos++, e.length == 1 ? e[0] : { type: "choice", exprs: e };
  }
}
function pM(n) {
  let e = [[]];
  return i(o(n, 0), t()), e;
  function t() {
    return e.push([]) - 1;
  }
  function r(a, l, u) {
    let d = { term: u, to: l };
    return e[a].push(d), d;
  }
  function i(a, l) {
    a.forEach((u) => u.to = l);
  }
  function o(a, l) {
    if (a.type == "choice")
      return a.exprs.reduce((u, d) => u.concat(o(d, l)), []);
    if (a.type == "seq")
      for (let u = 0; ; u++) {
        let d = o(a.exprs[u], l);
        if (u == a.exprs.length - 1)
          return d;
        i(d, l = t());
      }
    else if (a.type == "star") {
      let u = t();
      return r(l, u), i(o(a.expr, u), u), [r(u)];
    } else if (a.type == "plus") {
      let u = t();
      return i(o(a.expr, l), u), i(o(a.expr, u), u), [r(u)];
    } else {
      if (a.type == "opt")
        return [r(l)].concat(o(a.expr, l));
      if (a.type == "range") {
        let u = l;
        for (let d = 0; d < a.min; d++) {
          let h = t();
          i(o(a.expr, u), h), u = h;
        }
        if (a.max == -1)
          i(o(a.expr, u), u);
        else
          for (let d = a.min; d < a.max; d++) {
            let h = t();
            r(u, h), i(o(a.expr, u), h), u = h;
          }
        return [r(u)];
      } else {
        if (a.type == "name")
          return [r(l, void 0, a.value)];
        throw new Error("Unknown expr type");
      }
    }
  }
}
function vy(n, e) {
  return e - n;
}
function F0(n, e) {
  let t = [];
  return r(e), t.sort(vy);
  function r(i) {
    let o = n[i];
    if (o.length == 1 && !o[0].term)
      return r(o[0].to);
    t.push(i);
    for (let a = 0; a < o.length; a++) {
      let { term: l, to: u } = o[a];
      !l && t.indexOf(u) == -1 && r(u);
    }
  }
}
function gM(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return t(F0(n, 0));
  function t(r) {
    let i = [];
    r.forEach((a) => {
      n[a].forEach(({ term: l, to: u }) => {
        if (!l)
          return;
        let d;
        for (let h = 0; h < i.length; h++)
          i[h][0] == l && (d = i[h][1]);
        F0(n, u).forEach((h) => {
          d || i.push([l, d = []]), d.indexOf(h) == -1 && d.push(h);
        });
      });
    });
    let o = e[r.join(",")] = new bo(r.indexOf(n.length - 1) > -1);
    for (let a = 0; a < i.length; a++) {
      let l = i[a][1].sort(vy);
      o.next.push({ type: i[a][0], next: e[l.join(",")] || t(l) });
    }
    return o;
  }
}
function mM(n, e) {
  for (let t = 0, r = [n]; t < r.length; t++) {
    let i = r[t], o = !i.validEnd, a = [];
    for (let l = 0; l < i.next.length; l++) {
      let { type: u, next: d } = i.next[l];
      a.push(u.name), o && !(u.isText || u.hasRequiredAttrs()) && (o = !1), r.indexOf(d) == -1 && r.push(d);
    }
    o && e.err("Only non-generatable nodes (" + a.join(", ") + ") in a required position (see https://prosemirror.net/docs/guide/#generatable)");
  }
}
function yy(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n) {
    let r = n[t];
    if (!r.hasDefault)
      return null;
    e[t] = r.default;
  }
  return e;
}
function wy(n, e) {
  let t = /* @__PURE__ */ Object.create(null);
  for (let r in n) {
    let i = e && e[r];
    if (i === void 0) {
      let o = n[r];
      if (o.hasDefault)
        i = o.default;
      else
        throw new RangeError("No value supplied for attribute " + r);
    }
    t[r] = i;
  }
  return t;
}
function by(n) {
  let e = /* @__PURE__ */ Object.create(null);
  if (n)
    for (let t in n)
      e[t] = new vM(n[t]);
  return e;
}
let V0 = class xy {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.name = e, this.schema = t, this.spec = r, this.markSet = null, this.groups = r.group ? r.group.split(" ") : [], this.attrs = by(r.attrs), this.defaultAttrs = yy(this.attrs), this.contentMatch = null, this.inlineContent = null, this.isBlock = !(r.inline || e == "text"), this.isText = e == "text";
  }
  /**
  True if this is an inline type.
  */
  get isInline() {
    return !this.isBlock;
  }
  /**
  True if this is a textblock type, a block that contains inline
  content.
  */
  get isTextblock() {
    return this.isBlock && this.inlineContent;
  }
  /**
  True for node types that allow no content.
  */
  get isLeaf() {
    return this.contentMatch == bo.empty;
  }
  /**
  True when this node is an atom, i.e. when it does not have
  directly editable content.
  */
  get isAtom() {
    return this.isLeaf || !!this.spec.atom;
  }
  /**
  The node type's [whitespace](https://prosemirror.net/docs/ref/#model.NodeSpec.whitespace) option.
  */
  get whitespace() {
    return this.spec.whitespace || (this.spec.code ? "pre" : "normal");
  }
  /**
  Tells you whether this node type has any required attributes.
  */
  hasRequiredAttrs() {
    for (let e in this.attrs)
      if (this.attrs[e].isRequired)
        return !0;
    return !1;
  }
  /**
  Indicates whether this node allows some of the same content as
  the given node type.
  */
  compatibleContent(e) {
    return this == e || this.contentMatch.compatible(e.contentMatch);
  }
  /**
  @internal
  */
  computeAttrs(e) {
    return !e && this.defaultAttrs ? this.defaultAttrs : wy(this.attrs, e);
  }
  /**
  Create a `Node` of this type. The given attributes are
  checked and defaulted (you can pass `null` to use the type's
  defaults entirely, if no required attributes exist). `content`
  may be a `Fragment`, a node, an array of nodes, or
  `null`. Similarly `marks` may be `null` to default to the empty
  set of marks.
  */
  create(e = null, t, r) {
    if (this.isText)
      throw new Error("NodeType.create can't construct text nodes");
    return new Wr(this, this.computeAttrs(e), ue.from(t), ct.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but check the given content
  against the node type's content restrictions, and throw an error
  if it doesn't match.
  */
  createChecked(e = null, t, r) {
    return t = ue.from(t), this.checkContent(t), new Wr(this, this.computeAttrs(e), t, ct.setFrom(r));
  }
  /**
  Like [`create`](https://prosemirror.net/docs/ref/#model.NodeType.create), but see if it is
  necessary to add nodes to the start or end of the given fragment
  to make it fit the node. If no fitting wrapping can be found,
  return null. Note that, due to the fact that required nodes can
  always be created, this will always succeed if you pass null or
  `Fragment.empty` as content.
  */
  createAndFill(e = null, t, r) {
    if (e = this.computeAttrs(e), t = ue.from(t), t.size) {
      let a = this.contentMatch.fillBefore(t);
      if (!a)
        return null;
      t = a.append(t);
    }
    let i = this.contentMatch.matchFragment(t), o = i && i.fillBefore(ue.empty, !0);
    return o ? new Wr(this, e, t.append(o), ct.setFrom(r)) : null;
  }
  /**
  Returns true if the given fragment is valid content for this node
  type with the given attributes.
  */
  validContent(e) {
    let t = this.contentMatch.matchFragment(e);
    if (!t || !t.validEnd)
      return !1;
    for (let r = 0; r < e.childCount; r++)
      if (!this.allowsMarks(e.child(r).marks))
        return !1;
    return !0;
  }
  /**
  Throws a RangeError if the given fragment is not valid content for this
  node type.
  @internal
  */
  checkContent(e) {
    if (!this.validContent(e))
      throw new RangeError(`Invalid content for node ${this.name}: ${e.toString().slice(0, 50)}`);
  }
  /**
  Check whether the given mark type is allowed in this node.
  */
  allowsMarkType(e) {
    return this.markSet == null || this.markSet.indexOf(e) > -1;
  }
  /**
  Test whether the given set of marks are allowed in this node.
  */
  allowsMarks(e) {
    if (this.markSet == null)
      return !0;
    for (let t = 0; t < e.length; t++)
      if (!this.allowsMarkType(e[t].type))
        return !1;
    return !0;
  }
  /**
  Removes the marks that are not allowed in this node from the given set.
  */
  allowedMarks(e) {
    if (this.markSet == null)
      return e;
    let t;
    for (let r = 0; r < e.length; r++)
      this.allowsMarkType(e[r].type) ? t && t.push(e[r]) : t || (t = e.slice(0, r));
    return t ? t.length ? t : ct.none : e;
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null);
    e.forEach((o, a) => r[o] = new xy(o, t, a));
    let i = t.spec.topNode || "doc";
    if (!r[i])
      throw new RangeError("Schema is missing its top node type ('" + i + "')");
    if (!r.text)
      throw new RangeError("Every schema needs a 'text' type");
    for (let o in r.text.attrs)
      throw new RangeError("The text node type should not have attributes");
    return r;
  }
};
class vM {
  constructor(e) {
    this.hasDefault = Object.prototype.hasOwnProperty.call(e, "default"), this.default = e.default;
  }
  get isRequired() {
    return !this.hasDefault;
  }
}
class $c {
  /**
  @internal
  */
  constructor(e, t, r, i) {
    this.name = e, this.rank = t, this.schema = r, this.spec = i, this.attrs = by(i.attrs), this.excluded = null;
    let o = yy(this.attrs);
    this.instance = o ? new ct(this, o) : null;
  }
  /**
  Create a mark of this type. `attrs` may be `null` or an object
  containing only some of the mark's attributes. The others, if
  they have defaults, will be added.
  */
  create(e = null) {
    return !e && this.instance ? this.instance : new ct(this, wy(this.attrs, e));
  }
  /**
  @internal
  */
  static compile(e, t) {
    let r = /* @__PURE__ */ Object.create(null), i = 0;
    return e.forEach((o, a) => r[o] = new $c(o, i++, t, a)), r;
  }
  /**
  When there is a mark of this type in the given set, a new set
  without it is returned. Otherwise, the input set is returned.
  */
  removeFromSet(e) {
    for (var t = 0; t < e.length; t++)
      e[t].type == this && (e = e.slice(0, t).concat(e.slice(t + 1)), t--);
    return e;
  }
  /**
  Tests whether there is a mark of this type in the given set.
  */
  isInSet(e) {
    for (let t = 0; t < e.length; t++)
      if (e[t].type == this)
        return e[t];
  }
  /**
  Queries whether a given mark type is
  [excluded](https://prosemirror.net/docs/ref/#model.MarkSpec.excludes) by this one.
  */
  excludes(e) {
    return this.excluded.indexOf(e) > -1;
  }
}
class Sy {
  /**
  Construct a schema from a schema [specification](https://prosemirror.net/docs/ref/#model.SchemaSpec).
  */
  constructor(e) {
    this.cached = /* @__PURE__ */ Object.create(null);
    let t = this.spec = {};
    for (let i in e)
      t[i] = e[i];
    t.nodes = en.from(e.nodes), t.marks = en.from(e.marks || {}), this.nodes = V0.compile(this.spec.nodes, this), this.marks = $c.compile(this.spec.marks, this);
    let r = /* @__PURE__ */ Object.create(null);
    for (let i in this.nodes) {
      if (i in this.marks)
        throw new RangeError(i + " can not be both a node and a mark");
      let o = this.nodes[i], a = o.spec.content || "", l = o.spec.marks;
      o.contentMatch = r[a] || (r[a] = bo.parse(a, this.nodes)), o.inlineContent = o.contentMatch.inlineContent, o.markSet = l == "_" ? null : l ? W0(this, l.split(" ")) : l == "" || !o.inlineContent ? [] : null;
    }
    for (let i in this.marks) {
      let o = this.marks[i], a = o.spec.excludes;
      o.excluded = a == null ? [o] : a == "" ? [] : W0(this, a.split(" "));
    }
    this.nodeFromJSON = this.nodeFromJSON.bind(this), this.markFromJSON = this.markFromJSON.bind(this), this.topNodeType = this.nodes[this.spec.topNode || "doc"], this.cached.wrappings = /* @__PURE__ */ Object.create(null);
  }
  /**
  Create a node in this schema. The `type` may be a string or a
  `NodeType` instance. Attributes will be extended with defaults,
  `content` may be a `Fragment`, `null`, a `Node`, or an array of
  nodes.
  */
  node(e, t = null, r, i) {
    if (typeof e == "string")
      e = this.nodeType(e);
    else if (e instanceof V0) {
      if (e.schema != this)
        throw new RangeError("Node type from different schema used (" + e.name + ")");
    } else
      throw new RangeError("Invalid node type: " + e);
    return e.createChecked(t, r, i);
  }
  /**
  Create a text node in the schema. Empty text nodes are not
  allowed.
  */
  text(e, t) {
    let r = this.nodes.text;
    return new cc(r, r.defaultAttrs, e, ct.setFrom(t));
  }
  /**
  Create a mark with the given type and attributes.
  */
  mark(e, t) {
    return typeof e == "string" && (e = this.marks[e]), e.create(t);
  }
  /**
  Deserialize a node from its JSON representation. This method is
  bound.
  */
  nodeFromJSON(e) {
    return Wr.fromJSON(this, e);
  }
  /**
  Deserialize a mark from its JSON representation. This method is
  bound.
  */
  markFromJSON(e) {
    return ct.fromJSON(this, e);
  }
  /**
  @internal
  */
  nodeType(e) {
    let t = this.nodes[e];
    if (!t)
      throw new RangeError("Unknown node type: " + e);
    return t;
  }
}
function W0(n, e) {
  let t = [];
  for (let r = 0; r < e.length; r++) {
    let i = e[r], o = n.marks[i], a = o;
    if (o)
      t.push(o);
    else
      for (let l in n.marks) {
        let u = n.marks[l];
        (i == "_" || u.spec.group && u.spec.group.split(" ").indexOf(i) > -1) && t.push(a = u);
      }
    if (!a)
      throw new SyntaxError("Unknown mark type: '" + e[r] + "'");
  }
  return t;
}
class xo {
  /**
  Create a parser that targets the given schema, using the given
  parsing rules.
  */
  constructor(e, t) {
    this.schema = e, this.rules = t, this.tags = [], this.styles = [], t.forEach((r) => {
      r.tag ? this.tags.push(r) : r.style && this.styles.push(r);
    }), this.normalizeLists = !this.tags.some((r) => {
      if (!/^(ul|ol)\b/.test(r.tag) || !r.node)
        return !1;
      let i = e.nodes[r.node];
      return i.contentMatch.matchType(i);
    });
  }
  /**
  Parse a document from the content of a DOM node.
  */
  parse(e, t = {}) {
    let r = new $0(this, t, !1);
    return r.addAll(e, t.from, t.to), r.finish();
  }
  /**
  Parses the content of the given DOM node, like
  [`parse`](https://prosemirror.net/docs/ref/#model.DOMParser.parse), and takes the same set of
  options. But unlike that method, which produces a whole node,
  this one returns a slice that is open at the sides, meaning that
  the schema constraints aren't applied to the start of nodes to
  the left of the input and the end of nodes at the end.
  */
  parseSlice(e, t = {}) {
    let r = new $0(this, t, !0);
    return r.addAll(e, t.from, t.to), ke.maxOpen(r.finish());
  }
  /**
  @internal
  */
  matchTag(e, t, r) {
    for (let i = r ? this.tags.indexOf(r) + 1 : 0; i < this.tags.length; i++) {
      let o = this.tags[i];
      if (bM(e, o.tag) && (o.namespace === void 0 || e.namespaceURI == o.namespace) && (!o.context || t.matchesContext(o.context))) {
        if (o.getAttrs) {
          let a = o.getAttrs(e);
          if (a === !1)
            continue;
          o.attrs = a || void 0;
        }
        return o;
      }
    }
  }
  /**
  @internal
  */
  matchStyle(e, t, r, i) {
    for (let o = i ? this.styles.indexOf(i) + 1 : 0; o < this.styles.length; o++) {
      let a = this.styles[o], l = a.style;
      if (!(l.indexOf(e) != 0 || a.context && !r.matchesContext(a.context) || // Test that the style string either precisely matches the prop,
      // or has an '=' sign after the prop, followed by the given
      // value.
      l.length > e.length && (l.charCodeAt(e.length) != 61 || l.slice(e.length + 1) != t))) {
        if (a.getAttrs) {
          let u = a.getAttrs(t);
          if (u === !1)
            continue;
          a.attrs = u || void 0;
        }
        return a;
      }
    }
  }
  /**
  @internal
  */
  static schemaRules(e) {
    let t = [];
    function r(i) {
      let o = i.priority == null ? 50 : i.priority, a = 0;
      for (; a < t.length; a++) {
        let l = t[a];
        if ((l.priority == null ? 50 : l.priority) < o)
          break;
      }
      t.splice(a, 0, i);
    }
    for (let i in e.marks) {
      let o = e.marks[i].spec.parseDOM;
      o && o.forEach((a) => {
        r(a = U0(a)), a.mark || a.ignore || a.clearMark || (a.mark = i);
      });
    }
    for (let i in e.nodes) {
      let o = e.nodes[i].spec.parseDOM;
      o && o.forEach((a) => {
        r(a = U0(a)), a.node || a.ignore || a.mark || (a.node = i);
      });
    }
    return t;
  }
  /**
  Construct a DOM parser using the parsing rules listed in a
  schema's [node specs](https://prosemirror.net/docs/ref/#model.NodeSpec.parseDOM), reordered by
  [priority](https://prosemirror.net/docs/ref/#model.ParseRule.priority).
  */
  static fromSchema(e) {
    return e.cached.domParser || (e.cached.domParser = new xo(e, xo.schemaRules(e)));
  }
}
const Cy = {
  address: !0,
  article: !0,
  aside: !0,
  blockquote: !0,
  canvas: !0,
  dd: !0,
  div: !0,
  dl: !0,
  fieldset: !0,
  figcaption: !0,
  figure: !0,
  footer: !0,
  form: !0,
  h1: !0,
  h2: !0,
  h3: !0,
  h4: !0,
  h5: !0,
  h6: !0,
  header: !0,
  hgroup: !0,
  hr: !0,
  li: !0,
  noscript: !0,
  ol: !0,
  output: !0,
  p: !0,
  pre: !0,
  section: !0,
  table: !0,
  tfoot: !0,
  ul: !0
}, yM = {
  head: !0,
  noscript: !0,
  object: !0,
  script: !0,
  style: !0,
  title: !0
}, Ey = { ol: !0, ul: !0 }, uc = 1, dc = 2, Xs = 4;
function H0(n, e, t) {
  return e != null ? (e ? uc : 0) | (e === "full" ? dc : 0) : n && n.whitespace == "pre" ? uc | dc : t & ~Xs;
}
class Il {
  constructor(e, t, r, i, o, a, l) {
    this.type = e, this.attrs = t, this.marks = r, this.pendingMarks = i, this.solid = o, this.options = l, this.content = [], this.activeMarks = ct.none, this.stashMarks = [], this.match = a || (l & Xs ? null : e.contentMatch);
  }
  findWrapping(e) {
    if (!this.match) {
      if (!this.type)
        return [];
      let t = this.type.contentMatch.fillBefore(ue.from(e));
      if (t)
        this.match = this.type.contentMatch.matchFragment(t);
      else {
        let r = this.type.contentMatch, i;
        return (i = r.findWrapping(e.type)) ? (this.match = r, i) : null;
      }
    }
    return this.match.findWrapping(e.type);
  }
  finish(e) {
    if (!(this.options & uc)) {
      let r = this.content[this.content.length - 1], i;
      if (r && r.isText && (i = /[ \t\r\n\u000c]+$/.exec(r.text))) {
        let o = r;
        r.text.length == i[0].length ? this.content.pop() : this.content[this.content.length - 1] = o.withText(o.text.slice(0, o.text.length - i[0].length));
      }
    }
    let t = ue.from(this.content);
    return !e && this.match && (t = t.append(this.match.fillBefore(ue.empty, !0))), this.type ? this.type.create(this.attrs, t, this.marks) : t;
  }
  popFromStashMark(e) {
    for (let t = this.stashMarks.length - 1; t >= 0; t--)
      if (e.eq(this.stashMarks[t]))
        return this.stashMarks.splice(t, 1)[0];
  }
  applyPending(e) {
    for (let t = 0, r = this.pendingMarks; t < r.length; t++) {
      let i = r[t];
      (this.type ? this.type.allowsMarkType(i.type) : SM(i.type, e)) && !i.isInSet(this.activeMarks) && (this.activeMarks = i.addToSet(this.activeMarks), this.pendingMarks = i.removeFromSet(this.pendingMarks));
    }
  }
  inlineContext(e) {
    return this.type ? this.type.inlineContent : this.content.length ? this.content[0].isInline : e.parentNode && !Cy.hasOwnProperty(e.parentNode.nodeName.toLowerCase());
  }
}
class $0 {
  constructor(e, t, r) {
    this.parser = e, this.options = t, this.isOpen = r, this.open = 0;
    let i = t.topNode, o, a = H0(null, t.preserveWhitespace, 0) | (r ? Xs : 0);
    i ? o = new Il(i.type, i.attrs, ct.none, ct.none, !0, t.topMatch || i.type.contentMatch, a) : r ? o = new Il(null, null, ct.none, ct.none, !0, null, a) : o = new Il(e.schema.topNodeType, null, ct.none, ct.none, !0, null, a), this.nodes = [o], this.find = t.findPositions, this.needsBlock = !1;
  }
  get top() {
    return this.nodes[this.open];
  }
  // Add a DOM node to the content. Text is inserted as text node,
  // otherwise, the node is passed to `addElement` or, if it has a
  // `style` attribute, `addElementWithStyles`.
  addDOM(e) {
    e.nodeType == 3 ? this.addTextNode(e) : e.nodeType == 1 && this.addElement(e);
  }
  withStyleRules(e, t) {
    let r = e.getAttribute("style");
    if (!r)
      return t();
    let i = this.readStyles(xM(r));
    if (!i)
      return;
    let [o, a] = i, l = this.top;
    for (let u = 0; u < a.length; u++)
      this.removePendingMark(a[u], l);
    for (let u = 0; u < o.length; u++)
      this.addPendingMark(o[u]);
    t();
    for (let u = 0; u < o.length; u++)
      this.removePendingMark(o[u], l);
    for (let u = 0; u < a.length; u++)
      this.addPendingMark(a[u]);
  }
  addTextNode(e) {
    let t = e.nodeValue, r = this.top;
    if (r.options & dc || r.inlineContext(e) || /[^ \t\r\n\u000c]/.test(t)) {
      if (r.options & uc)
        r.options & dc ? t = t.replace(/\r\n?/g, `
`) : t = t.replace(/\r?\n|\r/g, " ");
      else if (t = t.replace(/[ \t\r\n\u000c]+/g, " "), /^[ \t\r\n\u000c]/.test(t) && this.open == this.nodes.length - 1) {
        let i = r.content[r.content.length - 1], o = e.previousSibling;
        (!i || o && o.nodeName == "BR" || i.isText && /[ \t\r\n\u000c]$/.test(i.text)) && (t = t.slice(1));
      }
      t && this.insertNode(this.parser.schema.text(t)), this.findInText(e);
    } else
      this.findInside(e);
  }
  // Try to find a handler for the given tag and use that to parse. If
  // none is found, the element's content nodes are added directly.
  addElement(e, t) {
    let r = e.nodeName.toLowerCase(), i;
    Ey.hasOwnProperty(r) && this.parser.normalizeLists && wM(e);
    let o = this.options.ruleFromNode && this.options.ruleFromNode(e) || (i = this.parser.matchTag(e, this, t));
    if (o ? o.ignore : yM.hasOwnProperty(r))
      this.findInside(e), this.ignoreFallback(e);
    else if (!o || o.skip || o.closeParent) {
      o && o.closeParent ? this.open = Math.max(0, this.open - 1) : o && o.skip.nodeType && (e = o.skip);
      let a, l = this.top, u = this.needsBlock;
      if (Cy.hasOwnProperty(r))
        l.content.length && l.content[0].isInline && this.open && (this.open--, l = this.top), a = !0, l.type || (this.needsBlock = !0);
      else if (!e.firstChild) {
        this.leafFallback(e);
        return;
      }
      o && o.skip ? this.addAll(e) : this.withStyleRules(e, () => this.addAll(e)), a && this.sync(l), this.needsBlock = u;
    } else
      this.withStyleRules(e, () => {
        this.addElementByRule(e, o, o.consuming === !1 ? i : void 0);
      });
  }
  // Called for leaf DOM nodes that would otherwise be ignored
  leafFallback(e) {
    e.nodeName == "BR" && this.top.type && this.top.type.inlineContent && this.addTextNode(e.ownerDocument.createTextNode(`
`));
  }
  // Called for ignored nodes
  ignoreFallback(e) {
    e.nodeName == "BR" && (!this.top.type || !this.top.type.inlineContent) && this.findPlace(this.parser.schema.text("-"));
  }
  // Run any style parser associated with the node's styles. Either
  // return an array of marks, or null to indicate some of the styles
  // had a rule with `ignore` set.
  readStyles(e) {
    let t = ct.none, r = ct.none;
    for (let i = 0; i < e.length; i += 2)
      for (let o = void 0; ; ) {
        let a = this.parser.matchStyle(e[i], e[i + 1], this, o);
        if (!a)
          break;
        if (a.ignore)
          return null;
        if (a.clearMark ? this.top.pendingMarks.concat(this.top.activeMarks).forEach((l) => {
          a.clearMark(l) && (r = l.addToSet(r));
        }) : t = this.parser.schema.marks[a.mark].create(a.attrs).addToSet(t), a.consuming === !1)
          o = a;
        else
          break;
      }
    return [t, r];
  }
  // Look up a handler for the given node. If none are found, return
  // false. Otherwise, apply it, use its return value to drive the way
  // the node's content is wrapped, and return true.
  addElementByRule(e, t, r) {
    let i, o, a;
    t.node ? (o = this.parser.schema.nodes[t.node], o.isLeaf ? this.insertNode(o.create(t.attrs)) || this.leafFallback(e) : i = this.enter(o, t.attrs || null, t.preserveWhitespace)) : (a = this.parser.schema.marks[t.mark].create(t.attrs), this.addPendingMark(a));
    let l = this.top;
    if (o && o.isLeaf)
      this.findInside(e);
    else if (r)
      this.addElement(e, r);
    else if (t.getContent)
      this.findInside(e), t.getContent(e, this.parser.schema).forEach((u) => this.insertNode(u));
    else {
      let u = e;
      typeof t.contentElement == "string" ? u = e.querySelector(t.contentElement) : typeof t.contentElement == "function" ? u = t.contentElement(e) : t.contentElement && (u = t.contentElement), this.findAround(e, u, !0), this.addAll(u);
    }
    i && this.sync(l) && this.open--, a && this.removePendingMark(a, l);
  }
  // Add all child nodes between `startIndex` and `endIndex` (or the
  // whole node, if not given). If `sync` is passed, use it to
  // synchronize after every block element.
  addAll(e, t, r) {
    let i = t || 0;
    for (let o = t ? e.childNodes[t] : e.firstChild, a = r == null ? null : e.childNodes[r]; o != a; o = o.nextSibling, ++i)
      this.findAtPoint(e, i), this.addDOM(o);
    this.findAtPoint(e, i);
  }
  // Try to find a way to fit the given node type into the current
  // context. May add intermediate wrappers and/or leave non-solid
  // nodes that we're in.
  findPlace(e) {
    let t, r;
    for (let i = this.open; i >= 0; i--) {
      let o = this.nodes[i], a = o.findWrapping(e);
      if (a && (!t || t.length > a.length) && (t = a, r = o, !a.length) || o.solid)
        break;
    }
    if (!t)
      return !1;
    this.sync(r);
    for (let i = 0; i < t.length; i++)
      this.enterInner(t[i], null, !1);
    return !0;
  }
  // Try to insert the given node, adjusting the context when needed.
  insertNode(e) {
    if (e.isInline && this.needsBlock && !this.top.type) {
      let t = this.textblockFromContext();
      t && this.enterInner(t);
    }
    if (this.findPlace(e)) {
      this.closeExtra();
      let t = this.top;
      t.applyPending(e.type), t.match && (t.match = t.match.matchType(e.type));
      let r = t.activeMarks;
      for (let i = 0; i < e.marks.length; i++)
        (!t.type || t.type.allowsMarkType(e.marks[i].type)) && (r = e.marks[i].addToSet(r));
      return t.content.push(e.mark(r)), !0;
    }
    return !1;
  }
  // Try to start a node of the given type, adjusting the context when
  // necessary.
  enter(e, t, r) {
    let i = this.findPlace(e.create(t));
    return i && this.enterInner(e, t, !0, r), i;
  }
  // Open a node of the given type
  enterInner(e, t = null, r = !1, i) {
    this.closeExtra();
    let o = this.top;
    o.applyPending(e), o.match = o.match && o.match.matchType(e);
    let a = H0(e, i, o.options);
    o.options & Xs && o.content.length == 0 && (a |= Xs), this.nodes.push(new Il(e, t, o.activeMarks, o.pendingMarks, r, null, a)), this.open++;
  }
  // Make sure all nodes above this.open are finished and added to
  // their parents
  closeExtra(e = !1) {
    let t = this.nodes.length - 1;
    if (t > this.open) {
      for (; t > this.open; t--)
        this.nodes[t - 1].content.push(this.nodes[t].finish(e));
      this.nodes.length = this.open + 1;
    }
  }
  finish() {
    return this.open = 0, this.closeExtra(this.isOpen), this.nodes[0].finish(this.isOpen || this.options.topOpen);
  }
  sync(e) {
    for (let t = this.open; t >= 0; t--)
      if (this.nodes[t] == e)
        return this.open = t, !0;
    return !1;
  }
  get currentPos() {
    this.closeExtra();
    let e = 0;
    for (let t = this.open; t >= 0; t--) {
      let r = this.nodes[t].content;
      for (let i = r.length - 1; i >= 0; i--)
        e += r[i].nodeSize;
      t && e++;
    }
    return e;
  }
  findAtPoint(e, t) {
    if (this.find)
      for (let r = 0; r < this.find.length; r++)
        this.find[r].node == e && this.find[r].offset == t && (this.find[r].pos = this.currentPos);
  }
  findInside(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].pos == null && e.nodeType == 1 && e.contains(this.find[t].node) && (this.find[t].pos = this.currentPos);
  }
  findAround(e, t, r) {
    if (e != t && this.find)
      for (let i = 0; i < this.find.length; i++)
        this.find[i].pos == null && e.nodeType == 1 && e.contains(this.find[i].node) && t.compareDocumentPosition(this.find[i].node) & (r ? 2 : 4) && (this.find[i].pos = this.currentPos);
  }
  findInText(e) {
    if (this.find)
      for (let t = 0; t < this.find.length; t++)
        this.find[t].node == e && (this.find[t].pos = this.currentPos - (e.nodeValue.length - this.find[t].offset));
  }
  // Determines whether the given context string matches this context.
  matchesContext(e) {
    if (e.indexOf("|") > -1)
      return e.split(/\s*\|\s*/).some(this.matchesContext, this);
    let t = e.split("/"), r = this.options.context, i = !this.isOpen && (!r || r.parent.type == this.nodes[0].type), o = -(r ? r.depth + 1 : 0) + (i ? 0 : 1), a = (l, u) => {
      for (; l >= 0; l--) {
        let d = t[l];
        if (d == "") {
          if (l == t.length - 1 || l == 0)
            continue;
          for (; u >= o; u--)
            if (a(l - 1, u))
              return !0;
          return !1;
        } else {
          let h = u > 0 || u == 0 && i ? this.nodes[u].type : r && u >= o ? r.node(u - o).type : null;
          if (!h || h.name != d && h.groups.indexOf(d) == -1)
            return !1;
          u--;
        }
      }
      return !0;
    };
    return a(t.length - 1, this.open);
  }
  textblockFromContext() {
    let e = this.options.context;
    if (e)
      for (let t = e.depth; t >= 0; t--) {
        let r = e.node(t).contentMatchAt(e.indexAfter(t)).defaultType;
        if (r && r.isTextblock && r.defaultAttrs)
          return r;
      }
    for (let t in this.parser.schema.nodes) {
      let r = this.parser.schema.nodes[t];
      if (r.isTextblock && r.defaultAttrs)
        return r;
    }
  }
  addPendingMark(e) {
    let t = CM(e, this.top.pendingMarks);
    t && this.top.stashMarks.push(t), this.top.pendingMarks = e.addToSet(this.top.pendingMarks);
  }
  removePendingMark(e, t) {
    for (let r = this.open; r >= 0; r--) {
      let i = this.nodes[r];
      if (i.pendingMarks.lastIndexOf(e) > -1)
        i.pendingMarks = e.removeFromSet(i.pendingMarks);
      else {
        i.activeMarks = e.removeFromSet(i.activeMarks);
        let a = i.popFromStashMark(e);
        a && i.type && i.type.allowsMarkType(a.type) && (i.activeMarks = a.addToSet(i.activeMarks));
      }
      if (i == t)
        break;
    }
  }
}
function wM(n) {
  for (let e = n.firstChild, t = null; e; e = e.nextSibling) {
    let r = e.nodeType == 1 ? e.nodeName.toLowerCase() : null;
    r && Ey.hasOwnProperty(r) && t ? (t.appendChild(e), e = t) : r == "li" ? t = e : r && (t = null);
  }
}
function bM(n, e) {
  return (n.matches || n.msMatchesSelector || n.webkitMatchesSelector || n.mozMatchesSelector).call(n, e);
}
function xM(n) {
  let e = /\s*([\w-]+)\s*:\s*([^;]+)/g, t, r = [];
  for (; t = e.exec(n); )
    r.push(t[1], t[2].trim());
  return r;
}
function U0(n) {
  let e = {};
  for (let t in n)
    e[t] = n[t];
  return e;
}
function SM(n, e) {
  let t = e.schema.nodes;
  for (let r in t) {
    let i = t[r];
    if (!i.allowsMarkType(n))
      continue;
    let o = [], a = (l) => {
      o.push(l);
      for (let u = 0; u < l.edgeCount; u++) {
        let { type: d, next: h } = l.edge(u);
        if (d == e || o.indexOf(h) < 0 && a(h))
          return !0;
      }
    };
    if (a(i.contentMatch))
      return !0;
  }
}
function CM(n, e) {
  for (let t = 0; t < e.length; t++)
    if (n.eq(e[t]))
      return e[t];
}
class si {
  /**
  Create a serializer. `nodes` should map node names to functions
  that take a node and return a description of the corresponding
  DOM. `marks` does the same for mark names, but also gets an
  argument that tells it whether the mark's content is block or
  inline content (for typical use, it'll always be inline). A mark
  serializer may be `null` to indicate that marks of that type
  should not be serialized.
  */
  constructor(e, t) {
    this.nodes = e, this.marks = t;
  }
  /**
  Serialize the content of this fragment to a DOM fragment. When
  not in the browser, the `document` option, containing a DOM
  document, should be passed so that the serializer can create
  nodes.
  */
  serializeFragment(e, t = {}, r) {
    r || (r = Ed(t).createDocumentFragment());
    let i = r, o = [];
    return e.forEach((a) => {
      if (o.length || a.marks.length) {
        let l = 0, u = 0;
        for (; l < o.length && u < a.marks.length; ) {
          let d = a.marks[u];
          if (!this.marks[d.type.name]) {
            u++;
            continue;
          }
          if (!d.eq(o[l][0]) || d.type.spec.spanning === !1)
            break;
          l++, u++;
        }
        for (; l < o.length; )
          i = o.pop()[1];
        for (; u < a.marks.length; ) {
          let d = a.marks[u++], h = this.serializeMark(d, a.isInline, t);
          h && (o.push([d, i]), i.appendChild(h.dom), i = h.contentDOM || h.dom);
        }
      }
      i.appendChild(this.serializeNodeInner(a, t));
    }), r;
  }
  /**
  @internal
  */
  serializeNodeInner(e, t) {
    let { dom: r, contentDOM: i } = si.renderSpec(Ed(t), this.nodes[e.type.name](e));
    if (i) {
      if (e.isLeaf)
        throw new RangeError("Content hole not allowed in a leaf node spec");
      this.serializeFragment(e.content, t, i);
    }
    return r;
  }
  /**
  Serialize this node to a DOM node. This can be useful when you
  need to serialize a part of a document, as opposed to the whole
  document. To serialize a whole document, use
  [`serializeFragment`](https://prosemirror.net/docs/ref/#model.DOMSerializer.serializeFragment) on
  its [content](https://prosemirror.net/docs/ref/#model.Node.content).
  */
  serializeNode(e, t = {}) {
    let r = this.serializeNodeInner(e, t);
    for (let i = e.marks.length - 1; i >= 0; i--) {
      let o = this.serializeMark(e.marks[i], e.isInline, t);
      o && ((o.contentDOM || o.dom).appendChild(r), r = o.dom);
    }
    return r;
  }
  /**
  @internal
  */
  serializeMark(e, t, r = {}) {
    let i = this.marks[e.type.name];
    return i && si.renderSpec(Ed(r), i(e, t));
  }
  /**
  Render an [output spec](https://prosemirror.net/docs/ref/#model.DOMOutputSpec) to a DOM node. If
  the spec has a hole (zero) in it, `contentDOM` will point at the
  node with the hole.
  */
  static renderSpec(e, t, r = null) {
    if (typeof t == "string")
      return { dom: e.createTextNode(t) };
    if (t.nodeType != null)
      return { dom: t };
    if (t.dom && t.dom.nodeType != null)
      return t;
    let i = t[0], o = i.indexOf(" ");
    o > 0 && (r = i.slice(0, o), i = i.slice(o + 1));
    let a, l = r ? e.createElementNS(r, i) : e.createElement(i), u = t[1], d = 1;
    if (u && typeof u == "object" && u.nodeType == null && !Array.isArray(u)) {
      d = 2;
      for (let h in u)
        if (u[h] != null) {
          let p = h.indexOf(" ");
          p > 0 ? l.setAttributeNS(h.slice(0, p), h.slice(p + 1), u[h]) : l.setAttribute(h, u[h]);
        }
    }
    for (let h = d; h < t.length; h++) {
      let p = t[h];
      if (p === 0) {
        if (h < t.length - 1 || h > d)
          throw new RangeError("Content hole must be the only child of its parent node");
        return { dom: l, contentDOM: l };
      } else {
        let { dom: g, contentDOM: v } = si.renderSpec(e, p, r);
        if (l.appendChild(g), v) {
          if (a)
            throw new RangeError("Multiple content holes");
          a = v;
        }
      }
    }
    return { dom: l, contentDOM: a };
  }
  /**
  Build a serializer using the [`toDOM`](https://prosemirror.net/docs/ref/#model.NodeSpec.toDOM)
  properties in a schema's node and mark specs.
  */
  static fromSchema(e) {
    return e.cached.domSerializer || (e.cached.domSerializer = new si(this.nodesFromSchema(e), this.marksFromSchema(e)));
  }
  /**
  Gather the serializers in a schema's node specs into an object.
  This can be useful as a base to build a custom serializer from.
  */
  static nodesFromSchema(e) {
    let t = Z0(e.nodes);
    return t.text || (t.text = (r) => r.text), t;
  }
  /**
  Gather the serializers in a schema's mark specs into an object.
  */
  static marksFromSchema(e) {
    return Z0(e.marks);
  }
}
function Z0(n) {
  let e = {};
  for (let t in n) {
    let r = n[t].spec.toDOM;
    r && (e[t] = r);
  }
  return e;
}
function Ed(n) {
  return n.document || window.document;
}
const ky = 65535, Oy = Math.pow(2, 16);
function EM(n, e) {
  return n + e * Oy;
}
function j0(n) {
  return n & ky;
}
function kM(n) {
  return (n - (n & ky)) / Oy;
}
const Ty = 1, My = 2, Yl = 4, Ry = 8;
class kf {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.pos = e, this.delInfo = t, this.recover = r;
  }
  /**
  Tells you whether the position was deleted, that is, whether the
  step removed the token on the side queried (via the `assoc`)
  argument from the document.
  */
  get deleted() {
    return (this.delInfo & Ry) > 0;
  }
  /**
  Tells you whether the token before the mapped position was deleted.
  */
  get deletedBefore() {
    return (this.delInfo & (Ty | Yl)) > 0;
  }
  /**
  True when the token after the mapped position was deleted.
  */
  get deletedAfter() {
    return (this.delInfo & (My | Yl)) > 0;
  }
  /**
  Tells whether any of the steps mapped through deletes across the
  position (including both the token before and after the
  position).
  */
  get deletedAcross() {
    return (this.delInfo & Yl) > 0;
  }
}
class Gn {
  /**
  Create a position map. The modifications to the document are
  represented as an array of numbers, in which each group of three
  represents a modified chunk as `[start, oldSize, newSize]`.
  */
  constructor(e, t = !1) {
    if (this.ranges = e, this.inverted = t, !e.length && Gn.empty)
      return Gn.empty;
  }
  /**
  @internal
  */
  recover(e) {
    let t = 0, r = j0(e);
    if (!this.inverted)
      for (let i = 0; i < r; i++)
        t += this.ranges[i * 3 + 2] - this.ranges[i * 3 + 1];
    return this.ranges[r * 3] + t + kM(e);
  }
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  map(e, t = 1) {
    return this._map(e, t, !0);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0, o = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let u = this.ranges[l] - (this.inverted ? i : 0);
      if (u > e)
        break;
      let d = this.ranges[l + o], h = this.ranges[l + a], p = u + d;
      if (e <= p) {
        let g = d ? e == u ? -1 : e == p ? 1 : t : t, v = u + i + (g < 0 ? 0 : h);
        if (r)
          return v;
        let m = e == (t < 0 ? u : p) ? null : EM(l / 3, e - u), w = e == u ? My : e == p ? Ty : Yl;
        return (t < 0 ? e != u : e != p) && (w |= Ry), new kf(v, w, m);
      }
      i += h - d;
    }
    return r ? e + i : new kf(e + i, 0, null);
  }
  /**
  @internal
  */
  touches(e, t) {
    let r = 0, i = j0(t), o = this.inverted ? 2 : 1, a = this.inverted ? 1 : 2;
    for (let l = 0; l < this.ranges.length; l += 3) {
      let u = this.ranges[l] - (this.inverted ? r : 0);
      if (u > e)
        break;
      let d = this.ranges[l + o], h = u + d;
      if (e <= h && l == i * 3)
        return !0;
      r += this.ranges[l + a] - d;
    }
    return !1;
  }
  /**
  Calls the given function on each of the changed ranges included in
  this map.
  */
  forEach(e) {
    let t = this.inverted ? 2 : 1, r = this.inverted ? 1 : 2;
    for (let i = 0, o = 0; i < this.ranges.length; i += 3) {
      let a = this.ranges[i], l = a - (this.inverted ? o : 0), u = a + (this.inverted ? 0 : o), d = this.ranges[i + t], h = this.ranges[i + r];
      e(l, l + d, u, u + h), o += h - d;
    }
  }
  /**
  Create an inverted version of this map. The result can be used to
  map positions in the post-step document to the pre-step document.
  */
  invert() {
    return new Gn(this.ranges, !this.inverted);
  }
  /**
  @internal
  */
  toString() {
    return (this.inverted ? "-" : "") + JSON.stringify(this.ranges);
  }
  /**
  Create a map that moves all positions by offset `n` (which may be
  negative). This can be useful when applying steps meant for a
  sub-document to a larger document, or vice-versa.
  */
  static offset(e) {
    return e == 0 ? Gn.empty : new Gn(e < 0 ? [0, -e, 0] : [0, 0, e]);
  }
}
Gn.empty = new Gn([]);
class ts {
  /**
  Create a new mapping with the given position maps.
  */
  constructor(e = [], t, r = 0, i = e.length) {
    this.maps = e, this.mirror = t, this.from = r, this.to = i;
  }
  /**
  Create a mapping that maps only through a part of this one.
  */
  slice(e = 0, t = this.maps.length) {
    return new ts(this.maps, this.mirror, e, t);
  }
  /**
  @internal
  */
  copy() {
    return new ts(this.maps.slice(), this.mirror && this.mirror.slice(), this.from, this.to);
  }
  /**
  Add a step map to the end of this mapping. If `mirrors` is
  given, it should be the index of the step map that is the mirror
  image of this one.
  */
  appendMap(e, t) {
    this.to = this.maps.push(e), t != null && this.setMirror(this.maps.length - 1, t);
  }
  /**
  Add all the step maps in a given mapping to this one (preserving
  mirroring information).
  */
  appendMapping(e) {
    for (let t = 0, r = this.maps.length; t < e.maps.length; t++) {
      let i = e.getMirror(t);
      this.appendMap(e.maps[t], i != null && i < t ? r + i : void 0);
    }
  }
  /**
  Finds the offset of the step map that mirrors the map at the
  given offset, in this mapping (as per the second argument to
  `appendMap`).
  */
  getMirror(e) {
    if (this.mirror) {
      for (let t = 0; t < this.mirror.length; t++)
        if (this.mirror[t] == e)
          return this.mirror[t + (t % 2 ? -1 : 1)];
    }
  }
  /**
  @internal
  */
  setMirror(e, t) {
    this.mirror || (this.mirror = []), this.mirror.push(e, t);
  }
  /**
  Append the inverse of the given mapping to this one.
  */
  appendMappingInverted(e) {
    for (let t = e.maps.length - 1, r = this.maps.length + e.maps.length; t >= 0; t--) {
      let i = e.getMirror(t);
      this.appendMap(e.maps[t].invert(), i != null && i > t ? r - i - 1 : void 0);
    }
  }
  /**
  Create an inverted version of this mapping.
  */
  invert() {
    let e = new ts();
    return e.appendMappingInverted(this), e;
  }
  /**
  Map a position through this mapping.
  */
  map(e, t = 1) {
    if (this.mirror)
      return this._map(e, t, !0);
    for (let r = this.from; r < this.to; r++)
      e = this.maps[r].map(e, t);
    return e;
  }
  /**
  Map a position through this mapping, returning a mapping
  result.
  */
  mapResult(e, t = 1) {
    return this._map(e, t, !1);
  }
  /**
  @internal
  */
  _map(e, t, r) {
    let i = 0;
    for (let o = this.from; o < this.to; o++) {
      let a = this.maps[o], l = a.mapResult(e, t);
      if (l.recover != null) {
        let u = this.getMirror(o);
        if (u != null && u > o && u < this.to) {
          o = u, e = this.maps[u].recover(l.recover);
          continue;
        }
      }
      i |= l.delInfo, e = l.pos;
    }
    return r ? e : new kf(e, i, null);
  }
}
const kd = /* @__PURE__ */ Object.create(null);
class yn {
  /**
  Get the step map that represents the changes made by this step,
  and which can be used to transform between positions in the old
  and the new document.
  */
  getMap() {
    return Gn.empty;
  }
  /**
  Try to merge this step with another one, to be applied directly
  after it. Returns the merged step when possible, null if the
  steps can't be merged.
  */
  merge(e) {
    return null;
  }
  /**
  Deserialize a step from its JSON representation. Will call
  through to the step class' own implementation of this method.
  */
  static fromJSON(e, t) {
    if (!t || !t.stepType)
      throw new RangeError("Invalid input for Step.fromJSON");
    let r = kd[t.stepType];
    if (!r)
      throw new RangeError(`No step type ${t.stepType} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to serialize steps to JSON, each step needs a string
  ID to attach to its JSON representation. Use this method to
  register an ID for your step classes. Try to pick something
  that's unlikely to clash with steps from other modules.
  */
  static jsonID(e, t) {
    if (e in kd)
      throw new RangeError("Duplicate use of step JSON ID " + e);
    return kd[e] = t, t.prototype.jsonID = e, t;
  }
}
class Vt {
  /**
  @internal
  */
  constructor(e, t) {
    this.doc = e, this.failed = t;
  }
  /**
  Create a successful step result.
  */
  static ok(e) {
    return new Vt(e, null);
  }
  /**
  Create a failed step result.
  */
  static fail(e) {
    return new Vt(null, e);
  }
  /**
  Call [`Node.replace`](https://prosemirror.net/docs/ref/#model.Node.replace) with the given
  arguments. Create a successful result if it succeeds, and a
  failed one if it throws a `ReplaceError`.
  */
  static fromReplace(e, t, r, i) {
    try {
      return Vt.ok(e.replace(t, r, i));
    } catch (o) {
      if (o instanceof ac)
        return Vt.fail(o.message);
      throw o;
    }
  }
}
function lh(n, e, t) {
  let r = [];
  for (let i = 0; i < n.childCount; i++) {
    let o = n.child(i);
    o.content.size && (o = o.copy(lh(o.content, e, o))), o.isInline && (o = e(o, t, i)), r.push(o);
  }
  return ue.fromArray(r);
}
class Ii extends yn {
  /**
  Create a mark step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = e.resolve(this.from), i = r.node(r.sharedDepth(this.to)), o = new ke(lh(t.content, (a, l) => !a.isAtom || !l.type.allowsMarkType(this.mark.type) ? a : a.mark(this.mark.addToSet(a.marks)), i), t.openStart, t.openEnd);
    return Vt.fromReplace(e, this.from, this.to, o);
  }
  invert() {
    return new Fr(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Ii(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Ii && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Ii(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "addMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for AddMarkStep.fromJSON");
    return new Ii(t.from, t.to, e.markFromJSON(t.mark));
  }
}
yn.jsonID("addMark", Ii);
class Fr extends yn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t, r) {
    super(), this.from = e, this.to = t, this.mark = r;
  }
  apply(e) {
    let t = e.slice(this.from, this.to), r = new ke(lh(t.content, (i) => i.mark(this.mark.removeFromSet(i.marks)), e), t.openStart, t.openEnd);
    return Vt.fromReplace(e, this.from, this.to, r);
  }
  invert() {
    return new Ii(this.from, this.to, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deleted && r.deleted || t.pos >= r.pos ? null : new Fr(t.pos, r.pos, this.mark);
  }
  merge(e) {
    return e instanceof Fr && e.mark.eq(this.mark) && this.from <= e.to && this.to >= e.from ? new Fr(Math.min(this.from, e.from), Math.max(this.to, e.to), this.mark) : null;
  }
  toJSON() {
    return {
      stepType: "removeMark",
      mark: this.mark.toJSON(),
      from: this.from,
      to: this.to
    };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for RemoveMarkStep.fromJSON");
    return new Fr(t.from, t.to, e.markFromJSON(t.mark));
  }
}
yn.jsonID("removeMark", Fr);
class Ai extends yn {
  /**
  Create a node mark step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Vt.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.addToSet(t.marks));
    return Vt.fromReplace(e, this.pos, this.pos + 1, new ke(ue.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    if (t) {
      let r = this.mark.addToSet(t.marks);
      if (r.length == t.marks.length) {
        for (let i = 0; i < t.marks.length; i++)
          if (!t.marks[i].isInSet(r))
            return new Ai(this.pos, t.marks[i]);
        return new Ai(this.pos, this.mark);
      }
    }
    return new as(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new Ai(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "addNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for AddNodeMarkStep.fromJSON");
    return new Ai(t.pos, e.markFromJSON(t.mark));
  }
}
yn.jsonID("addNodeMark", Ai);
class as extends yn {
  /**
  Create a mark-removing step.
  */
  constructor(e, t) {
    super(), this.pos = e, this.mark = t;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Vt.fail("No node at mark step's position");
    let r = t.type.create(t.attrs, null, this.mark.removeFromSet(t.marks));
    return Vt.fromReplace(e, this.pos, this.pos + 1, new ke(ue.from(r), 0, t.isLeaf ? 0 : 1));
  }
  invert(e) {
    let t = e.nodeAt(this.pos);
    return !t || !this.mark.isInSet(t.marks) ? this : new Ai(this.pos, this.mark);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new as(t.pos, this.mark);
  }
  toJSON() {
    return { stepType: "removeNodeMark", pos: this.pos, mark: this.mark.toJSON() };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for RemoveNodeMarkStep.fromJSON");
    return new as(t.pos, e.markFromJSON(t.mark));
  }
}
yn.jsonID("removeNodeMark", as);
class hn extends yn {
  /**
  The given `slice` should fit the 'gap' between `from` and
  `to`—the depths must line up, and the surrounding nodes must be
  able to be joined with the open sides of the slice. When
  `structure` is true, the step will fail if the content between
  from and to is not just a sequence of closing and then opening
  tokens (this is to guard against rebased replace steps
  overwriting something they weren't supposed to).
  */
  constructor(e, t, r, i = !1) {
    super(), this.from = e, this.to = t, this.slice = r, this.structure = i;
  }
  apply(e) {
    return this.structure && Of(e, this.from, this.to) ? Vt.fail("Structure replace would overwrite content") : Vt.fromReplace(e, this.from, this.to, this.slice);
  }
  getMap() {
    return new Gn([this.from, this.to - this.from, this.slice.size]);
  }
  invert(e) {
    return new hn(this.from, this.from + this.slice.size, e.slice(this.from, this.to));
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1);
    return t.deletedAcross && r.deletedAcross ? null : new hn(t.pos, Math.max(t.pos, r.pos), this.slice);
  }
  merge(e) {
    if (!(e instanceof hn) || e.structure || this.structure)
      return null;
    if (this.from + this.slice.size == e.from && !this.slice.openEnd && !e.slice.openStart) {
      let t = this.slice.size + e.slice.size == 0 ? ke.empty : new ke(this.slice.content.append(e.slice.content), this.slice.openStart, e.slice.openEnd);
      return new hn(this.from, this.to + (e.to - e.from), t, this.structure);
    } else if (e.to == this.from && !this.slice.openStart && !e.slice.openEnd) {
      let t = this.slice.size + e.slice.size == 0 ? ke.empty : new ke(e.slice.content.append(this.slice.content), e.slice.openStart, this.slice.openEnd);
      return new hn(e.from, this.to, t, this.structure);
    } else
      return null;
  }
  toJSON() {
    let e = { stepType: "replace", from: this.from, to: this.to };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number")
      throw new RangeError("Invalid input for ReplaceStep.fromJSON");
    return new hn(t.from, t.to, ke.fromJSON(e, t.slice), !!t.structure);
  }
}
yn.jsonID("replace", hn);
class Xn extends yn {
  /**
  Create a replace-around step with the given range and gap.
  `insert` should be the point in the slice into which the content
  of the gap should be moved. `structure` has the same meaning as
  it has in the [`ReplaceStep`](https://prosemirror.net/docs/ref/#transform.ReplaceStep) class.
  */
  constructor(e, t, r, i, o, a, l = !1) {
    super(), this.from = e, this.to = t, this.gapFrom = r, this.gapTo = i, this.slice = o, this.insert = a, this.structure = l;
  }
  apply(e) {
    if (this.structure && (Of(e, this.from, this.gapFrom) || Of(e, this.gapTo, this.to)))
      return Vt.fail("Structure gap-replace would overwrite content");
    let t = e.slice(this.gapFrom, this.gapTo);
    if (t.openStart || t.openEnd)
      return Vt.fail("Gap is not a flat range");
    let r = this.slice.insertAt(this.insert, t.content);
    return r ? Vt.fromReplace(e, this.from, this.to, r) : Vt.fail("Content does not fit in gap");
  }
  getMap() {
    return new Gn([
      this.from,
      this.gapFrom - this.from,
      this.insert,
      this.gapTo,
      this.to - this.gapTo,
      this.slice.size - this.insert
    ]);
  }
  invert(e) {
    let t = this.gapTo - this.gapFrom;
    return new Xn(this.from, this.from + this.slice.size + t, this.from + this.insert, this.from + this.insert + t, e.slice(this.from, this.to).removeBetween(this.gapFrom - this.from, this.gapTo - this.from), this.gapFrom - this.from, this.structure);
  }
  map(e) {
    let t = e.mapResult(this.from, 1), r = e.mapResult(this.to, -1), i = e.map(this.gapFrom, -1), o = e.map(this.gapTo, 1);
    return t.deletedAcross && r.deletedAcross || i < t.pos || o > r.pos ? null : new Xn(t.pos, r.pos, i, o, this.slice, this.insert, this.structure);
  }
  toJSON() {
    let e = {
      stepType: "replaceAround",
      from: this.from,
      to: this.to,
      gapFrom: this.gapFrom,
      gapTo: this.gapTo,
      insert: this.insert
    };
    return this.slice.size && (e.slice = this.slice.toJSON()), this.structure && (e.structure = !0), e;
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.from != "number" || typeof t.to != "number" || typeof t.gapFrom != "number" || typeof t.gapTo != "number" || typeof t.insert != "number")
      throw new RangeError("Invalid input for ReplaceAroundStep.fromJSON");
    return new Xn(t.from, t.to, t.gapFrom, t.gapTo, ke.fromJSON(e, t.slice), t.insert, !!t.structure);
  }
}
yn.jsonID("replaceAround", Xn);
function Of(n, e, t) {
  let r = n.resolve(e), i = t - e, o = r.depth;
  for (; i > 0 && o > 0 && r.indexAfter(o) == r.node(o).childCount; )
    o--, i--;
  if (i > 0) {
    let a = r.node(o).maybeChild(r.indexAfter(o));
    for (; i > 0; ) {
      if (!a || a.isLeaf)
        return !0;
      a = a.firstChild, i--;
    }
  }
  return !1;
}
function OM(n, e, t, r) {
  let i = [], o = [], a, l;
  n.doc.nodesBetween(e, t, (u, d, h) => {
    if (!u.isInline)
      return;
    let p = u.marks;
    if (!r.isInSet(p) && h.type.allowsMarkType(r.type)) {
      let g = Math.max(d, e), v = Math.min(d + u.nodeSize, t), m = r.addToSet(p);
      for (let w = 0; w < p.length; w++)
        p[w].isInSet(m) || (a && a.to == g && a.mark.eq(p[w]) ? a.to = v : i.push(a = new Fr(g, v, p[w])));
      l && l.to == g ? l.to = v : o.push(l = new Ii(g, v, r));
    }
  }), i.forEach((u) => n.step(u)), o.forEach((u) => n.step(u));
}
function TM(n, e, t, r) {
  let i = [], o = 0;
  n.doc.nodesBetween(e, t, (a, l) => {
    if (!a.isInline)
      return;
    o++;
    let u = null;
    if (r instanceof $c) {
      let d = a.marks, h;
      for (; h = r.isInSet(d); )
        (u || (u = [])).push(h), d = h.removeFromSet(d);
    } else
      r ? r.isInSet(a.marks) && (u = [r]) : u = a.marks;
    if (u && u.length) {
      let d = Math.min(l + a.nodeSize, t);
      for (let h = 0; h < u.length; h++) {
        let p = u[h], g;
        for (let v = 0; v < i.length; v++) {
          let m = i[v];
          m.step == o - 1 && p.eq(i[v].style) && (g = m);
        }
        g ? (g.to = d, g.step = o) : i.push({ style: p, from: Math.max(l, e), to: d, step: o });
      }
    }
  }), i.forEach((a) => n.step(new Fr(a.from, a.to, a.style)));
}
function MM(n, e, t, r = t.contentMatch) {
  let i = n.doc.nodeAt(e), o = [], a = e + 1;
  for (let l = 0; l < i.childCount; l++) {
    let u = i.child(l), d = a + u.nodeSize, h = r.matchType(u.type);
    if (!h)
      o.push(new hn(a, d, ke.empty));
    else {
      r = h;
      for (let p = 0; p < u.marks.length; p++)
        t.allowsMarkType(u.marks[p].type) || n.step(new Fr(a, d, u.marks[p]));
      if (u.isText && !t.spec.code) {
        let p, g = /\r?\n|\r/g, v;
        for (; p = g.exec(u.text); )
          v || (v = new ke(ue.from(t.schema.text(" ", t.allowedMarks(u.marks))), 0, 0)), o.push(new hn(a + p.index, a + p.index + p[0].length, v));
      }
    }
    a = d;
  }
  if (!r.validEnd) {
    let l = r.fillBefore(ue.empty, !0);
    n.replace(a, a, new ke(l, 0, 0));
  }
  for (let l = o.length - 1; l >= 0; l--)
    n.step(o[l]);
}
function RM(n, e, t) {
  return (e == 0 || n.canReplace(e, n.childCount)) && (t == n.childCount || n.canReplace(0, t));
}
function Uc(n) {
  let t = n.parent.content.cutByIndex(n.startIndex, n.endIndex);
  for (let r = n.depth; ; --r) {
    let i = n.$from.node(r), o = n.$from.index(r), a = n.$to.indexAfter(r);
    if (r < n.depth && i.canReplace(o, a, t))
      return r;
    if (r == 0 || i.type.spec.isolating || !RM(i, o, a))
      break;
  }
  return null;
}
function DM(n, e, t) {
  let { $from: r, $to: i, depth: o } = e, a = r.before(o + 1), l = i.after(o + 1), u = a, d = l, h = ue.empty, p = 0;
  for (let m = o, w = !1; m > t; m--)
    w || r.index(m) > 0 ? (w = !0, h = ue.from(r.node(m).copy(h)), p++) : u--;
  let g = ue.empty, v = 0;
  for (let m = o, w = !1; m > t; m--)
    w || i.after(m + 1) < i.end(m) ? (w = !0, g = ue.from(i.node(m).copy(g)), v++) : d++;
  n.step(new Xn(u, d, a, l, new ke(h.append(g), p, v), h.size - p, !0));
}
function IM(n, e, t = null, r = n) {
  let i = AM(n, e), o = i && LM(r, e);
  return o ? i.map(Y0).concat({ type: e, attrs: t }).concat(o.map(Y0)) : null;
}
function Y0(n) {
  return { type: n, attrs: null };
}
function AM(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, o = t.contentMatchAt(r).findWrapping(e);
  if (!o)
    return null;
  let a = o.length ? o[0] : e;
  return t.canReplaceWith(r, i, a) ? o : null;
}
function LM(n, e) {
  let { parent: t, startIndex: r, endIndex: i } = n, o = t.child(r), a = e.contentMatch.findWrapping(o.type);
  if (!a)
    return null;
  let u = (a.length ? a[a.length - 1] : e).contentMatch;
  for (let d = r; u && d < i; d++)
    u = u.matchType(t.child(d).type);
  return !u || !u.validEnd ? null : a;
}
function PM(n, e, t) {
  let r = ue.empty;
  for (let a = t.length - 1; a >= 0; a--) {
    if (r.size) {
      let l = t[a].type.contentMatch.matchFragment(r);
      if (!l || !l.validEnd)
        throw new RangeError("Wrapper type given to Transform.wrap does not form valid content of its parent wrapper");
    }
    r = ue.from(t[a].type.create(t[a].attrs, r));
  }
  let i = e.start, o = e.end;
  n.step(new Xn(i, o, i, o, new ke(r, 0, 0), t.length, !0));
}
function _M(n, e, t, r, i) {
  if (!r.isTextblock)
    throw new RangeError("Type given to setBlockType should be a textblock");
  let o = n.steps.length;
  n.doc.nodesBetween(e, t, (a, l) => {
    if (a.isTextblock && !a.hasMarkup(r, i) && NM(n.doc, n.mapping.slice(o).map(l), r)) {
      n.clearIncompatible(n.mapping.slice(o).map(l, 1), r);
      let u = n.mapping.slice(o), d = u.map(l, 1), h = u.map(l + a.nodeSize, 1);
      return n.step(new Xn(d, h, d + 1, h - 1, new ke(ue.from(r.create(i, null, a.marks)), 0, 0), 1, !0)), !1;
    }
  });
}
function NM(n, e, t) {
  let r = n.resolve(e), i = r.index();
  return r.parent.canReplaceWith(i, i + 1, t);
}
function zM(n, e, t, r, i) {
  let o = n.doc.nodeAt(e);
  if (!o)
    throw new RangeError("No node at given position");
  t || (t = o.type);
  let a = t.create(r, null, i || o.marks);
  if (o.isLeaf)
    return n.replaceWith(e, e + o.nodeSize, a);
  if (!t.validContent(o.content))
    throw new RangeError("Invalid content for node type " + t.name);
  n.step(new Xn(e, e + o.nodeSize, e + 1, e + o.nodeSize - 1, new ke(ue.from(a), 0, 0), 1, !0));
}
function vo(n, e, t = 1, r) {
  let i = n.resolve(e), o = i.depth - t, a = r && r[r.length - 1] || i.parent;
  if (o < 0 || i.parent.type.spec.isolating || !i.parent.canReplace(i.index(), i.parent.childCount) || !a.type.validContent(i.parent.content.cutByIndex(i.index(), i.parent.childCount)))
    return !1;
  for (let d = i.depth - 1, h = t - 2; d > o; d--, h--) {
    let p = i.node(d), g = i.index(d);
    if (p.type.spec.isolating)
      return !1;
    let v = p.content.cutByIndex(g, p.childCount), m = r && r[h + 1];
    m && (v = v.replaceChild(0, m.type.create(m.attrs)));
    let w = r && r[h] || p;
    if (!p.canReplace(g + 1, p.childCount) || !w.type.validContent(v))
      return !1;
  }
  let l = i.indexAfter(o), u = r && r[0];
  return i.node(o).canReplaceWith(l, l, u ? u.type : i.node(o + 1).type);
}
function BM(n, e, t = 1, r) {
  let i = n.doc.resolve(e), o = ue.empty, a = ue.empty;
  for (let l = i.depth, u = i.depth - t, d = t - 1; l > u; l--, d--) {
    o = ue.from(i.node(l).copy(o));
    let h = r && r[d];
    a = ue.from(h ? h.type.create(h.attrs, a) : i.node(l).copy(a));
  }
  n.step(new hn(e, e, new ke(o.append(a), t, t), !0));
}
function Ta(n, e) {
  let t = n.resolve(e), r = t.index();
  return Dy(t.nodeBefore, t.nodeAfter) && t.parent.canReplace(r, r + 1);
}
function Dy(n, e) {
  return !!(n && e && !n.isLeaf && n.canAppend(e));
}
function Iy(n, e, t = -1) {
  let r = n.resolve(e);
  for (let i = r.depth; ; i--) {
    let o, a, l = r.index(i);
    if (i == r.depth ? (o = r.nodeBefore, a = r.nodeAfter) : t > 0 ? (o = r.node(i + 1), l++, a = r.node(i).maybeChild(l)) : (o = r.node(i).maybeChild(l - 1), a = r.node(i + 1)), o && !o.isTextblock && Dy(o, a) && r.node(i).canReplace(l, l + 1))
      return e;
    if (i == 0)
      break;
    e = t < 0 ? r.before(i) : r.after(i);
  }
}
function FM(n, e, t) {
  let r = new hn(e - t, e + t, ke.empty, !0);
  n.step(r);
}
function VM(n, e, t) {
  let r = n.resolve(e);
  if (r.parent.canReplaceWith(r.index(), r.index(), t))
    return e;
  if (r.parentOffset == 0)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.index(i);
      if (r.node(i).canReplaceWith(o, o, t))
        return r.before(i + 1);
      if (o > 0)
        return null;
    }
  if (r.parentOffset == r.parent.content.size)
    for (let i = r.depth - 1; i >= 0; i--) {
      let o = r.indexAfter(i);
      if (r.node(i).canReplaceWith(o, o, t))
        return r.after(i + 1);
      if (o < r.node(i).childCount)
        return null;
    }
  return null;
}
function WM(n, e, t) {
  let r = n.resolve(e);
  if (!t.content.size)
    return e;
  let i = t.content;
  for (let o = 0; o < t.openStart; o++)
    i = i.firstChild.content;
  for (let o = 1; o <= (t.openStart == 0 && t.size ? 2 : 1); o++)
    for (let a = r.depth; a >= 0; a--) {
      let l = a == r.depth ? 0 : r.pos <= (r.start(a + 1) + r.end(a + 1)) / 2 ? -1 : 1, u = r.index(a) + (l > 0 ? 1 : 0), d = r.node(a), h = !1;
      if (o == 1)
        h = d.canReplace(u, u, i);
      else {
        let p = d.contentMatchAt(u).findWrapping(i.firstChild.type);
        h = p && d.canReplaceWith(u, u, p[0]);
      }
      if (h)
        return l == 0 ? r.pos : l < 0 ? r.before(a + 1) : r.after(a + 1);
    }
  return null;
}
function ch(n, e, t = e, r = ke.empty) {
  if (e == t && !r.size)
    return null;
  let i = n.resolve(e), o = n.resolve(t);
  return Ay(i, o, r) ? new hn(e, t, r) : new HM(i, o, r).fit();
}
function Ay(n, e, t) {
  return !t.openStart && !t.openEnd && n.start() == e.start() && n.parent.canReplace(n.index(), e.index(), t.content);
}
class HM {
  constructor(e, t, r) {
    this.$from = e, this.$to = t, this.unplaced = r, this.frontier = [], this.placed = ue.empty;
    for (let i = 0; i <= e.depth; i++) {
      let o = e.node(i);
      this.frontier.push({
        type: o.type,
        match: o.contentMatchAt(e.indexAfter(i))
      });
    }
    for (let i = e.depth; i > 0; i--)
      this.placed = ue.from(e.node(i).copy(this.placed));
  }
  get depth() {
    return this.frontier.length - 1;
  }
  fit() {
    for (; this.unplaced.size; ) {
      let d = this.findFittable();
      d ? this.placeNodes(d) : this.openMore() || this.dropNode();
    }
    let e = this.mustMoveInline(), t = this.placed.size - this.depth - this.$from.depth, r = this.$from, i = this.close(e < 0 ? this.$to : r.doc.resolve(e));
    if (!i)
      return null;
    let o = this.placed, a = r.depth, l = i.depth;
    for (; a && l && o.childCount == 1; )
      o = o.firstChild.content, a--, l--;
    let u = new ke(o, a, l);
    return e > -1 ? new Xn(r.pos, e, this.$to.pos, this.$to.end(), u, t) : u.size || r.pos != this.$to.pos ? new hn(r.pos, i.pos, u) : null;
  }
  // Find a position on the start spine of `this.unplaced` that has
  // content that can be moved somewhere on the frontier. Returns two
  // depths, one for the slice and one for the frontier.
  findFittable() {
    let e = this.unplaced.openStart;
    for (let t = this.unplaced.content, r = 0, i = this.unplaced.openEnd; r < e; r++) {
      let o = t.firstChild;
      if (t.childCount > 1 && (i = 0), o.type.spec.isolating && i <= r) {
        e = r;
        break;
      }
      t = o.content;
    }
    for (let t = 1; t <= 2; t++)
      for (let r = t == 1 ? e : this.unplaced.openStart; r >= 0; r--) {
        let i, o = null;
        r ? (o = Od(this.unplaced.content, r - 1).firstChild, i = o.content) : i = this.unplaced.content;
        let a = i.firstChild;
        for (let l = this.depth; l >= 0; l--) {
          let { type: u, match: d } = this.frontier[l], h, p = null;
          if (t == 1 && (a ? d.matchType(a.type) || (p = d.fillBefore(ue.from(a), !1)) : o && u.compatibleContent(o.type)))
            return { sliceDepth: r, frontierDepth: l, parent: o, inject: p };
          if (t == 2 && a && (h = d.findWrapping(a.type)))
            return { sliceDepth: r, frontierDepth: l, parent: o, wrap: h };
          if (o && d.matchType(o.type))
            break;
        }
      }
  }
  openMore() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Od(e, t);
    return !i.childCount || i.firstChild.isLeaf ? !1 : (this.unplaced = new ke(e, t + 1, Math.max(r, i.size + t >= e.size - r ? t + 1 : 0)), !0);
  }
  dropNode() {
    let { content: e, openStart: t, openEnd: r } = this.unplaced, i = Od(e, t);
    if (i.childCount <= 1 && t > 0) {
      let o = e.size - t <= t + i.size;
      this.unplaced = new ke($s(e, t - 1, 1), t - 1, o ? t - 1 : r);
    } else
      this.unplaced = new ke($s(e, t, 1), t, r);
  }
  // Move content from the unplaced slice at `sliceDepth` to the
  // frontier node at `frontierDepth`. Close that frontier node when
  // applicable.
  placeNodes({ sliceDepth: e, frontierDepth: t, parent: r, inject: i, wrap: o }) {
    for (; this.depth > t; )
      this.closeFrontierNode();
    if (o)
      for (let w = 0; w < o.length; w++)
        this.openFrontierNode(o[w]);
    let a = this.unplaced, l = r ? r.content : a.content, u = a.openStart - e, d = 0, h = [], { match: p, type: g } = this.frontier[t];
    if (i) {
      for (let w = 0; w < i.childCount; w++)
        h.push(i.child(w));
      p = p.matchFragment(i);
    }
    let v = l.size + e - (a.content.size - a.openEnd);
    for (; d < l.childCount; ) {
      let w = l.child(d), b = p.matchType(w.type);
      if (!b)
        break;
      d++, (d > 1 || u == 0 || w.content.size) && (p = b, h.push(Ly(w.mark(g.allowedMarks(w.marks)), d == 1 ? u : 0, d == l.childCount ? v : -1)));
    }
    let m = d == l.childCount;
    m || (v = -1), this.placed = Us(this.placed, t, ue.from(h)), this.frontier[t].match = p, m && v < 0 && r && r.type == this.frontier[this.depth].type && this.frontier.length > 1 && this.closeFrontierNode();
    for (let w = 0, b = l; w < v; w++) {
      let C = b.lastChild;
      this.frontier.push({ type: C.type, match: C.contentMatchAt(C.childCount) }), b = C.content;
    }
    this.unplaced = m ? e == 0 ? ke.empty : new ke($s(a.content, e - 1, 1), e - 1, v < 0 ? a.openEnd : e - 1) : new ke($s(a.content, e, d), a.openStart, a.openEnd);
  }
  mustMoveInline() {
    if (!this.$to.parent.isTextblock)
      return -1;
    let e = this.frontier[this.depth], t;
    if (!e.type.isTextblock || !Td(this.$to, this.$to.depth, e.type, e.match, !1) || this.$to.depth == this.depth && (t = this.findCloseLevel(this.$to)) && t.depth == this.depth)
      return -1;
    let { depth: r } = this.$to, i = this.$to.after(r);
    for (; r > 1 && i == this.$to.end(--r); )
      ++i;
    return i;
  }
  findCloseLevel(e) {
    e:
      for (let t = Math.min(this.depth, e.depth); t >= 0; t--) {
        let { match: r, type: i } = this.frontier[t], o = t < e.depth && e.end(t + 1) == e.pos + (e.depth - (t + 1)), a = Td(e, t, i, r, o);
        if (a) {
          for (let l = t - 1; l >= 0; l--) {
            let { match: u, type: d } = this.frontier[l], h = Td(e, l, d, u, !0);
            if (!h || h.childCount)
              continue e;
          }
          return { depth: t, fit: a, move: o ? e.doc.resolve(e.after(t + 1)) : e };
        }
      }
  }
  close(e) {
    let t = this.findCloseLevel(e);
    if (!t)
      return null;
    for (; this.depth > t.depth; )
      this.closeFrontierNode();
    t.fit.childCount && (this.placed = Us(this.placed, t.depth, t.fit)), e = t.move;
    for (let r = t.depth + 1; r <= e.depth; r++) {
      let i = e.node(r), o = i.type.contentMatch.fillBefore(i.content, !0, e.index(r));
      this.openFrontierNode(i.type, i.attrs, o);
    }
    return e;
  }
  openFrontierNode(e, t = null, r) {
    let i = this.frontier[this.depth];
    i.match = i.match.matchType(e), this.placed = Us(this.placed, this.depth, ue.from(e.create(t, r))), this.frontier.push({ type: e, match: e.contentMatch });
  }
  closeFrontierNode() {
    let t = this.frontier.pop().match.fillBefore(ue.empty, !0);
    t.childCount && (this.placed = Us(this.placed, this.frontier.length, t));
  }
}
function $s(n, e, t) {
  return e == 0 ? n.cutByIndex(t, n.childCount) : n.replaceChild(0, n.firstChild.copy($s(n.firstChild.content, e - 1, t)));
}
function Us(n, e, t) {
  return e == 0 ? n.append(t) : n.replaceChild(n.childCount - 1, n.lastChild.copy(Us(n.lastChild.content, e - 1, t)));
}
function Od(n, e) {
  for (let t = 0; t < e; t++)
    n = n.firstChild.content;
  return n;
}
function Ly(n, e, t) {
  if (e <= 0)
    return n;
  let r = n.content;
  return e > 1 && (r = r.replaceChild(0, Ly(r.firstChild, e - 1, r.childCount == 1 ? t - 1 : 0))), e > 0 && (r = n.type.contentMatch.fillBefore(r).append(r), t <= 0 && (r = r.append(n.type.contentMatch.matchFragment(r).fillBefore(ue.empty, !0)))), n.copy(r);
}
function Td(n, e, t, r, i) {
  let o = n.node(e), a = i ? n.indexAfter(e) : n.index(e);
  if (a == o.childCount && !t.compatibleContent(o.type))
    return null;
  let l = r.fillBefore(o.content, !0, a);
  return l && !$M(t, o.content, a) ? l : null;
}
function $M(n, e, t) {
  for (let r = t; r < e.childCount; r++)
    if (!n.allowsMarks(e.child(r).marks))
      return !0;
  return !1;
}
function UM(n) {
  return n.spec.defining || n.spec.definingForContent;
}
function ZM(n, e, t, r) {
  if (!r.size)
    return n.deleteRange(e, t);
  let i = n.doc.resolve(e), o = n.doc.resolve(t);
  if (Ay(i, o, r))
    return n.step(new hn(e, t, r));
  let a = _y(i, n.doc.resolve(t));
  a[a.length - 1] == 0 && a.pop();
  let l = -(i.depth + 1);
  a.unshift(l);
  for (let g = i.depth, v = i.pos - 1; g > 0; g--, v--) {
    let m = i.node(g).type.spec;
    if (m.defining || m.definingAsContext || m.isolating)
      break;
    a.indexOf(g) > -1 ? l = g : i.before(g) == v && a.splice(1, 0, -g);
  }
  let u = a.indexOf(l), d = [], h = r.openStart;
  for (let g = r.content, v = 0; ; v++) {
    let m = g.firstChild;
    if (d.push(m), v == r.openStart)
      break;
    g = m.content;
  }
  for (let g = h - 1; g >= 0; g--) {
    let v = d[g], m = UM(v.type);
    if (m && !v.sameMarkup(i.node(Math.abs(l) - 1)))
      h = g;
    else if (m || !v.type.isTextblock)
      break;
  }
  for (let g = r.openStart; g >= 0; g--) {
    let v = (g + h + 1) % (r.openStart + 1), m = d[v];
    if (m)
      for (let w = 0; w < a.length; w++) {
        let b = a[(w + u) % a.length], C = !0;
        b < 0 && (C = !1, b = -b);
        let M = i.node(b - 1), k = i.index(b - 1);
        if (M.canReplaceWith(k, k, m.type, m.marks))
          return n.replace(i.before(b), C ? o.after(b) : t, new ke(Py(r.content, 0, r.openStart, v), v, r.openEnd));
      }
  }
  let p = n.steps.length;
  for (let g = a.length - 1; g >= 0 && (n.replace(e, t, r), !(n.steps.length > p)); g--) {
    let v = a[g];
    v < 0 || (e = i.before(v), t = o.after(v));
  }
}
function Py(n, e, t, r, i) {
  if (e < t) {
    let o = n.firstChild;
    n = n.replaceChild(0, o.copy(Py(o.content, e + 1, t, r, o)));
  }
  if (e > r) {
    let o = i.contentMatchAt(0), a = o.fillBefore(n).append(n);
    n = a.append(o.matchFragment(a).fillBefore(ue.empty, !0));
  }
  return n;
}
function jM(n, e, t, r) {
  if (!r.isInline && e == t && n.doc.resolve(e).parent.content.size) {
    let i = VM(n.doc, e, r.type);
    i != null && (e = t = i);
  }
  n.replaceRange(e, t, new ke(ue.from(r), 0, 0));
}
function YM(n, e, t) {
  let r = n.doc.resolve(e), i = n.doc.resolve(t), o = _y(r, i);
  for (let a = 0; a < o.length; a++) {
    let l = o[a], u = a == o.length - 1;
    if (u && l == 0 || r.node(l).type.contentMatch.validEnd)
      return n.delete(r.start(l), i.end(l));
    if (l > 0 && (u || r.node(l - 1).canReplace(r.index(l - 1), i.indexAfter(l - 1))))
      return n.delete(r.before(l), i.after(l));
  }
  for (let a = 1; a <= r.depth && a <= i.depth; a++)
    if (e - r.start(a) == r.depth - a && t > r.end(a) && i.end(a) - t != i.depth - a)
      return n.delete(r.before(a), t);
  n.delete(e, t);
}
function _y(n, e) {
  let t = [], r = Math.min(n.depth, e.depth);
  for (let i = r; i >= 0; i--) {
    let o = n.start(i);
    if (o < n.pos - (n.depth - i) || e.end(i) > e.pos + (e.depth - i) || n.node(i).type.spec.isolating || e.node(i).type.spec.isolating)
      break;
    (o == e.start(i) || i == n.depth && i == e.depth && n.parent.inlineContent && e.parent.inlineContent && i && e.start(i - 1) == o - 1) && t.push(i);
  }
  return t;
}
class ns extends yn {
  /**
  Construct an attribute step.
  */
  constructor(e, t, r) {
    super(), this.pos = e, this.attr = t, this.value = r;
  }
  apply(e) {
    let t = e.nodeAt(this.pos);
    if (!t)
      return Vt.fail("No node at attribute step's position");
    let r = /* @__PURE__ */ Object.create(null);
    for (let o in t.attrs)
      r[o] = t.attrs[o];
    r[this.attr] = this.value;
    let i = t.type.create(r, null, t.marks);
    return Vt.fromReplace(e, this.pos, this.pos + 1, new ke(ue.from(i), 0, t.isLeaf ? 0 : 1));
  }
  getMap() {
    return Gn.empty;
  }
  invert(e) {
    return new ns(this.pos, this.attr, e.nodeAt(this.pos).attrs[this.attr]);
  }
  map(e) {
    let t = e.mapResult(this.pos, 1);
    return t.deletedAfter ? null : new ns(t.pos, this.attr, this.value);
  }
  toJSON() {
    return { stepType: "attr", pos: this.pos, attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.pos != "number" || typeof t.attr != "string")
      throw new RangeError("Invalid input for AttrStep.fromJSON");
    return new ns(t.pos, t.attr, t.value);
  }
}
yn.jsonID("attr", ns);
class fa extends yn {
  /**
  Construct an attribute step.
  */
  constructor(e, t) {
    super(), this.attr = e, this.value = t;
  }
  apply(e) {
    let t = /* @__PURE__ */ Object.create(null);
    for (let i in e.attrs)
      t[i] = e.attrs[i];
    t[this.attr] = this.value;
    let r = e.type.create(t, e.content, e.marks);
    return Vt.ok(r);
  }
  getMap() {
    return Gn.empty;
  }
  invert(e) {
    return new fa(this.attr, e.attrs[this.attr]);
  }
  map(e) {
    return this;
  }
  toJSON() {
    return { stepType: "docAttr", attr: this.attr, value: this.value };
  }
  static fromJSON(e, t) {
    if (typeof t.attr != "string")
      throw new RangeError("Invalid input for DocAttrStep.fromJSON");
    return new fa(t.attr, t.value);
  }
}
yn.jsonID("docAttr", fa);
let ls = class extends Error {
};
ls = function n(e) {
  let t = Error.call(this, e);
  return t.__proto__ = n.prototype, t;
};
ls.prototype = Object.create(Error.prototype);
ls.prototype.constructor = ls;
ls.prototype.name = "TransformError";
class qM {
  /**
  Create a transform that starts with the given document.
  */
  constructor(e) {
    this.doc = e, this.steps = [], this.docs = [], this.mapping = new ts();
  }
  /**
  The starting document.
  */
  get before() {
    return this.docs.length ? this.docs[0] : this.doc;
  }
  /**
  Apply a new step in this transform, saving the result. Throws an
  error when the step fails.
  */
  step(e) {
    let t = this.maybeStep(e);
    if (t.failed)
      throw new ls(t.failed);
    return this;
  }
  /**
  Try to apply a step in this transformation, ignoring it if it
  fails. Returns the step result.
  */
  maybeStep(e) {
    let t = e.apply(this.doc);
    return t.failed || this.addStep(e, t.doc), t;
  }
  /**
  True when the document has been changed (when there are any
  steps).
  */
  get docChanged() {
    return this.steps.length > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    this.docs.push(this.doc), this.steps.push(e), this.mapping.appendMap(e.getMap()), this.doc = t;
  }
  /**
  Replace the part of the document between `from` and `to` with the
  given `slice`.
  */
  replace(e, t = e, r = ke.empty) {
    let i = ch(this.doc, e, t, r);
    return i && this.step(i), this;
  }
  /**
  Replace the given range with the given content, which may be a
  fragment, node, or array of nodes.
  */
  replaceWith(e, t, r) {
    return this.replace(e, t, new ke(ue.from(r), 0, 0));
  }
  /**
  Delete the content between the given positions.
  */
  delete(e, t) {
    return this.replace(e, t, ke.empty);
  }
  /**
  Insert the given content at the given position.
  */
  insert(e, t) {
    return this.replaceWith(e, e, t);
  }
  /**
  Replace a range of the document with a given slice, using
  `from`, `to`, and the slice's
  [`openStart`](https://prosemirror.net/docs/ref/#model.Slice.openStart) property as hints, rather
  than fixed start and end points. This method may grow the
  replaced area or close open nodes in the slice in order to get a
  fit that is more in line with WYSIWYG expectations, by dropping
  fully covered parent nodes of the replaced region when they are
  marked [non-defining as
  context](https://prosemirror.net/docs/ref/#model.NodeSpec.definingAsContext), or including an
  open parent node from the slice that _is_ marked as [defining
  its content](https://prosemirror.net/docs/ref/#model.NodeSpec.definingForContent).
  
  This is the method, for example, to handle paste. The similar
  [`replace`](https://prosemirror.net/docs/ref/#transform.Transform.replace) method is a more
  primitive tool which will _not_ move the start and end of its given
  range, and is useful in situations where you need more precise
  control over what happens.
  */
  replaceRange(e, t, r) {
    return ZM(this, e, t, r), this;
  }
  /**
  Replace the given range with a node, but use `from` and `to` as
  hints, rather than precise positions. When from and to are the same
  and are at the start or end of a parent node in which the given
  node doesn't fit, this method may _move_ them out towards a parent
  that does allow the given node to be placed. When the given range
  completely covers a parent node, this method may completely replace
  that parent node.
  */
  replaceRangeWith(e, t, r) {
    return jM(this, e, t, r), this;
  }
  /**
  Delete the given range, expanding it to cover fully covered
  parent nodes until a valid replace is found.
  */
  deleteRange(e, t) {
    return YM(this, e, t), this;
  }
  /**
  Split the content in the given range off from its parent, if there
  is sibling content before or after it, and move it up the tree to
  the depth specified by `target`. You'll probably want to use
  [`liftTarget`](https://prosemirror.net/docs/ref/#transform.liftTarget) to compute `target`, to make
  sure the lift is valid.
  */
  lift(e, t) {
    return DM(this, e, t), this;
  }
  /**
  Join the blocks around the given position. If depth is 2, their
  last and first siblings are also joined, and so on.
  */
  join(e, t = 1) {
    return FM(this, e, t), this;
  }
  /**
  Wrap the given [range](https://prosemirror.net/docs/ref/#model.NodeRange) in the given set of wrappers.
  The wrappers are assumed to be valid in this position, and should
  probably be computed with [`findWrapping`](https://prosemirror.net/docs/ref/#transform.findWrapping).
  */
  wrap(e, t) {
    return PM(this, e, t), this;
  }
  /**
  Set the type of all textblocks (partly) between `from` and `to` to
  the given node type with the given attributes.
  */
  setBlockType(e, t = e, r, i = null) {
    return _M(this, e, t, r, i), this;
  }
  /**
  Change the type, attributes, and/or marks of the node at `pos`.
  When `type` isn't given, the existing node type is preserved,
  */
  setNodeMarkup(e, t, r = null, i) {
    return zM(this, e, t, r, i), this;
  }
  /**
  Set a single attribute on a given node to a new value.
  The `pos` addresses the document content. Use `setDocAttribute`
  to set attributes on the document itself.
  */
  setNodeAttribute(e, t, r) {
    return this.step(new ns(e, t, r)), this;
  }
  /**
  Set a single attribute on the document to a new value.
  */
  setDocAttribute(e, t) {
    return this.step(new fa(e, t)), this;
  }
  /**
  Add a mark to the node at position `pos`.
  */
  addNodeMark(e, t) {
    return this.step(new Ai(e, t)), this;
  }
  /**
  Remove a mark (or a mark of the given type) from the node at
  position `pos`.
  */
  removeNodeMark(e, t) {
    if (!(t instanceof ct)) {
      let r = this.doc.nodeAt(e);
      if (!r)
        throw new RangeError("No node at position " + e);
      if (t = t.isInSet(r.marks), !t)
        return this;
    }
    return this.step(new as(e, t)), this;
  }
  /**
  Split the node at the given position, and optionally, if `depth` is
  greater than one, any number of nodes above that. By default, the
  parts split off will inherit the node type of the original node.
  This can be changed by passing an array of types and attributes to
  use after the split.
  */
  split(e, t = 1, r) {
    return BM(this, e, t, r), this;
  }
  /**
  Add the given mark to the inline content between `from` and `to`.
  */
  addMark(e, t, r) {
    return OM(this, e, t, r), this;
  }
  /**
  Remove marks from inline nodes between `from` and `to`. When
  `mark` is a single mark, remove precisely that mark. When it is
  a mark type, remove all marks of that type. When it is null,
  remove all marks of any type.
  */
  removeMark(e, t, r) {
    return TM(this, e, t, r), this;
  }
  /**
  Removes all marks and nodes from the content of the node at
  `pos` that don't match the given new parent node type. Accepts
  an optional starting [content match](https://prosemirror.net/docs/ref/#model.ContentMatch) as
  third argument.
  */
  clearIncompatible(e, t, r) {
    return MM(this, e, t, r), this;
  }
}
const Md = /* @__PURE__ */ Object.create(null);
class rt {
  /**
  Initialize a selection with the head and anchor and ranges. If no
  ranges are given, constructs a single range across `$anchor` and
  `$head`.
  */
  constructor(e, t, r) {
    this.$anchor = e, this.$head = t, this.ranges = r || [new GM(e.min(t), e.max(t))];
  }
  /**
  The selection's anchor, as an unresolved position.
  */
  get anchor() {
    return this.$anchor.pos;
  }
  /**
  The selection's head.
  */
  get head() {
    return this.$head.pos;
  }
  /**
  The lower bound of the selection's main range.
  */
  get from() {
    return this.$from.pos;
  }
  /**
  The upper bound of the selection's main range.
  */
  get to() {
    return this.$to.pos;
  }
  /**
  The resolved lower  bound of the selection's main range.
  */
  get $from() {
    return this.ranges[0].$from;
  }
  /**
  The resolved upper bound of the selection's main range.
  */
  get $to() {
    return this.ranges[0].$to;
  }
  /**
  Indicates whether the selection contains any content.
  */
  get empty() {
    let e = this.ranges;
    for (let t = 0; t < e.length; t++)
      if (e[t].$from.pos != e[t].$to.pos)
        return !1;
    return !0;
  }
  /**
  Get the content of this selection as a slice.
  */
  content() {
    return this.$from.doc.slice(this.from, this.to, !0);
  }
  /**
  Replace the selection with a slice or, if no slice is given,
  delete the selection. Will append to the given transaction.
  */
  replace(e, t = ke.empty) {
    let r = t.content.lastChild, i = null;
    for (let l = 0; l < t.openEnd; l++)
      i = r, r = r.lastChild;
    let o = e.steps.length, a = this.ranges;
    for (let l = 0; l < a.length; l++) {
      let { $from: u, $to: d } = a[l], h = e.mapping.slice(o);
      e.replaceRange(h.map(u.pos), h.map(d.pos), l ? ke.empty : t), l == 0 && K0(e, o, (r ? r.isInline : i && i.isTextblock) ? -1 : 1);
    }
  }
  /**
  Replace the selection with the given node, appending the changes
  to the given transaction.
  */
  replaceWith(e, t) {
    let r = e.steps.length, i = this.ranges;
    for (let o = 0; o < i.length; o++) {
      let { $from: a, $to: l } = i[o], u = e.mapping.slice(r), d = u.map(a.pos), h = u.map(l.pos);
      o ? e.deleteRange(d, h) : (e.replaceRangeWith(d, h, t), K0(e, r, t.isInline ? -1 : 1));
    }
  }
  /**
  Find a valid cursor or leaf node selection starting at the given
  position and searching back if `dir` is negative, and forward if
  positive. When `textOnly` is true, only consider cursor
  selections. Will return null when no valid selection position is
  found.
  */
  static findFrom(e, t, r = !1) {
    let i = e.parent.inlineContent ? new it(e) : Go(e.node(0), e.parent, e.pos, e.index(), t, r);
    if (i)
      return i;
    for (let o = e.depth - 1; o >= 0; o--) {
      let a = t < 0 ? Go(e.node(0), e.node(o), e.before(o + 1), e.index(o), t, r) : Go(e.node(0), e.node(o), e.after(o + 1), e.index(o) + 1, t, r);
      if (a)
        return a;
    }
    return null;
  }
  /**
  Find a valid cursor or leaf node selection near the given
  position. Searches forward first by default, but if `bias` is
  negative, it will search backwards first.
  */
  static near(e, t = 1) {
    return this.findFrom(e, t) || this.findFrom(e, -t) || new Ln(e.node(0));
  }
  /**
  Find the cursor or leaf node selection closest to the start of
  the given document. Will return an
  [`AllSelection`](https://prosemirror.net/docs/ref/#state.AllSelection) if no valid position
  exists.
  */
  static atStart(e) {
    return Go(e, e, 0, 0, 1) || new Ln(e);
  }
  /**
  Find the cursor or leaf node selection closest to the end of the
  given document.
  */
  static atEnd(e) {
    return Go(e, e, e.content.size, e.childCount, -1) || new Ln(e);
  }
  /**
  Deserialize the JSON representation of a selection. Must be
  implemented for custom classes (as a static class method).
  */
  static fromJSON(e, t) {
    if (!t || !t.type)
      throw new RangeError("Invalid input for Selection.fromJSON");
    let r = Md[t.type];
    if (!r)
      throw new RangeError(`No selection type ${t.type} defined`);
    return r.fromJSON(e, t);
  }
  /**
  To be able to deserialize selections from JSON, custom selection
  classes must register themselves with an ID string, so that they
  can be disambiguated. Try to pick something that's unlikely to
  clash with classes from other modules.
  */
  static jsonID(e, t) {
    if (e in Md)
      throw new RangeError("Duplicate use of selection JSON ID " + e);
    return Md[e] = t, t.prototype.jsonID = e, t;
  }
  /**
  Get a [bookmark](https://prosemirror.net/docs/ref/#state.SelectionBookmark) for this selection,
  which is a value that can be mapped without having access to a
  current document, and later resolved to a real selection for a
  given document again. (This is used mostly by the history to
  track and restore old selections.) The default implementation of
  this method just converts the selection to a text selection and
  returns the bookmark for that.
  */
  getBookmark() {
    return it.between(this.$anchor, this.$head).getBookmark();
  }
}
rt.prototype.visible = !0;
class GM {
  /**
  Create a range.
  */
  constructor(e, t) {
    this.$from = e, this.$to = t;
  }
}
let q0 = !1;
function G0(n) {
  !q0 && !n.parent.inlineContent && (q0 = !0, console.warn("TextSelection endpoint not pointing into a node with inline content (" + n.parent.type.name + ")"));
}
class it extends rt {
  /**
  Construct a text selection between the given points.
  */
  constructor(e, t = e) {
    G0(e), G0(t), super(e, t);
  }
  /**
  Returns a resolved position if this is a cursor selection (an
  empty text selection), and null otherwise.
  */
  get $cursor() {
    return this.$anchor.pos == this.$head.pos ? this.$head : null;
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    if (!r.parent.inlineContent)
      return rt.near(r);
    let i = e.resolve(t.map(this.anchor));
    return new it(i.parent.inlineContent ? i : r, r);
  }
  replace(e, t = ke.empty) {
    if (super.replace(e, t), t == ke.empty) {
      let r = this.$from.marksAcross(this.$to);
      r && e.ensureMarks(r);
    }
  }
  eq(e) {
    return e instanceof it && e.anchor == this.anchor && e.head == this.head;
  }
  getBookmark() {
    return new Zc(this.anchor, this.head);
  }
  toJSON() {
    return { type: "text", anchor: this.anchor, head: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number" || typeof t.head != "number")
      throw new RangeError("Invalid input for TextSelection.fromJSON");
    return new it(e.resolve(t.anchor), e.resolve(t.head));
  }
  /**
  Create a text selection from non-resolved positions.
  */
  static create(e, t, r = t) {
    let i = e.resolve(t);
    return new this(i, r == t ? i : e.resolve(r));
  }
  /**
  Return a text selection that spans the given positions or, if
  they aren't text positions, find a text selection near them.
  `bias` determines whether the method searches forward (default)
  or backwards (negative number) first. Will fall back to calling
  [`Selection.near`](https://prosemirror.net/docs/ref/#state.Selection^near) when the document
  doesn't contain a valid text position.
  */
  static between(e, t, r) {
    let i = e.pos - t.pos;
    if ((!r || i) && (r = i >= 0 ? 1 : -1), !t.parent.inlineContent) {
      let o = rt.findFrom(t, r, !0) || rt.findFrom(t, -r, !0);
      if (o)
        t = o.$head;
      else
        return rt.near(t, r);
    }
    return e.parent.inlineContent || (i == 0 ? e = t : (e = (rt.findFrom(e, -r, !0) || rt.findFrom(e, r, !0)).$anchor, e.pos < t.pos != i < 0 && (e = t))), new it(e, t);
  }
}
rt.jsonID("text", it);
class Zc {
  constructor(e, t) {
    this.anchor = e, this.head = t;
  }
  map(e) {
    return new Zc(e.map(this.anchor), e.map(this.head));
  }
  resolve(e) {
    return it.between(e.resolve(this.anchor), e.resolve(this.head));
  }
}
class He extends rt {
  /**
  Create a node selection. Does not verify the validity of its
  argument.
  */
  constructor(e) {
    let t = e.nodeAfter, r = e.node(0).resolve(e.pos + t.nodeSize);
    super(e, r), this.node = t;
  }
  map(e, t) {
    let { deleted: r, pos: i } = t.mapResult(this.anchor), o = e.resolve(i);
    return r ? rt.near(o) : new He(o);
  }
  content() {
    return new ke(ue.from(this.node), 0, 0);
  }
  eq(e) {
    return e instanceof He && e.anchor == this.anchor;
  }
  toJSON() {
    return { type: "node", anchor: this.anchor };
  }
  getBookmark() {
    return new uh(this.anchor);
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.anchor != "number")
      throw new RangeError("Invalid input for NodeSelection.fromJSON");
    return new He(e.resolve(t.anchor));
  }
  /**
  Create a node selection from non-resolved positions.
  */
  static create(e, t) {
    return new He(e.resolve(t));
  }
  /**
  Determines whether the given node may be selected as a node
  selection.
  */
  static isSelectable(e) {
    return !e.isText && e.type.spec.selectable !== !1;
  }
}
He.prototype.visible = !1;
rt.jsonID("node", He);
class uh {
  constructor(e) {
    this.anchor = e;
  }
  map(e) {
    let { deleted: t, pos: r } = e.mapResult(this.anchor);
    return t ? new Zc(r, r) : new uh(r);
  }
  resolve(e) {
    let t = e.resolve(this.anchor), r = t.nodeAfter;
    return r && He.isSelectable(r) ? new He(t) : rt.near(t);
  }
}
class Ln extends rt {
  /**
  Create an all-selection over the given document.
  */
  constructor(e) {
    super(e.resolve(0), e.resolve(e.content.size));
  }
  replace(e, t = ke.empty) {
    if (t == ke.empty) {
      e.delete(0, e.doc.content.size);
      let r = rt.atStart(e.doc);
      r.eq(e.selection) || e.setSelection(r);
    } else
      super.replace(e, t);
  }
  toJSON() {
    return { type: "all" };
  }
  /**
  @internal
  */
  static fromJSON(e) {
    return new Ln(e);
  }
  map(e) {
    return new Ln(e);
  }
  eq(e) {
    return e instanceof Ln;
  }
  getBookmark() {
    return KM;
  }
}
rt.jsonID("all", Ln);
const KM = {
  map() {
    return this;
  },
  resolve(n) {
    return new Ln(n);
  }
};
function Go(n, e, t, r, i, o = !1) {
  if (e.inlineContent)
    return it.create(n, t);
  for (let a = r - (i > 0 ? 0 : 1); i > 0 ? a < e.childCount : a >= 0; a += i) {
    let l = e.child(a);
    if (l.isAtom) {
      if (!o && He.isSelectable(l))
        return He.create(n, t - (i < 0 ? l.nodeSize : 0));
    } else {
      let u = Go(n, l, t + i, i < 0 ? l.childCount : 0, i, o);
      if (u)
        return u;
    }
    t += l.nodeSize * i;
  }
  return null;
}
function K0(n, e, t) {
  let r = n.steps.length - 1;
  if (r < e)
    return;
  let i = n.steps[r];
  if (!(i instanceof hn || i instanceof Xn))
    return;
  let o = n.mapping.maps[r], a;
  o.forEach((l, u, d, h) => {
    a == null && (a = h);
  }), n.setSelection(rt.near(n.doc.resolve(a), t));
}
const X0 = 1, Al = 2, J0 = 4;
class XM extends qM {
  /**
  @internal
  */
  constructor(e) {
    super(e.doc), this.curSelectionFor = 0, this.updated = 0, this.meta = /* @__PURE__ */ Object.create(null), this.time = Date.now(), this.curSelection = e.selection, this.storedMarks = e.storedMarks;
  }
  /**
  The transaction's current selection. This defaults to the editor
  selection [mapped](https://prosemirror.net/docs/ref/#state.Selection.map) through the steps in the
  transaction, but can be overwritten with
  [`setSelection`](https://prosemirror.net/docs/ref/#state.Transaction.setSelection).
  */
  get selection() {
    return this.curSelectionFor < this.steps.length && (this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionFor)), this.curSelectionFor = this.steps.length), this.curSelection;
  }
  /**
  Update the transaction's current selection. Will determine the
  selection that the editor gets when the transaction is applied.
  */
  setSelection(e) {
    if (e.$from.doc != this.doc)
      throw new RangeError("Selection passed to setSelection must point at the current document");
    return this.curSelection = e, this.curSelectionFor = this.steps.length, this.updated = (this.updated | X0) & ~Al, this.storedMarks = null, this;
  }
  /**
  Whether the selection was explicitly updated by this transaction.
  */
  get selectionSet() {
    return (this.updated & X0) > 0;
  }
  /**
  Set the current stored marks.
  */
  setStoredMarks(e) {
    return this.storedMarks = e, this.updated |= Al, this;
  }
  /**
  Make sure the current stored marks or, if that is null, the marks
  at the selection, match the given set of marks. Does nothing if
  this is already the case.
  */
  ensureMarks(e) {
    return ct.sameSet(this.storedMarks || this.selection.$from.marks(), e) || this.setStoredMarks(e), this;
  }
  /**
  Add a mark to the set of stored marks.
  */
  addStoredMark(e) {
    return this.ensureMarks(e.addToSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Remove a mark or mark type from the set of stored marks.
  */
  removeStoredMark(e) {
    return this.ensureMarks(e.removeFromSet(this.storedMarks || this.selection.$head.marks()));
  }
  /**
  Whether the stored marks were explicitly set for this transaction.
  */
  get storedMarksSet() {
    return (this.updated & Al) > 0;
  }
  /**
  @internal
  */
  addStep(e, t) {
    super.addStep(e, t), this.updated = this.updated & ~Al, this.storedMarks = null;
  }
  /**
  Update the timestamp for the transaction.
  */
  setTime(e) {
    return this.time = e, this;
  }
  /**
  Replace the current selection with the given slice.
  */
  replaceSelection(e) {
    return this.selection.replace(this, e), this;
  }
  /**
  Replace the selection with the given node. When `inheritMarks` is
  true and the content is inline, it inherits the marks from the
  place where it is inserted.
  */
  replaceSelectionWith(e, t = !0) {
    let r = this.selection;
    return t && (e = e.mark(this.storedMarks || (r.empty ? r.$from.marks() : r.$from.marksAcross(r.$to) || ct.none))), r.replaceWith(this, e), this;
  }
  /**
  Delete the selection.
  */
  deleteSelection() {
    return this.selection.replace(this), this;
  }
  /**
  Replace the given range, or the selection if no range is given,
  with a text node containing the given string.
  */
  insertText(e, t, r) {
    let i = this.doc.type.schema;
    if (t == null)
      return e ? this.replaceSelectionWith(i.text(e), !0) : this.deleteSelection();
    {
      if (r == null && (r = t), r = r ?? t, !e)
        return this.deleteRange(t, r);
      let o = this.storedMarks;
      if (!o) {
        let a = this.doc.resolve(t);
        o = r == t ? a.marks() : a.marksAcross(this.doc.resolve(r));
      }
      return this.replaceRangeWith(t, r, i.text(e, o)), this.selection.empty || this.setSelection(rt.near(this.selection.$to)), this;
    }
  }
  /**
  Store a metadata property in this transaction, keyed either by
  name or by plugin.
  */
  setMeta(e, t) {
    return this.meta[typeof e == "string" ? e : e.key] = t, this;
  }
  /**
  Retrieve a metadata property for a given name or plugin.
  */
  getMeta(e) {
    return this.meta[typeof e == "string" ? e : e.key];
  }
  /**
  Returns true if this transaction doesn't contain any metadata,
  and can thus safely be extended.
  */
  get isGeneric() {
    for (let e in this.meta)
      return !1;
    return !0;
  }
  /**
  Indicate that the editor should scroll the selection into view
  when updated to the state produced by this transaction.
  */
  scrollIntoView() {
    return this.updated |= J0, this;
  }
  /**
  True when this transaction has had `scrollIntoView` called on it.
  */
  get scrolledIntoView() {
    return (this.updated & J0) > 0;
  }
}
function Q0(n, e) {
  return !e || !n ? n : n.bind(e);
}
class Zs {
  constructor(e, t, r) {
    this.name = e, this.init = Q0(t.init, r), this.apply = Q0(t.apply, r);
  }
}
const JM = [
  new Zs("doc", {
    init(n) {
      return n.doc || n.schema.topNodeType.createAndFill();
    },
    apply(n) {
      return n.doc;
    }
  }),
  new Zs("selection", {
    init(n, e) {
      return n.selection || rt.atStart(e.doc);
    },
    apply(n) {
      return n.selection;
    }
  }),
  new Zs("storedMarks", {
    init(n) {
      return n.storedMarks || null;
    },
    apply(n, e, t, r) {
      return r.selection.$cursor ? n.storedMarks : null;
    }
  }),
  new Zs("scrollToSelection", {
    init() {
      return 0;
    },
    apply(n, e) {
      return n.scrolledIntoView ? e + 1 : e;
    }
  })
];
class Rd {
  constructor(e, t) {
    this.schema = e, this.plugins = [], this.pluginsByKey = /* @__PURE__ */ Object.create(null), this.fields = JM.slice(), t && t.forEach((r) => {
      if (this.pluginsByKey[r.key])
        throw new RangeError("Adding different instances of a keyed plugin (" + r.key + ")");
      this.plugins.push(r), this.pluginsByKey[r.key] = r, r.spec.state && this.fields.push(new Zs(r.key, r.spec.state, r));
    });
  }
}
class Xo {
  /**
  @internal
  */
  constructor(e) {
    this.config = e;
  }
  /**
  The schema of the state's document.
  */
  get schema() {
    return this.config.schema;
  }
  /**
  The plugins that are active in this state.
  */
  get plugins() {
    return this.config.plugins;
  }
  /**
  Apply the given transaction to produce a new state.
  */
  apply(e) {
    return this.applyTransaction(e).state;
  }
  /**
  @internal
  */
  filterTransaction(e, t = -1) {
    for (let r = 0; r < this.config.plugins.length; r++)
      if (r != t) {
        let i = this.config.plugins[r];
        if (i.spec.filterTransaction && !i.spec.filterTransaction.call(i, e, this))
          return !1;
      }
    return !0;
  }
  /**
  Verbose variant of [`apply`](https://prosemirror.net/docs/ref/#state.EditorState.apply) that
  returns the precise transactions that were applied (which might
  be influenced by the [transaction
  hooks](https://prosemirror.net/docs/ref/#state.PluginSpec.filterTransaction) of
  plugins) along with the new state.
  */
  applyTransaction(e) {
    if (!this.filterTransaction(e))
      return { state: this, transactions: [] };
    let t = [e], r = this.applyInner(e), i = null;
    for (; ; ) {
      let o = !1;
      for (let a = 0; a < this.config.plugins.length; a++) {
        let l = this.config.plugins[a];
        if (l.spec.appendTransaction) {
          let u = i ? i[a].n : 0, d = i ? i[a].state : this, h = u < t.length && l.spec.appendTransaction.call(l, u ? t.slice(u) : t, d, r);
          if (h && r.filterTransaction(h, a)) {
            if (h.setMeta("appendedTransaction", e), !i) {
              i = [];
              for (let p = 0; p < this.config.plugins.length; p++)
                i.push(p < a ? { state: r, n: t.length } : { state: this, n: 0 });
            }
            t.push(h), r = r.applyInner(h), o = !0;
          }
          i && (i[a] = { state: r, n: t.length });
        }
      }
      if (!o)
        return { state: r, transactions: t };
    }
  }
  /**
  @internal
  */
  applyInner(e) {
    if (!e.before.eq(this.doc))
      throw new RangeError("Applying a mismatched transaction");
    let t = new Xo(this.config), r = this.config.fields;
    for (let i = 0; i < r.length; i++) {
      let o = r[i];
      t[o.name] = o.apply(e, this[o.name], this, t);
    }
    return t;
  }
  /**
  Start a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) from this state.
  */
  get tr() {
    return new XM(this);
  }
  /**
  Create a new state.
  */
  static create(e) {
    let t = new Rd(e.doc ? e.doc.type.schema : e.schema, e.plugins), r = new Xo(t);
    for (let i = 0; i < t.fields.length; i++)
      r[t.fields[i].name] = t.fields[i].init(e, r);
    return r;
  }
  /**
  Create a new state based on this one, but with an adjusted set
  of active plugins. State fields that exist in both sets of
  plugins are kept unchanged. Those that no longer exist are
  dropped, and those that are new are initialized using their
  [`init`](https://prosemirror.net/docs/ref/#state.StateField.init) method, passing in the new
  configuration object..
  */
  reconfigure(e) {
    let t = new Rd(this.schema, e.plugins), r = t.fields, i = new Xo(t);
    for (let o = 0; o < r.length; o++) {
      let a = r[o].name;
      i[a] = this.hasOwnProperty(a) ? this[a] : r[o].init(e, i);
    }
    return i;
  }
  /**
  Serialize this state to JSON. If you want to serialize the state
  of plugins, pass an object mapping property names to use in the
  resulting JSON object to plugin objects. The argument may also be
  a string or number, in which case it is ignored, to support the
  way `JSON.stringify` calls `toString` methods.
  */
  toJSON(e) {
    let t = { doc: this.doc.toJSON(), selection: this.selection.toJSON() };
    if (this.storedMarks && (t.storedMarks = this.storedMarks.map((r) => r.toJSON())), e && typeof e == "object")
      for (let r in e) {
        if (r == "doc" || r == "selection")
          throw new RangeError("The JSON fields `doc` and `selection` are reserved");
        let i = e[r], o = i.spec.state;
        o && o.toJSON && (t[r] = o.toJSON.call(i, this[i.key]));
      }
    return t;
  }
  /**
  Deserialize a JSON representation of a state. `config` should
  have at least a `schema` field, and should contain array of
  plugins to initialize the state with. `pluginFields` can be used
  to deserialize the state of plugins, by associating plugin
  instances with the property names they use in the JSON object.
  */
  static fromJSON(e, t, r) {
    if (!t)
      throw new RangeError("Invalid input for EditorState.fromJSON");
    if (!e.schema)
      throw new RangeError("Required config field 'schema' missing");
    let i = new Rd(e.schema, e.plugins), o = new Xo(i);
    return i.fields.forEach((a) => {
      if (a.name == "doc")
        o.doc = Wr.fromJSON(e.schema, t.doc);
      else if (a.name == "selection")
        o.selection = rt.fromJSON(o.doc, t.selection);
      else if (a.name == "storedMarks")
        t.storedMarks && (o.storedMarks = t.storedMarks.map(e.schema.markFromJSON));
      else {
        if (r)
          for (let l in r) {
            let u = r[l], d = u.spec.state;
            if (u.key == a.name && d && d.fromJSON && Object.prototype.hasOwnProperty.call(t, l)) {
              o[a.name] = d.fromJSON.call(u, e, t[l], o);
              return;
            }
          }
        o[a.name] = a.init(e, o);
      }
    }), o;
  }
}
function Ny(n, e, t) {
  for (let r in n) {
    let i = n[r];
    i instanceof Function ? i = i.bind(e) : r == "handleDOMEvents" && (i = Ny(i, e, {})), t[r] = i;
  }
  return t;
}
class Ma {
  /**
  Create a plugin.
  */
  constructor(e) {
    this.spec = e, this.props = {}, e.props && Ny(e.props, this, this.props), this.key = e.key ? e.key.key : zy("plugin");
  }
  /**
  Extract the plugin's state field from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Dd = /* @__PURE__ */ Object.create(null);
function zy(n) {
  return n in Dd ? n + "$" + ++Dd[n] : (Dd[n] = 0, n + "$");
}
class By {
  /**
  Create a plugin key.
  */
  constructor(e = "key") {
    this.key = zy(e);
  }
  /**
  Get the active plugin with this key, if any, from an editor
  state.
  */
  get(e) {
    return e.config.pluginsByKey[this.key];
  }
  /**
  Get the plugin's state from an editor state.
  */
  getState(e) {
    return e[this.key];
  }
}
const Fy = (n, e) => n.selection.empty ? !1 : (e && e(n.tr.deleteSelection().scrollIntoView()), !0);
function QM(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("backward", n) : t.parentOffset > 0) ? null : t;
}
const eR = (n, e, t) => {
  let r = QM(n, t);
  if (!r)
    return !1;
  let i = Vy(r);
  if (!i) {
    let a = r.blockRange(), l = a && Uc(a);
    return l == null ? !1 : (e && e(n.tr.lift(a, l).scrollIntoView()), !0);
  }
  let o = i.nodeBefore;
  if (!o.type.spec.isolating && $y(n, i, e))
    return !0;
  if (r.parent.content.size == 0 && (cs(o, "end") || He.isSelectable(o))) {
    let a = ch(n.doc, r.before(), r.after(), ke.empty);
    if (a && a.slice.size < a.to - a.from) {
      if (e) {
        let l = n.tr.step(a);
        l.setSelection(cs(o, "end") ? rt.findFrom(l.doc.resolve(l.mapping.map(i.pos, -1)), -1) : He.create(l.doc, i.pos - o.nodeSize)), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos - o.nodeSize, i.pos).scrollIntoView()), !0) : !1;
};
function cs(n, e, t = !1) {
  for (let r = n; r; r = e == "start" ? r.firstChild : r.lastChild) {
    if (r.isTextblock)
      return !0;
    if (t && r.childCount != 1)
      return !1;
  }
  return !1;
}
const tR = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("backward", n) : r.parentOffset > 0)
      return !1;
    o = Vy(r);
  }
  let a = o && o.nodeBefore;
  return !a || !He.isSelectable(a) ? !1 : (e && e(n.tr.setSelection(He.create(n.doc, o.pos - a.nodeSize)).scrollIntoView()), !0);
};
function Vy(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      if (n.index(e) > 0)
        return n.doc.resolve(n.before(e + 1));
      if (n.node(e).type.spec.isolating)
        break;
    }
  return null;
}
function nR(n, e) {
  let { $cursor: t } = n.selection;
  return !t || (e ? !e.endOfTextblock("forward", n) : t.parentOffset < t.parent.content.size) ? null : t;
}
const rR = (n, e, t) => {
  let r = nR(n, t);
  if (!r)
    return !1;
  let i = Wy(r);
  if (!i)
    return !1;
  let o = i.nodeAfter;
  if ($y(n, i, e))
    return !0;
  if (r.parent.content.size == 0 && (cs(o, "start") || He.isSelectable(o))) {
    let a = ch(n.doc, r.before(), r.after(), ke.empty);
    if (a && a.slice.size < a.to - a.from) {
      if (e) {
        let l = n.tr.step(a);
        l.setSelection(cs(o, "start") ? rt.findFrom(l.doc.resolve(l.mapping.map(i.pos)), 1) : He.create(l.doc, l.mapping.map(i.pos))), e(l.scrollIntoView());
      }
      return !0;
    }
  }
  return o.isAtom && i.depth == r.depth - 1 ? (e && e(n.tr.delete(i.pos, i.pos + o.nodeSize).scrollIntoView()), !0) : !1;
}, iR = (n, e, t) => {
  let { $head: r, empty: i } = n.selection, o = r;
  if (!i)
    return !1;
  if (r.parent.isTextblock) {
    if (t ? !t.endOfTextblock("forward", n) : r.parentOffset < r.parent.content.size)
      return !1;
    o = Wy(r);
  }
  let a = o && o.nodeAfter;
  return !a || !He.isSelectable(a) ? !1 : (e && e(n.tr.setSelection(He.create(n.doc, o.pos)).scrollIntoView()), !0);
};
function Wy(n) {
  if (!n.parent.type.spec.isolating)
    for (let e = n.depth - 1; e >= 0; e--) {
      let t = n.node(e);
      if (n.index(e) + 1 < t.childCount)
        return n.doc.resolve(n.after(e + 1));
      if (t.type.spec.isolating)
        break;
    }
  return null;
}
const oR = (n, e) => {
  let t = n.selection, r = t instanceof He, i;
  if (r) {
    if (t.node.isTextblock || !Ta(n.doc, t.from))
      return !1;
    i = t.from;
  } else if (i = Iy(n.doc, t.from, -1), i == null)
    return !1;
  if (e) {
    let o = n.tr.join(i);
    r && o.setSelection(He.create(o.doc, i - n.doc.resolve(i).nodeBefore.nodeSize)), e(o.scrollIntoView());
  }
  return !0;
}, sR = (n, e) => {
  let t = n.selection, r;
  if (t instanceof He) {
    if (t.node.isTextblock || !Ta(n.doc, t.to))
      return !1;
    r = t.to;
  } else if (r = Iy(n.doc, t.to, 1), r == null)
    return !1;
  return e && e(n.tr.join(r).scrollIntoView()), !0;
}, aR = (n, e) => {
  let { $from: t, $to: r } = n.selection, i = t.blockRange(r), o = i && Uc(i);
  return o == null ? !1 : (e && e(n.tr.lift(i, o).scrollIntoView()), !0);
}, lR = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  return !t.parent.type.spec.code || !t.sameParent(r) ? !1 : (e && e(n.tr.insertText(`
`).scrollIntoView()), !0);
};
function dh(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    let { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
const Hy = (n, e) => {
  let { $head: t, $anchor: r } = n.selection;
  if (!t.parent.type.spec.code || !t.sameParent(r))
    return !1;
  let i = t.node(-1), o = t.indexAfter(-1), a = dh(i.contentMatchAt(o));
  if (!a || !i.canReplaceWith(o, o, a))
    return !1;
  if (e) {
    let l = t.after(), u = n.tr.replaceWith(l, l, a.createAndFill());
    u.setSelection(rt.near(u.doc.resolve(l), 1)), e(u.scrollIntoView());
  }
  return !0;
}, cR = (n, e) => {
  let t = n.selection, { $from: r, $to: i } = t;
  if (t instanceof Ln || r.parent.inlineContent || i.parent.inlineContent)
    return !1;
  let o = dh(i.parent.contentMatchAt(i.indexAfter()));
  if (!o || !o.isTextblock)
    return !1;
  if (e) {
    let a = (!r.parentOffset && i.index() < i.parent.childCount ? r : i).pos, l = n.tr.insert(a, o.createAndFill());
    l.setSelection(it.create(l.doc, a + 1)), e(l.scrollIntoView());
  }
  return !0;
}, uR = (n, e) => {
  let { $cursor: t } = n.selection;
  if (!t || t.parent.content.size)
    return !1;
  if (t.depth > 1 && t.after() != t.end(-1)) {
    let o = t.before();
    if (vo(n.doc, o))
      return e && e(n.tr.split(o).scrollIntoView()), !0;
  }
  let r = t.blockRange(), i = r && Uc(r);
  return i == null ? !1 : (e && e(n.tr.lift(r, i).scrollIntoView()), !0);
};
function dR(n) {
  return (e, t) => {
    let { $from: r, $to: i } = e.selection;
    if (e.selection instanceof He && e.selection.node.isBlock)
      return !r.parentOffset || !vo(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.parent.isBlock)
      return !1;
    if (t) {
      let o = i.parentOffset == i.parent.content.size, a = e.tr;
      (e.selection instanceof it || e.selection instanceof Ln) && a.deleteSelection();
      let l = r.depth == 0 ? null : dh(r.node(-1).contentMatchAt(r.indexAfter(-1))), u = n && n(i.parent, o), d = u ? [u] : o && l ? [{ type: l }] : void 0, h = vo(a.doc, a.mapping.map(r.pos), 1, d);
      if (!d && !h && vo(a.doc, a.mapping.map(r.pos), 1, l ? [{ type: l }] : void 0) && (l && (d = [{ type: l }]), h = !0), h && (a.split(a.mapping.map(r.pos), 1, d), !o && !r.parentOffset && r.parent.type != l)) {
        let p = a.mapping.map(r.before()), g = a.doc.resolve(p);
        l && r.node(-1).canReplaceWith(g.index(), g.index() + 1, l) && a.setNodeMarkup(a.mapping.map(r.before()), l);
      }
      t(a.scrollIntoView());
    }
    return !0;
  };
}
const fR = dR(), hR = (n, e) => {
  let { $from: t, to: r } = n.selection, i, o = t.sharedDepth(r);
  return o == 0 ? !1 : (i = t.before(o), e && e(n.tr.setSelection(He.create(n.doc, i))), !0);
}, pR = (n, e) => (e && e(n.tr.setSelection(new Ln(n.doc))), !0);
function gR(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, o = e.index();
  return !r || !i || !r.type.compatibleContent(i.type) ? !1 : !r.content.size && e.parent.canReplace(o - 1, o) ? (t && t(n.tr.delete(e.pos - r.nodeSize, e.pos).scrollIntoView()), !0) : !e.parent.canReplace(o, o + 1) || !(i.isTextblock || Ta(n.doc, e.pos)) ? !1 : (t && t(n.tr.clearIncompatible(e.pos, r.type, r.contentMatchAt(r.childCount)).join(e.pos).scrollIntoView()), !0);
}
function $y(n, e, t) {
  let r = e.nodeBefore, i = e.nodeAfter, o, a;
  if (r.type.spec.isolating || i.type.spec.isolating)
    return !1;
  if (gR(n, e, t))
    return !0;
  let l = e.parent.canReplace(e.index(), e.index() + 1);
  if (l && (o = (a = r.contentMatchAt(r.childCount)).findWrapping(i.type)) && a.matchType(o[0] || i.type).validEnd) {
    if (t) {
      let p = e.pos + i.nodeSize, g = ue.empty;
      for (let w = o.length - 1; w >= 0; w--)
        g = ue.from(o[w].create(null, g));
      g = ue.from(r.copy(g));
      let v = n.tr.step(new Xn(e.pos - 1, p, e.pos, p, new ke(g, 1, 0), o.length, !0)), m = p + 2 * o.length;
      Ta(v.doc, m) && v.join(m), t(v.scrollIntoView());
    }
    return !0;
  }
  let u = rt.findFrom(e, 1), d = u && u.$from.blockRange(u.$to), h = d && Uc(d);
  if (h != null && h >= e.depth)
    return t && t(n.tr.lift(d, h).scrollIntoView()), !0;
  if (l && cs(i, "start", !0) && cs(r, "end")) {
    let p = r, g = [];
    for (; g.push(p), !p.isTextblock; )
      p = p.lastChild;
    let v = i, m = 1;
    for (; !v.isTextblock; v = v.firstChild)
      m++;
    if (p.canReplace(p.childCount, p.childCount, v.content)) {
      if (t) {
        let w = ue.empty;
        for (let C = g.length - 1; C >= 0; C--)
          w = ue.from(g[C].copy(w));
        let b = n.tr.step(new Xn(e.pos - g.length, e.pos + i.nodeSize, e.pos + m, e.pos + i.nodeSize - m, new ke(w, g.length, 0), 0, !0));
        t(b.scrollIntoView());
      }
      return !0;
    }
  }
  return !1;
}
function Uy(n) {
  return function(e, t) {
    let r = e.selection, i = n < 0 ? r.$from : r.$to, o = i.depth;
    for (; i.node(o).isInline; ) {
      if (!o)
        return !1;
      o--;
    }
    return i.node(o).isTextblock ? (t && t(e.tr.setSelection(it.create(e.doc, n < 0 ? i.start(o) : i.end(o)))), !0) : !1;
  };
}
const mR = Uy(-1), vR = Uy(1);
function yR(n, e = null) {
  return function(t, r) {
    let i = !1;
    for (let o = 0; o < t.selection.ranges.length && !i; o++) {
      let { $from: { pos: a }, $to: { pos: l } } = t.selection.ranges[o];
      t.doc.nodesBetween(a, l, (u, d) => {
        if (i)
          return !1;
        if (!(!u.isTextblock || u.hasMarkup(n, e)))
          if (u.type == n)
            i = !0;
          else {
            let h = t.doc.resolve(d), p = h.index();
            i = h.parent.canReplaceWith(p, p + 1, n);
          }
      });
    }
    if (!i)
      return !1;
    if (r) {
      let o = t.tr;
      for (let a = 0; a < t.selection.ranges.length; a++) {
        let { $from: { pos: l }, $to: { pos: u } } = t.selection.ranges[a];
        o.setBlockType(l, u, n, e);
      }
      r(o.scrollIntoView());
    }
    return !0;
  };
}
function jc(...n) {
  return function(e, t, r) {
    for (let i = 0; i < n.length; i++)
      if (n[i](e, t, r))
        return !0;
    return !1;
  };
}
let Id = jc(Fy, eR, tR), em = jc(Fy, rR, iR);
const ii = {
  Enter: jc(lR, cR, uR, fR),
  "Mod-Enter": Hy,
  Backspace: Id,
  "Mod-Backspace": Id,
  "Shift-Backspace": Id,
  Delete: em,
  "Mod-Delete": em,
  "Mod-a": pR
}, Zy = {
  "Ctrl-h": ii.Backspace,
  "Alt-Backspace": ii["Mod-Backspace"],
  "Ctrl-d": ii.Delete,
  "Ctrl-Alt-Backspace": ii["Mod-Delete"],
  "Alt-Delete": ii["Mod-Delete"],
  "Alt-d": ii["Mod-Delete"],
  "Ctrl-a": mR,
  "Ctrl-e": vR
};
for (let n in ii)
  Zy[n] = ii[n];
const wR = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : typeof os < "u" && os.platform ? os.platform() == "darwin" : !1, bR = wR ? Zy : ii;
var ci = {
  8: "Backspace",
  9: "Tab",
  10: "Enter",
  12: "NumLock",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  44: "PrintScreen",
  45: "Insert",
  46: "Delete",
  59: ";",
  61: "=",
  91: "Meta",
  92: "Meta",
  106: "*",
  107: "+",
  108: ",",
  109: "-",
  110: ".",
  111: "/",
  144: "NumLock",
  145: "ScrollLock",
  160: "Shift",
  161: "Shift",
  162: "Control",
  163: "Control",
  164: "Alt",
  165: "Alt",
  173: "-",
  186: ";",
  187: "=",
  188: ",",
  189: "-",
  190: ".",
  191: "/",
  192: "`",
  219: "[",
  220: "\\",
  221: "]",
  222: "'"
}, fc = {
  48: ")",
  49: "!",
  50: "@",
  51: "#",
  52: "$",
  53: "%",
  54: "^",
  55: "&",
  56: "*",
  57: "(",
  59: ":",
  61: "+",
  173: "_",
  186: ":",
  187: "+",
  188: "<",
  189: "_",
  190: ">",
  191: "?",
  192: "~",
  219: "{",
  220: "|",
  221: "}",
  222: '"'
}, xR = typeof navigator < "u" && /Mac/.test(navigator.platform), SR = typeof navigator < "u" && /MSIE \d|Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(navigator.userAgent);
for (var nn = 0; nn < 10; nn++)
  ci[48 + nn] = ci[96 + nn] = String(nn);
for (var nn = 1; nn <= 24; nn++)
  ci[nn + 111] = "F" + nn;
for (var nn = 65; nn <= 90; nn++)
  ci[nn] = String.fromCharCode(nn + 32), fc[nn] = String.fromCharCode(nn);
for (var Ad in ci)
  fc.hasOwnProperty(Ad) || (fc[Ad] = ci[Ad]);
function fh(n) {
  var e = xR && n.metaKey && n.shiftKey && !n.ctrlKey && !n.altKey || SR && n.shiftKey && n.key && n.key.length == 1 || n.key == "Unidentified", t = !e && n.key || (n.shiftKey ? fc : ci)[n.keyCode] || n.key || "Unidentified";
  return t == "Esc" && (t = "Escape"), t == "Del" && (t = "Delete"), t == "Left" && (t = "ArrowLeft"), t == "Up" && (t = "ArrowUp"), t == "Right" && (t = "ArrowRight"), t == "Down" && (t = "ArrowDown"), t;
}
const CR = typeof navigator < "u" ? /Mac|iP(hone|[oa]d)/.test(navigator.platform) : !1;
function ER(n) {
  let e = n.split(/-(?!$)/), t = e[e.length - 1];
  t == "Space" && (t = " ");
  let r, i, o, a;
  for (let l = 0; l < e.length - 1; l++) {
    let u = e[l];
    if (/^(cmd|meta|m)$/i.test(u))
      a = !0;
    else if (/^a(lt)?$/i.test(u))
      r = !0;
    else if (/^(c|ctrl|control)$/i.test(u))
      i = !0;
    else if (/^s(hift)?$/i.test(u))
      o = !0;
    else if (/^mod$/i.test(u))
      CR ? a = !0 : i = !0;
    else
      throw new Error("Unrecognized modifier name: " + u);
  }
  return r && (t = "Alt-" + t), i && (t = "Ctrl-" + t), a && (t = "Meta-" + t), o && (t = "Shift-" + t), t;
}
function kR(n) {
  let e = /* @__PURE__ */ Object.create(null);
  for (let t in n)
    e[ER(t)] = n[t];
  return e;
}
function Ld(n, e, t = !0) {
  return e.altKey && (n = "Alt-" + n), e.ctrlKey && (n = "Ctrl-" + n), e.metaKey && (n = "Meta-" + n), t && e.shiftKey && (n = "Shift-" + n), n;
}
function OR(n) {
  let e = kR(n);
  return function(t, r) {
    let i = fh(r), o, a = e[Ld(i, r)];
    if (a && a(t.state, t.dispatch, t))
      return !0;
    if (i.length == 1 && i != " ") {
      if (r.shiftKey) {
        let l = e[Ld(i, r, !1)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (o = ci[r.keyCode]) && o != i) {
        let l = e[Ld(o, r)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const Cn = function(n) {
  for (var e = 0; ; e++)
    if (n = n.previousSibling, !n)
      return e;
}, ha = function(n) {
  let e = n.assignedSlot || n.parentNode;
  return e && e.nodeType == 11 ? e.host : e;
};
let tm = null;
const ri = function(n, e, t) {
  let r = tm || (tm = document.createRange());
  return r.setEnd(n, t ?? n.nodeValue.length), r.setStart(n, e || 0), r;
}, So = function(n, e, t, r) {
  return t && (nm(n, e, t, r, -1) || nm(n, e, t, r, 1));
}, TR = /^(img|br|input|textarea|hr)$/i;
function nm(n, e, t, r, i) {
  for (; ; ) {
    if (n == t && e == r)
      return !0;
    if (e == (i < 0 ? 0 : Br(n))) {
      let o = n.parentNode;
      if (!o || o.nodeType != 1 || hh(n) || TR.test(n.nodeName) || n.contentEditable == "false")
        return !1;
      e = Cn(n) + (i < 0 ? 0 : 1), n = o;
    } else if (n.nodeType == 1) {
      if (n = n.childNodes[e + (i < 0 ? -1 : 0)], n.contentEditable == "false")
        return !1;
      e = i < 0 ? Br(n) : 0;
    } else
      return !1;
  }
}
function Br(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function MR(n, e, t) {
  for (let r = e == 0, i = e == Br(n); r || i; ) {
    if (n == t)
      return !0;
    let o = Cn(n);
    if (n = n.parentNode, !n)
      return !1;
    r = r && o == 0, i = i && o == Br(n);
  }
}
function hh(n) {
  let e;
  for (let t = n; t && !(e = t.pmViewDesc); t = t.parentNode)
    ;
  return e && e.node && e.node.isBlock && (e.dom == n || e.contentDOM == n);
}
const Yc = function(n) {
  return n.focusNode && So(n.focusNode, n.focusOffset, n.anchorNode, n.anchorOffset);
};
function fo(n, e) {
  let t = document.createEvent("Event");
  return t.initEvent("keydown", !0, !0), t.keyCode = n, t.key = t.code = e, t;
}
function RR(n) {
  let e = n.activeElement;
  for (; e && e.shadowRoot; )
    e = e.shadowRoot.activeElement;
  return e;
}
function DR(n, e, t) {
  if (n.caretPositionFromPoint)
    try {
      let r = n.caretPositionFromPoint(e, t);
      if (r)
        return { node: r.offsetNode, offset: r.offset };
    } catch {
    }
  if (n.caretRangeFromPoint) {
    let r = n.caretRangeFromPoint(e, t);
    if (r)
      return { node: r.startContainer, offset: r.startOffset };
  }
}
const Hr = typeof navigator < "u" ? navigator : null, rm = typeof document < "u" ? document : null, Yi = Hr && Hr.userAgent || "", Tf = /Edge\/(\d+)/.exec(Yi), jy = /MSIE \d/.exec(Yi), Mf = /Trident\/(?:[7-9]|\d{2,})\..*rv:(\d+)/.exec(Yi), Pn = !!(jy || Mf || Tf), _i = jy ? document.documentMode : Mf ? +Mf[1] : Tf ? +Tf[1] : 0, Tr = !Pn && /gecko\/(\d+)/i.test(Yi);
Tr && +(/Firefox\/(\d+)/.exec(Yi) || [0, 0])[1];
const Rf = !Pn && /Chrome\/(\d+)/.exec(Yi), gn = !!Rf, IR = Rf ? +Rf[1] : 0, En = !Pn && !!Hr && /Apple Computer/.test(Hr.vendor), us = En && (/Mobile\/\w+/.test(Yi) || !!Hr && Hr.maxTouchPoints > 2), ur = us || (Hr ? /Mac/.test(Hr.platform) : !1), AR = Hr ? /Win/.test(Hr.platform) : !1, kr = /Android \d/.test(Yi), Ra = !!rm && "webkitFontSmoothing" in rm.documentElement.style, LR = Ra ? +(/\bAppleWebKit\/(\d+)/.exec(navigator.userAgent) || [0, 0])[1] : 0;
function PR(n) {
  return {
    left: 0,
    right: n.documentElement.clientWidth,
    top: 0,
    bottom: n.documentElement.clientHeight
  };
}
function ni(n, e) {
  return typeof n == "number" ? n : n[e];
}
function _R(n) {
  let e = n.getBoundingClientRect(), t = e.width / n.offsetWidth || 1, r = e.height / n.offsetHeight || 1;
  return {
    left: e.left,
    right: e.left + n.clientWidth * t,
    top: e.top,
    bottom: e.top + n.clientHeight * r
  };
}
function im(n, e, t) {
  let r = n.someProp("scrollThreshold") || 0, i = n.someProp("scrollMargin") || 5, o = n.dom.ownerDocument;
  for (let a = t || n.dom; a; a = ha(a)) {
    if (a.nodeType != 1)
      continue;
    let l = a, u = l == o.body, d = u ? PR(o) : _R(l), h = 0, p = 0;
    if (e.top < d.top + ni(r, "top") ? p = -(d.top - e.top + ni(i, "top")) : e.bottom > d.bottom - ni(r, "bottom") && (p = e.bottom - e.top > d.bottom - d.top ? e.top + ni(i, "top") - d.top : e.bottom - d.bottom + ni(i, "bottom")), e.left < d.left + ni(r, "left") ? h = -(d.left - e.left + ni(i, "left")) : e.right > d.right - ni(r, "right") && (h = e.right - d.right + ni(i, "right")), h || p)
      if (u)
        o.defaultView.scrollBy(h, p);
      else {
        let g = l.scrollLeft, v = l.scrollTop;
        p && (l.scrollTop += p), h && (l.scrollLeft += h);
        let m = l.scrollLeft - g, w = l.scrollTop - v;
        e = { left: e.left - m, top: e.top - w, right: e.right - m, bottom: e.bottom - w };
      }
    if (u || /^(fixed|sticky)$/.test(getComputedStyle(a).position))
      break;
  }
}
function NR(n) {
  let e = n.dom.getBoundingClientRect(), t = Math.max(0, e.top), r, i;
  for (let o = (e.left + e.right) / 2, a = t + 1; a < Math.min(innerHeight, e.bottom); a += 5) {
    let l = n.root.elementFromPoint(o, a);
    if (!l || l == n.dom || !n.dom.contains(l))
      continue;
    let u = l.getBoundingClientRect();
    if (u.top >= t - 20) {
      r = l, i = u.top;
      break;
    }
  }
  return { refDOM: r, refTop: i, stack: Yy(n.dom) };
}
function Yy(n) {
  let e = [], t = n.ownerDocument;
  for (let r = n; r && (e.push({ dom: r, top: r.scrollTop, left: r.scrollLeft }), n != t); r = ha(r))
    ;
  return e;
}
function zR({ refDOM: n, refTop: e, stack: t }) {
  let r = n ? n.getBoundingClientRect().top : 0;
  qy(t, r == 0 ? 0 : r - e);
}
function qy(n, e) {
  for (let t = 0; t < n.length; t++) {
    let { dom: r, top: i, left: o } = n[t];
    r.scrollTop != i + e && (r.scrollTop = i + e), r.scrollLeft != o && (r.scrollLeft = o);
  }
}
let jo = null;
function BR(n) {
  if (n.setActive)
    return n.setActive();
  if (jo)
    return n.focus(jo);
  let e = Yy(n);
  n.focus(jo == null ? {
    get preventScroll() {
      return jo = { preventScroll: !0 }, !0;
    }
  } : void 0), jo || (jo = !1, qy(e, 0));
}
function Gy(n, e) {
  let t, r = 2e8, i, o = 0, a = e.top, l = e.top, u, d;
  for (let h = n.firstChild, p = 0; h; h = h.nextSibling, p++) {
    let g;
    if (h.nodeType == 1)
      g = h.getClientRects();
    else if (h.nodeType == 3)
      g = ri(h).getClientRects();
    else
      continue;
    for (let v = 0; v < g.length; v++) {
      let m = g[v];
      if (m.top <= a && m.bottom >= l) {
        a = Math.max(m.bottom, a), l = Math.min(m.top, l);
        let w = m.left > e.left ? m.left - e.left : m.right < e.left ? e.left - m.right : 0;
        if (w < r) {
          t = h, r = w, i = w && t.nodeType == 3 ? {
            left: m.right < e.left ? m.right : m.left,
            top: e.top
          } : e, h.nodeType == 1 && w && (o = p + (e.left >= (m.left + m.right) / 2 ? 1 : 0));
          continue;
        }
      } else
        m.top > e.top && !u && m.left <= e.left && m.right >= e.left && (u = h, d = { left: Math.max(m.left, Math.min(m.right, e.left)), top: m.top });
      !t && (e.left >= m.right && e.top >= m.top || e.left >= m.left && e.top >= m.bottom) && (o = p + 1);
    }
  }
  return !t && u && (t = u, i = d, r = 0), t && t.nodeType == 3 ? FR(t, i) : !t || r && t.nodeType == 1 ? { node: n, offset: o } : Gy(t, i);
}
function FR(n, e) {
  let t = n.nodeValue.length, r = document.createRange();
  for (let i = 0; i < t; i++) {
    r.setEnd(n, i + 1), r.setStart(n, i);
    let o = Oi(r, 1);
    if (o.top != o.bottom && ph(e, o))
      return { node: n, offset: i + (e.left >= (o.left + o.right) / 2 ? 1 : 0) };
  }
  return { node: n, offset: 0 };
}
function ph(n, e) {
  return n.left >= e.left - 1 && n.left <= e.right + 1 && n.top >= e.top - 1 && n.top <= e.bottom + 1;
}
function VR(n, e) {
  let t = n.parentNode;
  return t && /^li$/i.test(t.nodeName) && e.left < n.getBoundingClientRect().left ? t : n;
}
function WR(n, e, t) {
  let { node: r, offset: i } = Gy(e, t), o = -1;
  if (r.nodeType == 1 && !r.firstChild) {
    let a = r.getBoundingClientRect();
    o = a.left != a.right && t.left > (a.left + a.right) / 2 ? 1 : -1;
  }
  return n.docView.posFromDOM(r, i, o);
}
function HR(n, e, t, r) {
  let i = -1;
  for (let o = e, a = !1; o != n.dom; ) {
    let l = n.docView.nearestDesc(o, !0);
    if (!l)
      return null;
    if (l.dom.nodeType == 1 && (l.node.isBlock && l.parent && !a || !l.contentDOM)) {
      let u = l.dom.getBoundingClientRect();
      if (l.node.isBlock && l.parent && !a && (a = !0, u.left > r.left || u.top > r.top ? i = l.posBefore : (u.right < r.left || u.bottom < r.top) && (i = l.posAfter)), !l.contentDOM && i < 0 && !l.node.isText)
        return (l.node.isBlock ? r.top < (u.top + u.bottom) / 2 : r.left < (u.left + u.right) / 2) ? l.posBefore : l.posAfter;
    }
    o = l.dom.parentNode;
  }
  return i > -1 ? i : n.docView.posFromDOM(e, t, -1);
}
function Ky(n, e, t) {
  let r = n.childNodes.length;
  if (r && t.top < t.bottom)
    for (let i = Math.max(0, Math.min(r - 1, Math.floor(r * (e.top - t.top) / (t.bottom - t.top)) - 2)), o = i; ; ) {
      let a = n.childNodes[o];
      if (a.nodeType == 1) {
        let l = a.getClientRects();
        for (let u = 0; u < l.length; u++) {
          let d = l[u];
          if (ph(e, d))
            return Ky(a, e, d);
        }
      }
      if ((o = (o + 1) % r) == i)
        break;
    }
  return n;
}
function $R(n, e) {
  let t = n.dom.ownerDocument, r, i = 0, o = DR(t, e.left, e.top);
  o && ({ node: r, offset: i } = o);
  let a = (n.root.elementFromPoint ? n.root : t).elementFromPoint(e.left, e.top), l;
  if (!a || !n.dom.contains(a.nodeType != 1 ? a.parentNode : a)) {
    let d = n.dom.getBoundingClientRect();
    if (!ph(e, d) || (a = Ky(n.dom, e, d), !a))
      return null;
  }
  if (En)
    for (let d = a; r && d; d = ha(d))
      d.draggable && (r = void 0);
  if (a = VR(a, e), r) {
    if (Tr && r.nodeType == 1 && (i = Math.min(i, r.childNodes.length), i < r.childNodes.length)) {
      let h = r.childNodes[i], p;
      h.nodeName == "IMG" && (p = h.getBoundingClientRect()).right <= e.left && p.bottom > e.top && i++;
    }
    let d;
    Ra && i && r.nodeType == 1 && (d = r.childNodes[i - 1]).nodeType == 1 && d.contentEditable == "false" && d.getBoundingClientRect().top >= e.top && i--, r == n.dom && i == r.childNodes.length - 1 && r.lastChild.nodeType == 1 && e.top > r.lastChild.getBoundingClientRect().bottom ? l = n.state.doc.content.size : (i == 0 || r.nodeType != 1 || r.childNodes[i - 1].nodeName != "BR") && (l = HR(n, r, i, e));
  }
  l == null && (l = WR(n, a, e));
  let u = n.docView.nearestDesc(a, !0);
  return { pos: l, inside: u ? u.posAtStart - u.border : -1 };
}
function om(n) {
  return n.top < n.bottom || n.left < n.right;
}
function Oi(n, e) {
  let t = n.getClientRects();
  if (t.length) {
    let r = t[e < 0 ? 0 : t.length - 1];
    if (om(r))
      return r;
  }
  return Array.prototype.find.call(t, om) || n.getBoundingClientRect();
}
const UR = /[\u0590-\u05f4\u0600-\u06ff\u0700-\u08ac]/;
function Xy(n, e, t) {
  let { node: r, offset: i, atom: o } = n.docView.domFromPos(e, t < 0 ? -1 : 1), a = Ra || Tr;
  if (r.nodeType == 3)
    if (a && (UR.test(r.nodeValue) || (t < 0 ? !i : i == r.nodeValue.length))) {
      let u = Oi(ri(r, i, i), t);
      if (Tr && i && /\s/.test(r.nodeValue[i - 1]) && i < r.nodeValue.length) {
        let d = Oi(ri(r, i - 1, i - 1), -1);
        if (d.top == u.top) {
          let h = Oi(ri(r, i, i + 1), -1);
          if (h.top != u.top)
            return Fs(h, h.left < d.left);
        }
      }
      return u;
    } else {
      let u = i, d = i, h = t < 0 ? 1 : -1;
      return t < 0 && !i ? (d++, h = -1) : t >= 0 && i == r.nodeValue.length ? (u--, h = 1) : t < 0 ? u-- : d++, Fs(Oi(ri(r, u, d), h), h < 0);
    }
  if (!n.state.doc.resolve(e - (o || 0)).parent.inlineContent) {
    if (o == null && i && (t < 0 || i == Br(r))) {
      let u = r.childNodes[i - 1];
      if (u.nodeType == 1)
        return Pd(u.getBoundingClientRect(), !1);
    }
    if (o == null && i < Br(r)) {
      let u = r.childNodes[i];
      if (u.nodeType == 1)
        return Pd(u.getBoundingClientRect(), !0);
    }
    return Pd(r.getBoundingClientRect(), t >= 0);
  }
  if (o == null && i && (t < 0 || i == Br(r))) {
    let u = r.childNodes[i - 1], d = u.nodeType == 3 ? ri(u, Br(u) - (a ? 0 : 1)) : u.nodeType == 1 && (u.nodeName != "BR" || !u.nextSibling) ? u : null;
    if (d)
      return Fs(Oi(d, 1), !1);
  }
  if (o == null && i < Br(r)) {
    let u = r.childNodes[i];
    for (; u.pmViewDesc && u.pmViewDesc.ignoreForCoords; )
      u = u.nextSibling;
    let d = u ? u.nodeType == 3 ? ri(u, 0, a ? 0 : 1) : u.nodeType == 1 ? u : null : null;
    if (d)
      return Fs(Oi(d, -1), !0);
  }
  return Fs(Oi(r.nodeType == 3 ? ri(r) : r, -t), t >= 0);
}
function Fs(n, e) {
  if (n.width == 0)
    return n;
  let t = e ? n.left : n.right;
  return { top: n.top, bottom: n.bottom, left: t, right: t };
}
function Pd(n, e) {
  if (n.height == 0)
    return n;
  let t = e ? n.top : n.bottom;
  return { top: t, bottom: t, left: n.left, right: n.right };
}
function Jy(n, e, t) {
  let r = n.state, i = n.root.activeElement;
  r != e && n.updateState(e), i != n.dom && n.focus();
  try {
    return t();
  } finally {
    r != e && n.updateState(r), i != n.dom && i && i.focus();
  }
}
function ZR(n, e, t) {
  let r = e.selection, i = t == "up" ? r.$from : r.$to;
  return Jy(n, e, () => {
    let { node: o } = n.docView.domFromPos(i.pos, t == "up" ? -1 : 1);
    for (; ; ) {
      let l = n.docView.nearestDesc(o, !0);
      if (!l)
        break;
      if (l.node.isBlock) {
        o = l.contentDOM || l.dom;
        break;
      }
      o = l.dom.parentNode;
    }
    let a = Xy(n, i.pos, 1);
    for (let l = o.firstChild; l; l = l.nextSibling) {
      let u;
      if (l.nodeType == 1)
        u = l.getClientRects();
      else if (l.nodeType == 3)
        u = ri(l, 0, l.nodeValue.length).getClientRects();
      else
        continue;
      for (let d = 0; d < u.length; d++) {
        let h = u[d];
        if (h.bottom > h.top + 1 && (t == "up" ? a.top - h.top > (h.bottom - a.top) * 2 : h.bottom - a.bottom > (a.bottom - h.top) * 2))
          return !1;
      }
    }
    return !0;
  });
}
const jR = /[\u0590-\u08ac]/;
function YR(n, e, t) {
  let { $head: r } = e.selection;
  if (!r.parent.isTextblock)
    return !1;
  let i = r.parentOffset, o = !i, a = i == r.parent.content.size, l = n.domSelection();
  return !jR.test(r.parent.textContent) || !l.modify ? t == "left" || t == "backward" ? o : a : Jy(n, e, () => {
    let { focusNode: u, focusOffset: d, anchorNode: h, anchorOffset: p } = n.domSelectionRange(), g = l.caretBidiLevel;
    l.modify("move", t, "character");
    let v = r.depth ? n.docView.domAfterPos(r.before()) : n.dom, { focusNode: m, focusOffset: w } = n.domSelectionRange(), b = m && !v.contains(m.nodeType == 1 ? m : m.parentNode) || u == m && d == w;
    try {
      l.collapse(h, p), u && (u != h || d != p) && l.extend && l.extend(u, d);
    } catch {
    }
    return g != null && (l.caretBidiLevel = g), b;
  });
}
let sm = null, am = null, lm = !1;
function qR(n, e, t) {
  return sm == e && am == t ? lm : (sm = e, am = t, lm = t == "up" || t == "down" ? ZR(n, e, t) : YR(n, e, t));
}
const pr = 0, cm = 1, ho = 2, $r = 3;
class Da {
  constructor(e, t, r, i) {
    this.parent = e, this.children = t, this.dom = r, this.contentDOM = i, this.dirty = pr, r.pmViewDesc = this;
  }
  // Used to check whether a given description corresponds to a
  // widget/mark/node.
  matchesWidget(e) {
    return !1;
  }
  matchesMark(e) {
    return !1;
  }
  matchesNode(e, t, r) {
    return !1;
  }
  matchesHack(e) {
    return !1;
  }
  // When parsing in-editor content (in domchange.js), we allow
  // descriptions to determine the parse rules that should be used to
  // parse them.
  parseRule() {
    return null;
  }
  // Used by the editor's event handler to ignore events that come
  // from certain descs.
  stopEvent(e) {
    return !1;
  }
  // The size of the content represented by this desc.
  get size() {
    let e = 0;
    for (let t = 0; t < this.children.length; t++)
      e += this.children[t].size;
    return e;
  }
  // For block nodes, this represents the space taken up by their
  // start/end tokens.
  get border() {
    return 0;
  }
  destroy() {
    this.parent = void 0, this.dom.pmViewDesc == this && (this.dom.pmViewDesc = void 0);
    for (let e = 0; e < this.children.length; e++)
      this.children[e].destroy();
  }
  posBeforeChild(e) {
    for (let t = 0, r = this.posAtStart; ; t++) {
      let i = this.children[t];
      if (i == e)
        return r;
      r += i.size;
    }
  }
  get posBefore() {
    return this.parent.posBeforeChild(this);
  }
  get posAtStart() {
    return this.parent ? this.parent.posBeforeChild(this) + this.border : 0;
  }
  get posAfter() {
    return this.posBefore + this.size;
  }
  get posAtEnd() {
    return this.posAtStart + this.size - 2 * this.border;
  }
  localPosFromDOM(e, t, r) {
    if (this.contentDOM && this.contentDOM.contains(e.nodeType == 1 ? e : e.parentNode))
      if (r < 0) {
        let o, a;
        if (e == this.contentDOM)
          o = e.childNodes[t - 1];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.previousSibling;
        }
        for (; o && !((a = o.pmViewDesc) && a.parent == this); )
          o = o.previousSibling;
        return o ? this.posBeforeChild(a) + a.size : this.posAtStart;
      } else {
        let o, a;
        if (e == this.contentDOM)
          o = e.childNodes[t];
        else {
          for (; e.parentNode != this.contentDOM; )
            e = e.parentNode;
          o = e.nextSibling;
        }
        for (; o && !((a = o.pmViewDesc) && a.parent == this); )
          o = o.nextSibling;
        return o ? this.posBeforeChild(a) : this.posAtEnd;
      }
    let i;
    if (e == this.dom && this.contentDOM)
      i = t > Cn(this.contentDOM);
    else if (this.contentDOM && this.contentDOM != this.dom && this.dom.contains(this.contentDOM))
      i = e.compareDocumentPosition(this.contentDOM) & 2;
    else if (this.dom.firstChild) {
      if (t == 0)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !1;
            break;
          }
          if (o.previousSibling)
            break;
        }
      if (i == null && t == e.childNodes.length)
        for (let o = e; ; o = o.parentNode) {
          if (o == this.dom) {
            i = !0;
            break;
          }
          if (o.nextSibling)
            break;
        }
    }
    return i ?? r > 0 ? this.posAtEnd : this.posAtStart;
  }
  nearestDesc(e, t = !1) {
    for (let r = !0, i = e; i; i = i.parentNode) {
      let o = this.getDesc(i), a;
      if (o && (!t || o.node))
        if (r && (a = o.nodeDOM) && !(a.nodeType == 1 ? a.contains(e.nodeType == 1 ? e : e.parentNode) : a == e))
          r = !1;
        else
          return o;
    }
  }
  getDesc(e) {
    let t = e.pmViewDesc;
    for (let r = t; r; r = r.parent)
      if (r == this)
        return t;
  }
  posFromDOM(e, t, r) {
    for (let i = e; i; i = i.parentNode) {
      let o = this.getDesc(i);
      if (o)
        return o.localPosFromDOM(e, t, r);
    }
    return -1;
  }
  // Find the desc for the node after the given pos, if any. (When a
  // parent node overrode rendering, there might not be one.)
  descAt(e) {
    for (let t = 0, r = 0; t < this.children.length; t++) {
      let i = this.children[t], o = r + i.size;
      if (r == e && o != r) {
        for (; !i.border && i.children.length; )
          i = i.children[0];
        return i;
      }
      if (e < o)
        return i.descAt(e - r - i.border);
      r = o;
    }
  }
  domFromPos(e, t) {
    if (!this.contentDOM)
      return { node: this.dom, offset: 0, atom: e + 1 };
    let r = 0, i = 0;
    for (let o = 0; r < this.children.length; r++) {
      let a = this.children[r], l = o + a.size;
      if (l > e || a instanceof ew) {
        i = e - o;
        break;
      }
      o = l;
    }
    if (i)
      return this.children[r].domFromPos(i - this.children[r].border, t);
    for (let o; r && !(o = this.children[r - 1]).size && o instanceof Qy && o.side >= 0; r--)
      ;
    if (t <= 0) {
      let o, a = !0;
      for (; o = r ? this.children[r - 1] : null, !(!o || o.dom.parentNode == this.contentDOM); r--, a = !1)
        ;
      return o && t && a && !o.border && !o.domAtom ? o.domFromPos(o.size, t) : { node: this.contentDOM, offset: o ? Cn(o.dom) + 1 : 0 };
    } else {
      let o, a = !0;
      for (; o = r < this.children.length ? this.children[r] : null, !(!o || o.dom.parentNode == this.contentDOM); r++, a = !1)
        ;
      return o && a && !o.border && !o.domAtom ? o.domFromPos(0, t) : { node: this.contentDOM, offset: o ? Cn(o.dom) : this.contentDOM.childNodes.length };
    }
  }
  // Used to find a DOM range in a single parent for a given changed
  // range.
  parseRange(e, t, r = 0) {
    if (this.children.length == 0)
      return { node: this.contentDOM, from: e, to: t, fromOffset: 0, toOffset: this.contentDOM.childNodes.length };
    let i = -1, o = -1;
    for (let a = r, l = 0; ; l++) {
      let u = this.children[l], d = a + u.size;
      if (i == -1 && e <= d) {
        let h = a + u.border;
        if (e >= h && t <= d - u.border && u.node && u.contentDOM && this.contentDOM.contains(u.contentDOM))
          return u.parseRange(e, t, h);
        e = a;
        for (let p = l; p > 0; p--) {
          let g = this.children[p - 1];
          if (g.size && g.dom.parentNode == this.contentDOM && !g.emptyChildAt(1)) {
            i = Cn(g.dom) + 1;
            break;
          }
          e -= g.size;
        }
        i == -1 && (i = 0);
      }
      if (i > -1 && (d > t || l == this.children.length - 1)) {
        t = d;
        for (let h = l + 1; h < this.children.length; h++) {
          let p = this.children[h];
          if (p.size && p.dom.parentNode == this.contentDOM && !p.emptyChildAt(-1)) {
            o = Cn(p.dom);
            break;
          }
          t += p.size;
        }
        o == -1 && (o = this.contentDOM.childNodes.length);
        break;
      }
      a = d;
    }
    return { node: this.contentDOM, from: e, to: t, fromOffset: i, toOffset: o };
  }
  emptyChildAt(e) {
    if (this.border || !this.contentDOM || !this.children.length)
      return !1;
    let t = this.children[e < 0 ? 0 : this.children.length - 1];
    return t.size == 0 || t.emptyChildAt(e);
  }
  domAfterPos(e) {
    let { node: t, offset: r } = this.domFromPos(e, 0);
    if (t.nodeType != 1 || r == t.childNodes.length)
      throw new RangeError("No node after pos " + e);
    return t.childNodes[r];
  }
  // View descs are responsible for setting any selection that falls
  // entirely inside of them, so that custom implementations can do
  // custom things with the selection. Note that this falls apart when
  // a selection starts in such a node and ends in another, in which
  // case we just use whatever domFromPos produces as a best effort.
  setSelection(e, t, r, i = !1) {
    let o = Math.min(e, t), a = Math.max(e, t);
    for (let g = 0, v = 0; g < this.children.length; g++) {
      let m = this.children[g], w = v + m.size;
      if (o > v && a < w)
        return m.setSelection(e - v - m.border, t - v - m.border, r, i);
      v = w;
    }
    let l = this.domFromPos(e, e ? -1 : 1), u = t == e ? l : this.domFromPos(t, t ? -1 : 1), d = r.getSelection(), h = !1;
    if ((Tr || En) && e == t) {
      let { node: g, offset: v } = l;
      if (g.nodeType == 3) {
        if (h = !!(v && g.nodeValue[v - 1] == `
`), h && v == g.nodeValue.length)
          for (let m = g, w; m; m = m.parentNode) {
            if (w = m.nextSibling) {
              w.nodeName == "BR" && (l = u = { node: w.parentNode, offset: Cn(w) + 1 });
              break;
            }
            let b = m.pmViewDesc;
            if (b && b.node && b.node.isBlock)
              break;
          }
      } else {
        let m = g.childNodes[v - 1];
        h = m && (m.nodeName == "BR" || m.contentEditable == "false");
      }
    }
    if (Tr && d.focusNode && d.focusNode != u.node && d.focusNode.nodeType == 1) {
      let g = d.focusNode.childNodes[d.focusOffset];
      g && g.contentEditable == "false" && (i = !0);
    }
    if (!(i || h && En) && So(l.node, l.offset, d.anchorNode, d.anchorOffset) && So(u.node, u.offset, d.focusNode, d.focusOffset))
      return;
    let p = !1;
    if ((d.extend || e == t) && !h) {
      d.collapse(l.node, l.offset);
      try {
        e != t && d.extend(u.node, u.offset), p = !0;
      } catch {
      }
    }
    if (!p) {
      if (e > t) {
        let v = l;
        l = u, u = v;
      }
      let g = document.createRange();
      g.setEnd(u.node, u.offset), g.setStart(l.node, l.offset), d.removeAllRanges(), d.addRange(g);
    }
  }
  ignoreMutation(e) {
    return !this.contentDOM && e.type != "selection";
  }
  get contentLost() {
    return this.contentDOM && this.contentDOM != this.dom && !this.dom.contains(this.contentDOM);
  }
  // Remove a subtree of the element tree that has been touched
  // by a DOM change, so that the next update will redraw it.
  markDirty(e, t) {
    for (let r = 0, i = 0; i < this.children.length; i++) {
      let o = this.children[i], a = r + o.size;
      if (r == a ? e <= a && t >= r : e < a && t > r) {
        let l = r + o.border, u = a - o.border;
        if (e >= l && t <= u) {
          this.dirty = e == r || t == a ? ho : cm, e == l && t == u && (o.contentLost || o.dom.parentNode != this.contentDOM) ? o.dirty = $r : o.markDirty(e - l, t - l);
          return;
        } else
          o.dirty = o.dom == o.contentDOM && o.dom.parentNode == this.contentDOM && !o.children.length ? ho : $r;
      }
      r = a;
    }
    this.dirty = ho;
  }
  markParentsDirty() {
    let e = 1;
    for (let t = this.parent; t; t = t.parent, e++) {
      let r = e == 1 ? ho : cm;
      t.dirty < r && (t.dirty = r);
    }
  }
  get domAtom() {
    return !1;
  }
  get ignoreForCoords() {
    return !1;
  }
}
class Qy extends Da {
  constructor(e, t, r, i) {
    let o, a = t.type.toDOM;
    if (typeof a == "function" && (a = a(r, () => {
      if (!o)
        return i;
      if (o.parent)
        return o.parent.posBeforeChild(o);
    })), !t.type.spec.raw) {
      if (a.nodeType != 1) {
        let l = document.createElement("span");
        l.appendChild(a), a = l;
      }
      a.contentEditable = "false", a.classList.add("ProseMirror-widget");
    }
    super(e, [], a, null), this.widget = t, this.widget = t, o = this;
  }
  matchesWidget(e) {
    return this.dirty == pr && e.type.eq(this.widget.type);
  }
  parseRule() {
    return { ignore: !0 };
  }
  stopEvent(e) {
    let t = this.widget.spec.stopEvent;
    return t ? t(e) : !1;
  }
  ignoreMutation(e) {
    return e.type != "selection" || this.widget.spec.ignoreSelection;
  }
  destroy() {
    this.widget.type.destroy(this.dom), super.destroy();
  }
  get domAtom() {
    return !0;
  }
  get side() {
    return this.widget.type.side;
  }
}
class GR extends Da {
  constructor(e, t, r, i) {
    super(e, [], t, null), this.textDOM = r, this.text = i;
  }
  get size() {
    return this.text.length;
  }
  localPosFromDOM(e, t) {
    return e != this.textDOM ? this.posAtStart + (t ? this.size : 0) : this.posAtStart + t;
  }
  domFromPos(e) {
    return { node: this.textDOM, offset: e };
  }
  ignoreMutation(e) {
    return e.type === "characterData" && e.target.nodeValue == e.oldValue;
  }
}
class Co extends Da {
  constructor(e, t, r, i) {
    super(e, [], r, i), this.mark = t;
  }
  static create(e, t, r, i) {
    let o = i.nodeViews[t.type.name], a = o && o(t, i, r);
    return (!a || !a.dom) && (a = si.renderSpec(document, t.type.spec.toDOM(t, r))), new Co(e, t, a.dom, a.contentDOM || a.dom);
  }
  parseRule() {
    return this.dirty & $r || this.mark.type.spec.reparseInView ? null : { mark: this.mark.type.name, attrs: this.mark.attrs, contentElement: this.contentDOM };
  }
  matchesMark(e) {
    return this.dirty != $r && this.mark.eq(e);
  }
  markDirty(e, t) {
    if (super.markDirty(e, t), this.dirty != pr) {
      let r = this.parent;
      for (; !r.node; )
        r = r.parent;
      r.dirty < this.dirty && (r.dirty = this.dirty), this.dirty = pr;
    }
  }
  slice(e, t, r) {
    let i = Co.create(this.parent, this.mark, !0, r), o = this.children, a = this.size;
    t < a && (o = Af(o, t, a, r)), e > 0 && (o = Af(o, 0, e, r));
    for (let l = 0; l < o.length; l++)
      o[l].parent = i;
    return i.children = o, i;
  }
}
class Ni extends Da {
  constructor(e, t, r, i, o, a, l, u, d) {
    super(e, [], o, a), this.node = t, this.outerDeco = r, this.innerDeco = i, this.nodeDOM = l;
  }
  // By default, a node is rendered using the `toDOM` method from the
  // node type spec. But client code can use the `nodeViews` spec to
  // supply a custom node view, which can influence various aspects of
  // the way the node works.
  //
  // (Using subclassing for this was intentionally decided against,
  // since it'd require exposing a whole slew of finicky
  // implementation details to the user code that they probably will
  // never need.)
  static create(e, t, r, i, o, a) {
    let l = o.nodeViews[t.type.name], u, d = l && l(t, o, () => {
      if (!u)
        return a;
      if (u.parent)
        return u.parent.posBeforeChild(u);
    }, r, i), h = d && d.dom, p = d && d.contentDOM;
    if (t.isText) {
      if (!h)
        h = document.createTextNode(t.text);
      else if (h.nodeType != 3)
        throw new RangeError("Text must be rendered as a DOM text node");
    } else
      h || ({ dom: h, contentDOM: p } = si.renderSpec(document, t.type.spec.toDOM(t)));
    !p && !t.isText && h.nodeName != "BR" && (h.hasAttribute("contenteditable") || (h.contentEditable = "false"), t.type.spec.draggable && (h.draggable = !0));
    let g = h;
    return h = rw(h, r, t), d ? u = new KR(e, t, r, i, h, p || null, g, d, o, a + 1) : t.isText ? new qc(e, t, r, i, h, g, o) : new Ni(e, t, r, i, h, p || null, g, o, a + 1);
  }
  parseRule() {
    if (this.node.type.spec.reparseInView)
      return null;
    let e = { node: this.node.type.name, attrs: this.node.attrs };
    if (this.node.type.whitespace == "pre" && (e.preserveWhitespace = "full"), !this.contentDOM)
      e.getContent = () => this.node.content;
    else if (!this.contentLost)
      e.contentElement = this.contentDOM;
    else {
      for (let t = this.children.length - 1; t >= 0; t--) {
        let r = this.children[t];
        if (this.dom.contains(r.dom.parentNode)) {
          e.contentElement = r.dom.parentNode;
          break;
        }
      }
      e.contentElement || (e.getContent = () => ue.empty);
    }
    return e;
  }
  matchesNode(e, t, r) {
    return this.dirty == pr && e.eq(this.node) && If(t, this.outerDeco) && r.eq(this.innerDeco);
  }
  get size() {
    return this.node.nodeSize;
  }
  get border() {
    return this.node.isLeaf ? 0 : 1;
  }
  // Syncs `this.children` to match `this.node.content` and the local
  // decorations, possibly introducing nesting for marks. Then, in a
  // separate step, syncs the DOM inside `this.contentDOM` to
  // `this.children`.
  updateChildren(e, t) {
    let r = this.node.inlineContent, i = t, o = e.composing ? this.localCompositionInfo(e, t) : null, a = o && o.pos > -1 ? o : null, l = o && o.pos < 0, u = new JR(this, a && a.node, e);
    t4(this.node, this.innerDeco, (d, h, p) => {
      d.spec.marks ? u.syncToMarks(d.spec.marks, r, e) : d.type.side >= 0 && !p && u.syncToMarks(h == this.node.childCount ? ct.none : this.node.child(h).marks, r, e), u.placeWidget(d, e, i);
    }, (d, h, p, g) => {
      u.syncToMarks(d.marks, r, e);
      let v;
      u.findNodeMatch(d, h, p, g) || l && e.state.selection.from > i && e.state.selection.to < i + d.nodeSize && (v = u.findIndexWithChild(o.node)) > -1 && u.updateNodeAt(d, h, p, v, e) || u.updateNextNode(d, h, p, e, g, i) || u.addNode(d, h, p, e, i), i += d.nodeSize;
    }), u.syncToMarks([], r, e), this.node.isTextblock && u.addTextblockHacks(), u.destroyRest(), (u.changed || this.dirty == ho) && (a && this.protectLocalComposition(e, a), tw(this.contentDOM, this.children, e), us && n4(this.dom));
  }
  localCompositionInfo(e, t) {
    let { from: r, to: i } = e.state.selection;
    if (!(e.state.selection instanceof it) || r < t || i > t + this.node.content.size)
      return null;
    let o = e.domSelectionRange(), a = r4(o.focusNode, o.focusOffset);
    if (!a || !this.dom.contains(a.parentNode))
      return null;
    if (this.node.inlineContent) {
      let l = a.nodeValue, u = i4(this.node.content, l, r - t, i - t);
      return u < 0 ? null : { node: a, pos: u, text: l };
    } else
      return { node: a, pos: -1, text: "" };
  }
  protectLocalComposition(e, { node: t, pos: r, text: i }) {
    if (this.getDesc(t))
      return;
    let o = t;
    for (; o.parentNode != this.contentDOM; o = o.parentNode) {
      for (; o.previousSibling; )
        o.parentNode.removeChild(o.previousSibling);
      for (; o.nextSibling; )
        o.parentNode.removeChild(o.nextSibling);
      o.pmViewDesc && (o.pmViewDesc = void 0);
    }
    let a = new GR(this, o, t, i);
    e.input.compositionNodes.push(a), this.children = Af(this.children, r, r + i.length, e, a);
  }
  // If this desc must be updated to match the given node decoration,
  // do so and return true.
  update(e, t, r, i) {
    return this.dirty == $r || !e.sameMarkup(this.node) ? !1 : (this.updateInner(e, t, r, i), !0);
  }
  updateInner(e, t, r, i) {
    this.updateOuterDeco(t), this.node = e, this.innerDeco = r, this.contentDOM && this.updateChildren(i, this.posAtStart), this.dirty = pr;
  }
  updateOuterDeco(e) {
    if (If(e, this.outerDeco))
      return;
    let t = this.nodeDOM.nodeType != 1, r = this.dom;
    this.dom = nw(this.dom, this.nodeDOM, Df(this.outerDeco, this.node, t), Df(e, this.node, t)), this.dom != r && (r.pmViewDesc = void 0, this.dom.pmViewDesc = this), this.outerDeco = e;
  }
  // Mark this node as being the selected node.
  selectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.add("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && (this.dom.draggable = !0);
  }
  // Remove selected node marking from this node.
  deselectNode() {
    this.nodeDOM.nodeType == 1 && this.nodeDOM.classList.remove("ProseMirror-selectednode"), (this.contentDOM || !this.node.type.spec.draggable) && this.dom.removeAttribute("draggable");
  }
  get domAtom() {
    return this.node.isAtom;
  }
}
function um(n, e, t, r, i) {
  rw(r, e, n);
  let o = new Ni(void 0, n, e, t, r, r, r, i, 0);
  return o.contentDOM && o.updateChildren(i, 0), o;
}
class qc extends Ni {
  constructor(e, t, r, i, o, a, l) {
    super(e, t, r, i, o, null, a, l, 0);
  }
  parseRule() {
    let e = this.nodeDOM.parentNode;
    for (; e && e != this.dom && !e.pmIsDeco; )
      e = e.parentNode;
    return { skip: e || !0 };
  }
  update(e, t, r, i) {
    return this.dirty == $r || this.dirty != pr && !this.inParent() || !e.sameMarkup(this.node) ? !1 : (this.updateOuterDeco(t), (this.dirty != pr || e.text != this.node.text) && e.text != this.nodeDOM.nodeValue && (this.nodeDOM.nodeValue = e.text, i.trackWrites == this.nodeDOM && (i.trackWrites = null)), this.node = e, this.dirty = pr, !0);
  }
  inParent() {
    let e = this.parent.contentDOM;
    for (let t = this.nodeDOM; t; t = t.parentNode)
      if (t == e)
        return !0;
    return !1;
  }
  domFromPos(e) {
    return { node: this.nodeDOM, offset: e };
  }
  localPosFromDOM(e, t, r) {
    return e == this.nodeDOM ? this.posAtStart + Math.min(t, this.node.text.length) : super.localPosFromDOM(e, t, r);
  }
  ignoreMutation(e) {
    return e.type != "characterData" && e.type != "selection";
  }
  slice(e, t, r) {
    let i = this.node.cut(e, t), o = document.createTextNode(i.text);
    return new qc(this.parent, i, this.outerDeco, this.innerDeco, o, o, r);
  }
  markDirty(e, t) {
    super.markDirty(e, t), this.dom != this.nodeDOM && (e == 0 || t == this.nodeDOM.nodeValue.length) && (this.dirty = $r);
  }
  get domAtom() {
    return !1;
  }
}
class ew extends Da {
  parseRule() {
    return { ignore: !0 };
  }
  matchesHack(e) {
    return this.dirty == pr && this.dom.nodeName == e;
  }
  get domAtom() {
    return !0;
  }
  get ignoreForCoords() {
    return this.dom.nodeName == "IMG";
  }
}
class KR extends Ni {
  constructor(e, t, r, i, o, a, l, u, d, h) {
    super(e, t, r, i, o, a, l, d, h), this.spec = u;
  }
  // A custom `update` method gets to decide whether the update goes
  // through. If it does, and there's a `contentDOM` node, our logic
  // updates the children.
  update(e, t, r, i) {
    if (this.dirty == $r)
      return !1;
    if (this.spec.update) {
      let o = this.spec.update(e, t, r);
      return o && this.updateInner(e, t, r, i), o;
    } else
      return !this.contentDOM && !e.isLeaf ? !1 : super.update(e, t, r, i);
  }
  selectNode() {
    this.spec.selectNode ? this.spec.selectNode() : super.selectNode();
  }
  deselectNode() {
    this.spec.deselectNode ? this.spec.deselectNode() : super.deselectNode();
  }
  setSelection(e, t, r, i) {
    this.spec.setSelection ? this.spec.setSelection(e, t, r) : super.setSelection(e, t, r, i);
  }
  destroy() {
    this.spec.destroy && this.spec.destroy(), super.destroy();
  }
  stopEvent(e) {
    return this.spec.stopEvent ? this.spec.stopEvent(e) : !1;
  }
  ignoreMutation(e) {
    return this.spec.ignoreMutation ? this.spec.ignoreMutation(e) : super.ignoreMutation(e);
  }
}
function tw(n, e, t) {
  let r = n.firstChild, i = !1;
  for (let o = 0; o < e.length; o++) {
    let a = e[o], l = a.dom;
    if (l.parentNode == n) {
      for (; l != r; )
        r = dm(r), i = !0;
      r = r.nextSibling;
    } else
      i = !0, n.insertBefore(l, r);
    if (a instanceof Co) {
      let u = r ? r.previousSibling : n.lastChild;
      tw(a.contentDOM, a.children, t), r = u ? u.nextSibling : n.firstChild;
    }
  }
  for (; r; )
    r = dm(r), i = !0;
  i && t.trackWrites == n && (t.trackWrites = null);
}
const Js = function(n) {
  n && (this.nodeName = n);
};
Js.prototype = /* @__PURE__ */ Object.create(null);
const po = [new Js()];
function Df(n, e, t) {
  if (n.length == 0)
    return po;
  let r = t ? po[0] : new Js(), i = [r];
  for (let o = 0; o < n.length; o++) {
    let a = n[o].type.attrs;
    if (a) {
      a.nodeName && i.push(r = new Js(a.nodeName));
      for (let l in a) {
        let u = a[l];
        u != null && (t && i.length == 1 && i.push(r = new Js(e.isInline ? "span" : "div")), l == "class" ? r.class = (r.class ? r.class + " " : "") + u : l == "style" ? r.style = (r.style ? r.style + ";" : "") + u : l != "nodeName" && (r[l] = u));
      }
    }
  }
  return i;
}
function nw(n, e, t, r) {
  if (t == po && r == po)
    return e;
  let i = e;
  for (let o = 0; o < r.length; o++) {
    let a = r[o], l = t[o];
    if (o) {
      let u;
      l && l.nodeName == a.nodeName && i != n && (u = i.parentNode) && u.nodeName.toLowerCase() == a.nodeName || (u = document.createElement(a.nodeName), u.pmIsDeco = !0, u.appendChild(i), l = po[0]), i = u;
    }
    XR(i, l || po[0], a);
  }
  return i;
}
function XR(n, e, t) {
  for (let r in e)
    r != "class" && r != "style" && r != "nodeName" && !(r in t) && n.removeAttribute(r);
  for (let r in t)
    r != "class" && r != "style" && r != "nodeName" && t[r] != e[r] && n.setAttribute(r, t[r]);
  if (e.class != t.class) {
    let r = e.class ? e.class.split(" ").filter(Boolean) : [], i = t.class ? t.class.split(" ").filter(Boolean) : [];
    for (let o = 0; o < r.length; o++)
      i.indexOf(r[o]) == -1 && n.classList.remove(r[o]);
    for (let o = 0; o < i.length; o++)
      r.indexOf(i[o]) == -1 && n.classList.add(i[o]);
    n.classList.length == 0 && n.removeAttribute("class");
  }
  if (e.style != t.style) {
    if (e.style) {
      let r = /\s*([\w\-\xa1-\uffff]+)\s*:(?:"(?:\\.|[^"])*"|'(?:\\.|[^'])*'|\(.*?\)|[^;])*/g, i;
      for (; i = r.exec(e.style); )
        n.style.removeProperty(i[1]);
    }
    t.style && (n.style.cssText += t.style);
  }
}
function rw(n, e, t) {
  return nw(n, n, po, Df(e, t, n.nodeType != 1));
}
function If(n, e) {
  if (n.length != e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (!n[t].type.eq(e[t].type))
      return !1;
  return !0;
}
function dm(n) {
  let e = n.nextSibling;
  return n.parentNode.removeChild(n), e;
}
class JR {
  constructor(e, t, r) {
    this.lock = t, this.view = r, this.index = 0, this.stack = [], this.changed = !1, this.top = e, this.preMatch = QR(e.node.content, e);
  }
  // Destroy and remove the children between the given indices in
  // `this.top`.
  destroyBetween(e, t) {
    if (e != t) {
      for (let r = e; r < t; r++)
        this.top.children[r].destroy();
      this.top.children.splice(e, t - e), this.changed = !0;
    }
  }
  // Destroy all remaining children in `this.top`.
  destroyRest() {
    this.destroyBetween(this.index, this.top.children.length);
  }
  // Sync the current stack of mark descs with the given array of
  // marks, reusing existing mark descs when possible.
  syncToMarks(e, t, r) {
    let i = 0, o = this.stack.length >> 1, a = Math.min(o, e.length);
    for (; i < a && (i == o - 1 ? this.top : this.stack[i + 1 << 1]).matchesMark(e[i]) && e[i].type.spec.spanning !== !1; )
      i++;
    for (; i < o; )
      this.destroyRest(), this.top.dirty = pr, this.index = this.stack.pop(), this.top = this.stack.pop(), o--;
    for (; o < e.length; ) {
      this.stack.push(this.top, this.index + 1);
      let l = -1;
      for (let u = this.index; u < Math.min(this.index + 3, this.top.children.length); u++) {
        let d = this.top.children[u];
        if (d.matchesMark(e[o]) && !this.isLocked(d.dom)) {
          l = u;
          break;
        }
      }
      if (l > -1)
        l > this.index && (this.changed = !0, this.destroyBetween(this.index, l)), this.top = this.top.children[this.index];
      else {
        let u = Co.create(this.top, e[o], t, r);
        this.top.children.splice(this.index, 0, u), this.top = u, this.changed = !0;
      }
      this.index = 0, o++;
    }
  }
  // Try to find a node desc matching the given data. Skip over it and
  // return true when successful.
  findNodeMatch(e, t, r, i) {
    let o = -1, a;
    if (i >= this.preMatch.index && (a = this.preMatch.matches[i - this.preMatch.index]).parent == this.top && a.matchesNode(e, t, r))
      o = this.top.children.indexOf(a, this.index);
    else
      for (let l = this.index, u = Math.min(this.top.children.length, l + 5); l < u; l++) {
        let d = this.top.children[l];
        if (d.matchesNode(e, t, r) && !this.preMatch.matched.has(d)) {
          o = l;
          break;
        }
      }
    return o < 0 ? !1 : (this.destroyBetween(this.index, o), this.index++, !0);
  }
  updateNodeAt(e, t, r, i, o) {
    let a = this.top.children[i];
    return a.dirty == $r && a.dom == a.contentDOM && (a.dirty = ho), a.update(e, t, r, o) ? (this.destroyBetween(this.index, i), this.index++, !0) : !1;
  }
  findIndexWithChild(e) {
    for (; ; ) {
      let t = e.parentNode;
      if (!t)
        return -1;
      if (t == this.top.contentDOM) {
        let r = e.pmViewDesc;
        if (r) {
          for (let i = this.index; i < this.top.children.length; i++)
            if (this.top.children[i] == r)
              return i;
        }
        return -1;
      }
      e = t;
    }
  }
  // Try to update the next node, if any, to the given data. Checks
  // pre-matches to avoid overwriting nodes that could still be used.
  updateNextNode(e, t, r, i, o, a) {
    for (let l = this.index; l < this.top.children.length; l++) {
      let u = this.top.children[l];
      if (u instanceof Ni) {
        let d = this.preMatch.matched.get(u);
        if (d != null && d != o)
          return !1;
        let h = u.dom, p, g = this.isLocked(h) && !(e.isText && u.node && u.node.isText && u.nodeDOM.nodeValue == e.text && u.dirty != $r && If(t, u.outerDeco));
        if (!g && u.update(e, t, r, i))
          return this.destroyBetween(this.index, l), u.dom != h && (this.changed = !0), this.index++, !0;
        if (!g && (p = this.recreateWrapper(u, e, t, r, i, a)))
          return this.top.children[this.index] = p, p.contentDOM && (p.dirty = ho, p.updateChildren(i, a + 1), p.dirty = pr), this.changed = !0, this.index++, !0;
        break;
      }
    }
    return !1;
  }
  // When a node with content is replaced by a different node with
  // identical content, move over its children.
  recreateWrapper(e, t, r, i, o, a) {
    if (e.dirty || t.isAtom || !e.children.length || !e.node.content.eq(t.content))
      return null;
    let l = Ni.create(this.top, t, r, i, o, a);
    if (l.contentDOM) {
      l.children = e.children, e.children = [];
      for (let u of l.children)
        u.parent = l;
    }
    return e.destroy(), l;
  }
  // Insert the node as a newly created node desc.
  addNode(e, t, r, i, o) {
    let a = Ni.create(this.top, e, t, r, i, o);
    a.contentDOM && a.updateChildren(i, o + 1), this.top.children.splice(this.index++, 0, a), this.changed = !0;
  }
  placeWidget(e, t, r) {
    let i = this.index < this.top.children.length ? this.top.children[this.index] : null;
    if (i && i.matchesWidget(e) && (e == i.widget || !i.widget.type.toDOM.parentNode))
      this.index++;
    else {
      let o = new Qy(this.top, e, t, r);
      this.top.children.splice(this.index++, 0, o), this.changed = !0;
    }
  }
  // Make sure a textblock looks and behaves correctly in
  // contentEditable.
  addTextblockHacks() {
    let e = this.top.children[this.index - 1], t = this.top;
    for (; e instanceof Co; )
      t = e, e = t.children[t.children.length - 1];
    (!e || // Empty textblock
    !(e instanceof qc) || /\n$/.test(e.node.text) || this.view.requiresGeckoHackNode && /\s$/.test(e.node.text)) && ((En || gn) && e && e.dom.contentEditable == "false" && this.addHackNode("IMG", t), this.addHackNode("BR", this.top));
  }
  addHackNode(e, t) {
    if (t == this.top && this.index < t.children.length && t.children[this.index].matchesHack(e))
      this.index++;
    else {
      let r = document.createElement(e);
      e == "IMG" && (r.className = "ProseMirror-separator", r.alt = ""), e == "BR" && (r.className = "ProseMirror-trailingBreak");
      let i = new ew(this.top, [], r, null);
      t != this.top ? t.children.push(i) : t.children.splice(this.index++, 0, i), this.changed = !0;
    }
  }
  isLocked(e) {
    return this.lock && (e == this.lock || e.nodeType == 1 && e.contains(this.lock.parentNode));
  }
}
function QR(n, e) {
  let t = e, r = t.children.length, i = n.childCount, o = /* @__PURE__ */ new Map(), a = [];
  e:
    for (; i > 0; ) {
      let l;
      for (; ; )
        if (r) {
          let d = t.children[r - 1];
          if (d instanceof Co)
            t = d, r = d.children.length;
          else {
            l = d, r--;
            break;
          }
        } else {
          if (t == e)
            break e;
          r = t.parent.children.indexOf(t), t = t.parent;
        }
      let u = l.node;
      if (u) {
        if (u != n.child(i - 1))
          break;
        --i, o.set(l, i), a.push(l);
      }
    }
  return { index: i, matched: o, matches: a.reverse() };
}
function e4(n, e) {
  return n.type.side - e.type.side;
}
function t4(n, e, t, r) {
  let i = e.locals(n), o = 0;
  if (i.length == 0) {
    for (let d = 0; d < n.childCount; d++) {
      let h = n.child(d);
      r(h, i, e.forChild(o, h), d), o += h.nodeSize;
    }
    return;
  }
  let a = 0, l = [], u = null;
  for (let d = 0; ; ) {
    let h, p;
    for (; a < i.length && i[a].to == o; ) {
      let b = i[a++];
      b.widget && (h ? (p || (p = [h])).push(b) : h = b);
    }
    if (h)
      if (p) {
        p.sort(e4);
        for (let b = 0; b < p.length; b++)
          t(p[b], d, !!u);
      } else
        t(h, d, !!u);
    let g, v;
    if (u)
      v = -1, g = u, u = null;
    else if (d < n.childCount)
      v = d, g = n.child(d++);
    else
      break;
    for (let b = 0; b < l.length; b++)
      l[b].to <= o && l.splice(b--, 1);
    for (; a < i.length && i[a].from <= o && i[a].to > o; )
      l.push(i[a++]);
    let m = o + g.nodeSize;
    if (g.isText) {
      let b = m;
      a < i.length && i[a].from < b && (b = i[a].from);
      for (let C = 0; C < l.length; C++)
        l[C].to < b && (b = l[C].to);
      b < m && (u = g.cut(b - o), g = g.cut(0, b - o), m = b, v = -1);
    }
    let w = g.isInline && !g.isLeaf ? l.filter((b) => !b.inline) : l.slice();
    r(g, w, e.forChild(o, g), v), o = m;
  }
}
function n4(n) {
  if (n.nodeName == "UL" || n.nodeName == "OL") {
    let e = n.style.cssText;
    n.style.cssText = e + "; list-style: square !important", window.getComputedStyle(n).listStyle, n.style.cssText = e;
  }
}
function r4(n, e) {
  for (; ; ) {
    if (n.nodeType == 3)
      return n;
    if (n.nodeType == 1 && e > 0) {
      if (n.childNodes.length > e && n.childNodes[e].nodeType == 3)
        return n.childNodes[e];
      n = n.childNodes[e - 1], e = Br(n);
    } else if (n.nodeType == 1 && e < n.childNodes.length)
      n = n.childNodes[e], e = 0;
    else
      return null;
  }
}
function i4(n, e, t, r) {
  for (let i = 0, o = 0; i < n.childCount && o <= r; ) {
    let a = n.child(i++), l = o;
    if (o += a.nodeSize, !a.isText)
      continue;
    let u = a.text;
    for (; i < n.childCount; ) {
      let d = n.child(i++);
      if (o += d.nodeSize, !d.isText)
        break;
      u += d.text;
    }
    if (o >= t) {
      if (o >= r && u.slice(r - e.length - l, r - l) == e)
        return r - e.length;
      let d = l < r ? u.lastIndexOf(e, r - l - 1) : -1;
      if (d >= 0 && d + e.length + l >= t)
        return l + d;
      if (t == r && u.length >= r + e.length - l && u.slice(r - l, r - l + e.length) == e)
        return r;
    }
  }
  return -1;
}
function Af(n, e, t, r, i) {
  let o = [];
  for (let a = 0, l = 0; a < n.length; a++) {
    let u = n[a], d = l, h = l += u.size;
    d >= t || h <= e ? o.push(u) : (d < e && o.push(u.slice(0, e - d, r)), i && (o.push(i), i = void 0), h > t && o.push(u.slice(t - d, u.size, r)));
  }
  return o;
}
function gh(n, e = null) {
  let t = n.domSelectionRange(), r = n.state.doc;
  if (!t.focusNode)
    return null;
  let i = n.docView.nearestDesc(t.focusNode), o = i && i.size == 0, a = n.docView.posFromDOM(t.focusNode, t.focusOffset, 1);
  if (a < 0)
    return null;
  let l = r.resolve(a), u, d;
  if (Yc(t)) {
    for (u = l; i && !i.node; )
      i = i.parent;
    let h = i.node;
    if (i && h.isAtom && He.isSelectable(h) && i.parent && !(h.isInline && MR(t.focusNode, t.focusOffset, i.dom))) {
      let p = i.posBefore;
      d = new He(a == p ? l : r.resolve(p));
    }
  } else {
    let h = n.docView.posFromDOM(t.anchorNode, t.anchorOffset, 1);
    if (h < 0)
      return null;
    u = r.resolve(h);
  }
  if (!d) {
    let h = e == "pointer" || n.state.selection.head < l.pos && !o ? 1 : -1;
    d = mh(n, u, l, h);
  }
  return d;
}
function iw(n) {
  return n.editable ? n.hasFocus() : sw(n) && document.activeElement && document.activeElement.contains(n.dom);
}
function ai(n, e = !1) {
  let t = n.state.selection;
  if (ow(n, t), !!iw(n)) {
    if (!e && n.input.mouseDown && n.input.mouseDown.allowDefault && gn) {
      let r = n.domSelectionRange(), i = n.domObserver.currentSelection;
      if (r.anchorNode && i.anchorNode && So(r.anchorNode, r.anchorOffset, i.anchorNode, i.anchorOffset)) {
        n.input.mouseDown.delayedSelectionSync = !0, n.domObserver.setCurSelection();
        return;
      }
    }
    if (n.domObserver.disconnectSelection(), n.cursorWrapper)
      s4(n);
    else {
      let { anchor: r, head: i } = t, o, a;
      fm && !(t instanceof it) && (t.$from.parent.inlineContent || (o = hm(n, t.from)), !t.empty && !t.$from.parent.inlineContent && (a = hm(n, t.to))), n.docView.setSelection(r, i, n.root, e), fm && (o && pm(o), a && pm(a)), t.visible ? n.dom.classList.remove("ProseMirror-hideselection") : (n.dom.classList.add("ProseMirror-hideselection"), "onselectionchange" in document && o4(n));
    }
    n.domObserver.setCurSelection(), n.domObserver.connectSelection();
  }
}
const fm = En || gn && IR < 63;
function hm(n, e) {
  let { node: t, offset: r } = n.docView.domFromPos(e, 0), i = r < t.childNodes.length ? t.childNodes[r] : null, o = r ? t.childNodes[r - 1] : null;
  if (En && i && i.contentEditable == "false")
    return _d(i);
  if ((!i || i.contentEditable == "false") && (!o || o.contentEditable == "false")) {
    if (i)
      return _d(i);
    if (o)
      return _d(o);
  }
}
function _d(n) {
  return n.contentEditable = "true", En && n.draggable && (n.draggable = !1, n.wasDraggable = !0), n;
}
function pm(n) {
  n.contentEditable = "false", n.wasDraggable && (n.draggable = !0, n.wasDraggable = null);
}
function o4(n) {
  let e = n.dom.ownerDocument;
  e.removeEventListener("selectionchange", n.input.hideSelectionGuard);
  let t = n.domSelectionRange(), r = t.anchorNode, i = t.anchorOffset;
  e.addEventListener("selectionchange", n.input.hideSelectionGuard = () => {
    (t.anchorNode != r || t.anchorOffset != i) && (e.removeEventListener("selectionchange", n.input.hideSelectionGuard), setTimeout(() => {
      (!iw(n) || n.state.selection.visible) && n.dom.classList.remove("ProseMirror-hideselection");
    }, 20));
  });
}
function s4(n) {
  let e = n.domSelection(), t = document.createRange(), r = n.cursorWrapper.dom, i = r.nodeName == "IMG";
  i ? t.setEnd(r.parentNode, Cn(r) + 1) : t.setEnd(r, 0), t.collapse(!1), e.removeAllRanges(), e.addRange(t), !i && !n.state.selection.visible && Pn && _i <= 11 && (r.disabled = !0, r.disabled = !1);
}
function ow(n, e) {
  if (e instanceof He) {
    let t = n.docView.descAt(e.from);
    t != n.lastSelectedViewDesc && (gm(n), t && t.selectNode(), n.lastSelectedViewDesc = t);
  } else
    gm(n);
}
function gm(n) {
  n.lastSelectedViewDesc && (n.lastSelectedViewDesc.parent && n.lastSelectedViewDesc.deselectNode(), n.lastSelectedViewDesc = void 0);
}
function mh(n, e, t, r) {
  return n.someProp("createSelectionBetween", (i) => i(n, e, t)) || it.between(e, t, r);
}
function mm(n) {
  return n.editable && !n.hasFocus() ? !1 : sw(n);
}
function sw(n) {
  let e = n.domSelectionRange();
  if (!e.anchorNode)
    return !1;
  try {
    return n.dom.contains(e.anchorNode.nodeType == 3 ? e.anchorNode.parentNode : e.anchorNode) && (n.editable || n.dom.contains(e.focusNode.nodeType == 3 ? e.focusNode.parentNode : e.focusNode));
  } catch {
    return !1;
  }
}
function a4(n) {
  let e = n.docView.domFromPos(n.state.selection.anchor, 0), t = n.domSelectionRange();
  return So(e.node, e.offset, t.anchorNode, t.anchorOffset);
}
function Lf(n, e) {
  let { $anchor: t, $head: r } = n.selection, i = e > 0 ? t.max(r) : t.min(r), o = i.parent.inlineContent ? i.depth ? n.doc.resolve(e > 0 ? i.after() : i.before()) : null : i;
  return o && rt.findFrom(o, e);
}
function Ti(n, e) {
  return n.dispatch(n.state.tr.setSelection(e).scrollIntoView()), !0;
}
function vm(n, e, t) {
  let r = n.state.selection;
  if (r instanceof it)
    if (t.indexOf("s") > -1) {
      let { $head: i } = r, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter;
      if (!o || o.isText || !o.isLeaf)
        return !1;
      let a = n.state.doc.resolve(i.pos + o.nodeSize * (e < 0 ? -1 : 1));
      return Ti(n, new it(r.$anchor, a));
    } else if (r.empty) {
      if (n.endOfTextblock(e > 0 ? "forward" : "backward")) {
        let i = Lf(n.state, e);
        return i && i instanceof He ? Ti(n, i) : !1;
      } else if (!(ur && t.indexOf("m") > -1)) {
        let i = r.$head, o = i.textOffset ? null : e < 0 ? i.nodeBefore : i.nodeAfter, a;
        if (!o || o.isText)
          return !1;
        let l = e < 0 ? i.pos - o.nodeSize : i.pos;
        return o.isAtom || (a = n.docView.descAt(l)) && !a.contentDOM ? He.isSelectable(o) ? Ti(n, new He(e < 0 ? n.state.doc.resolve(i.pos - o.nodeSize) : i)) : Ra ? Ti(n, new it(n.state.doc.resolve(e < 0 ? l : l + o.nodeSize))) : !1 : !1;
      }
    } else
      return !1;
  else {
    if (r instanceof He && r.node.isInline)
      return Ti(n, new it(e > 0 ? r.$to : r.$from));
    {
      let i = Lf(n.state, e);
      return i ? Ti(n, i) : !1;
    }
  }
}
function hc(n) {
  return n.nodeType == 3 ? n.nodeValue.length : n.childNodes.length;
}
function Qs(n, e) {
  let t = n.pmViewDesc;
  return t && t.size == 0 && (e < 0 || n.nextSibling || n.nodeName != "BR");
}
function Yo(n, e) {
  return e < 0 ? l4(n) : c4(n);
}
function l4(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i, o, a = !1;
  for (Tr && t.nodeType == 1 && r < hc(t) && Qs(t.childNodes[r], -1) && (a = !0); ; )
    if (r > 0) {
      if (t.nodeType != 1)
        break;
      {
        let l = t.childNodes[r - 1];
        if (Qs(l, -1))
          i = t, o = --r;
        else if (l.nodeType == 3)
          t = l, r = t.nodeValue.length;
        else
          break;
      }
    } else {
      if (aw(t))
        break;
      {
        let l = t.previousSibling;
        for (; l && Qs(l, -1); )
          i = t.parentNode, o = Cn(l), l = l.previousSibling;
        if (l)
          t = l, r = hc(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = 0;
        }
      }
    }
  a ? Pf(n, t, r) : i && Pf(n, i, o);
}
function c4(n) {
  let e = n.domSelectionRange(), t = e.focusNode, r = e.focusOffset;
  if (!t)
    return;
  let i = hc(t), o, a;
  for (; ; )
    if (r < i) {
      if (t.nodeType != 1)
        break;
      let l = t.childNodes[r];
      if (Qs(l, 1))
        o = t, a = ++r;
      else
        break;
    } else {
      if (aw(t))
        break;
      {
        let l = t.nextSibling;
        for (; l && Qs(l, 1); )
          o = l.parentNode, a = Cn(l) + 1, l = l.nextSibling;
        if (l)
          t = l, r = 0, i = hc(t);
        else {
          if (t = t.parentNode, t == n.dom)
            break;
          r = i = 0;
        }
      }
    }
  o && Pf(n, o, a);
}
function aw(n) {
  let e = n.pmViewDesc;
  return e && e.node && e.node.isBlock;
}
function u4(n, e) {
  for (; n && e == n.childNodes.length && !hh(n); )
    e = Cn(n) + 1, n = n.parentNode;
  for (; n && e < n.childNodes.length; ) {
    let t = n.childNodes[e];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = 0;
  }
}
function d4(n, e) {
  for (; n && !e && !hh(n); )
    e = Cn(n), n = n.parentNode;
  for (; n && e; ) {
    let t = n.childNodes[e - 1];
    if (t.nodeType == 3)
      return t;
    if (t.nodeType == 1 && t.contentEditable == "false")
      break;
    n = t, e = n.childNodes.length;
  }
}
function Pf(n, e, t) {
  if (e.nodeType != 3) {
    let o, a;
    (a = u4(e, t)) ? (e = a, t = 0) : (o = d4(e, t)) && (e = o, t = o.nodeValue.length);
  }
  let r = n.domSelection();
  if (Yc(r)) {
    let o = document.createRange();
    o.setEnd(e, t), o.setStart(e, t), r.removeAllRanges(), r.addRange(o);
  } else
    r.extend && r.extend(e, t);
  n.domObserver.setCurSelection();
  let { state: i } = n;
  setTimeout(() => {
    n.state == i && ai(n);
  }, 50);
}
function ym(n, e) {
  let t = n.state.doc.resolve(e);
  if (!(gn || AR) && t.parent.inlineContent) {
    let i = n.coordsAtPos(e);
    if (e > t.start()) {
      let o = n.coordsAtPos(e - 1), a = (o.top + o.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left < i.left ? "ltr" : "rtl";
    }
    if (e < t.end()) {
      let o = n.coordsAtPos(e + 1), a = (o.top + o.bottom) / 2;
      if (a > i.top && a < i.bottom && Math.abs(o.left - i.left) > 1)
        return o.left > i.left ? "ltr" : "rtl";
    }
  }
  return getComputedStyle(n.dom).direction == "rtl" ? "rtl" : "ltr";
}
function wm(n, e, t) {
  let r = n.state.selection;
  if (r instanceof it && !r.empty || t.indexOf("s") > -1 || ur && t.indexOf("m") > -1)
    return !1;
  let { $from: i, $to: o } = r;
  if (!i.parent.inlineContent || n.endOfTextblock(e < 0 ? "up" : "down")) {
    let a = Lf(n.state, e);
    if (a && a instanceof He)
      return Ti(n, a);
  }
  if (!i.parent.inlineContent) {
    let a = e < 0 ? i : o, l = r instanceof Ln ? rt.near(a, e) : rt.findFrom(a, e);
    return l ? Ti(n, l) : !1;
  }
  return !1;
}
function bm(n, e) {
  if (!(n.state.selection instanceof it))
    return !0;
  let { $head: t, $anchor: r, empty: i } = n.state.selection;
  if (!t.sameParent(r))
    return !0;
  if (!i)
    return !1;
  if (n.endOfTextblock(e > 0 ? "forward" : "backward"))
    return !0;
  let o = !t.textOffset && (e < 0 ? t.nodeBefore : t.nodeAfter);
  if (o && !o.isText) {
    let a = n.state.tr;
    return e < 0 ? a.delete(t.pos - o.nodeSize, t.pos) : a.delete(t.pos, t.pos + o.nodeSize), n.dispatch(a), !0;
  }
  return !1;
}
function xm(n, e, t) {
  n.domObserver.stop(), e.contentEditable = t, n.domObserver.start();
}
function f4(n) {
  if (!En || n.state.selection.$head.parentOffset > 0)
    return !1;
  let { focusNode: e, focusOffset: t } = n.domSelectionRange();
  if (e && e.nodeType == 1 && t == 0 && e.firstChild && e.firstChild.contentEditable == "false") {
    let r = e.firstChild;
    xm(n, r, "true"), setTimeout(() => xm(n, r, "false"), 20);
  }
  return !1;
}
function h4(n) {
  let e = "";
  return n.ctrlKey && (e += "c"), n.metaKey && (e += "m"), n.altKey && (e += "a"), n.shiftKey && (e += "s"), e;
}
function p4(n, e) {
  let t = e.keyCode, r = h4(e);
  if (t == 8 || ur && t == 72 && r == "c")
    return bm(n, -1) || Yo(n, -1);
  if (t == 46 && !e.shiftKey || ur && t == 68 && r == "c")
    return bm(n, 1) || Yo(n, 1);
  if (t == 13 || t == 27)
    return !0;
  if (t == 37 || ur && t == 66 && r == "c") {
    let i = t == 37 ? ym(n, n.state.selection.from) == "ltr" ? -1 : 1 : -1;
    return vm(n, i, r) || Yo(n, i);
  } else if (t == 39 || ur && t == 70 && r == "c") {
    let i = t == 39 ? ym(n, n.state.selection.from) == "ltr" ? 1 : -1 : 1;
    return vm(n, i, r) || Yo(n, i);
  } else {
    if (t == 38 || ur && t == 80 && r == "c")
      return wm(n, -1, r) || Yo(n, -1);
    if (t == 40 || ur && t == 78 && r == "c")
      return f4(n) || wm(n, 1, r) || Yo(n, 1);
    if (r == (ur ? "m" : "c") && (t == 66 || t == 73 || t == 89 || t == 90))
      return !0;
  }
  return !1;
}
function lw(n, e) {
  n.someProp("transformCopied", (v) => {
    e = v(e, n);
  });
  let t = [], { content: r, openStart: i, openEnd: o } = e;
  for (; i > 1 && o > 1 && r.childCount == 1 && r.firstChild.childCount == 1; ) {
    i--, o--;
    let v = r.firstChild;
    t.push(v.type.name, v.attrs != v.type.defaultAttrs ? v.attrs : null), r = v.content;
  }
  let a = n.someProp("clipboardSerializer") || si.fromSchema(n.state.schema), l = pw(), u = l.createElement("div");
  u.appendChild(a.serializeFragment(r, { document: l }));
  let d = u.firstChild, h, p = 0;
  for (; d && d.nodeType == 1 && (h = hw[d.nodeName.toLowerCase()]); ) {
    for (let v = h.length - 1; v >= 0; v--) {
      let m = l.createElement(h[v]);
      for (; u.firstChild; )
        m.appendChild(u.firstChild);
      u.appendChild(m), p++;
    }
    d = u.firstChild;
  }
  d && d.nodeType == 1 && d.setAttribute("data-pm-slice", `${i} ${o}${p ? ` -${p}` : ""} ${JSON.stringify(t)}`);
  let g = n.someProp("clipboardTextSerializer", (v) => v(e, n)) || e.content.textBetween(0, e.content.size, `

`);
  return { dom: u, text: g };
}
function cw(n, e, t, r, i) {
  let o = i.parent.type.spec.code, a, l;
  if (!t && !e)
    return null;
  let u = e && (r || o || !t);
  if (u) {
    if (n.someProp("transformPastedText", (g) => {
      e = g(e, o || r, n);
    }), o)
      return e ? new ke(ue.from(n.state.schema.text(e.replace(/\r\n?/g, `
`))), 0, 0) : ke.empty;
    let p = n.someProp("clipboardTextParser", (g) => g(e, i, r, n));
    if (p)
      l = p;
    else {
      let g = i.marks(), { schema: v } = n.state, m = si.fromSchema(v);
      a = document.createElement("div"), e.split(/(?:\r\n?|\n)+/).forEach((w) => {
        let b = a.appendChild(document.createElement("p"));
        w && b.appendChild(m.serializeNode(v.text(w, g)));
      });
    }
  } else
    n.someProp("transformPastedHTML", (p) => {
      t = p(t, n);
    }), a = v4(t), Ra && y4(a);
  let d = a && a.querySelector("[data-pm-slice]"), h = d && /^(\d+) (\d+)(?: -(\d+))? (.*)/.exec(d.getAttribute("data-pm-slice") || "");
  if (h && h[3])
    for (let p = +h[3]; p > 0; p--) {
      let g = a.firstChild;
      for (; g && g.nodeType != 1; )
        g = g.nextSibling;
      if (!g)
        break;
      a = g;
    }
  if (l || (l = (n.someProp("clipboardParser") || n.someProp("domParser") || xo.fromSchema(n.state.schema)).parseSlice(a, {
    preserveWhitespace: !!(u || h),
    context: i,
    ruleFromNode(g) {
      return g.nodeName == "BR" && !g.nextSibling && g.parentNode && !g4.test(g.parentNode.nodeName) ? { ignore: !0 } : null;
    }
  })), h)
    l = w4(Sm(l, +h[1], +h[2]), h[4]);
  else if (l = ke.maxOpen(m4(l.content, i), !0), l.openStart || l.openEnd) {
    let p = 0, g = 0;
    for (let v = l.content.firstChild; p < l.openStart && !v.type.spec.isolating; p++, v = v.firstChild)
      ;
    for (let v = l.content.lastChild; g < l.openEnd && !v.type.spec.isolating; g++, v = v.lastChild)
      ;
    l = Sm(l, p, g);
  }
  return n.someProp("transformPasted", (p) => {
    l = p(l, n);
  }), l;
}
const g4 = /^(a|abbr|acronym|b|cite|code|del|em|i|ins|kbd|label|output|q|ruby|s|samp|span|strong|sub|sup|time|u|tt|var)$/i;
function m4(n, e) {
  if (n.childCount < 2)
    return n;
  for (let t = e.depth; t >= 0; t--) {
    let i = e.node(t).contentMatchAt(e.index(t)), o, a = [];
    if (n.forEach((l) => {
      if (!a)
        return;
      let u = i.findWrapping(l.type), d;
      if (!u)
        return a = null;
      if (d = a.length && o.length && dw(u, o, l, a[a.length - 1], 0))
        a[a.length - 1] = d;
      else {
        a.length && (a[a.length - 1] = fw(a[a.length - 1], o.length));
        let h = uw(l, u);
        a.push(h), i = i.matchType(h.type), o = u;
      }
    }), a)
      return ue.from(a);
  }
  return n;
}
function uw(n, e, t = 0) {
  for (let r = e.length - 1; r >= t; r--)
    n = e[r].create(null, ue.from(n));
  return n;
}
function dw(n, e, t, r, i) {
  if (i < n.length && i < e.length && n[i] == e[i]) {
    let o = dw(n, e, t, r.lastChild, i + 1);
    if (o)
      return r.copy(r.content.replaceChild(r.childCount - 1, o));
    if (r.contentMatchAt(r.childCount).matchType(i == n.length - 1 ? t.type : n[i + 1]))
      return r.copy(r.content.append(ue.from(uw(t, n, i + 1))));
  }
}
function fw(n, e) {
  if (e == 0)
    return n;
  let t = n.content.replaceChild(n.childCount - 1, fw(n.lastChild, e - 1)), r = n.contentMatchAt(n.childCount).fillBefore(ue.empty, !0);
  return n.copy(t.append(r));
}
function _f(n, e, t, r, i, o) {
  let a = e < 0 ? n.firstChild : n.lastChild, l = a.content;
  return n.childCount > 1 && (o = 0), i < r - 1 && (l = _f(l, e, t, r, i + 1, o)), i >= t && (l = e < 0 ? a.contentMatchAt(0).fillBefore(l, o <= i).append(l) : l.append(a.contentMatchAt(a.childCount).fillBefore(ue.empty, !0))), n.replaceChild(e < 0 ? 0 : n.childCount - 1, a.copy(l));
}
function Sm(n, e, t) {
  return e < n.openStart && (n = new ke(_f(n.content, -1, e, n.openStart, 0, n.openEnd), e, n.openEnd)), t < n.openEnd && (n = new ke(_f(n.content, 1, t, n.openEnd, 0, 0), n.openStart, t)), n;
}
const hw = {
  thead: ["table"],
  tbody: ["table"],
  tfoot: ["table"],
  caption: ["table"],
  colgroup: ["table"],
  col: ["table", "colgroup"],
  tr: ["table", "tbody"],
  td: ["table", "tbody", "tr"],
  th: ["table", "tbody", "tr"]
};
let Cm = null;
function pw() {
  return Cm || (Cm = document.implementation.createHTMLDocument("title"));
}
function v4(n) {
  let e = /^(\s*<meta [^>]*>)*/.exec(n);
  e && (n = n.slice(e[0].length));
  let t = pw().createElement("div"), r = /<([a-z][^>\s]+)/i.exec(n), i;
  if ((i = r && hw[r[1].toLowerCase()]) && (n = i.map((o) => "<" + o + ">").join("") + n + i.map((o) => "</" + o + ">").reverse().join("")), t.innerHTML = n, i)
    for (let o = 0; o < i.length; o++)
      t = t.querySelector(i[o]) || t;
  return t;
}
function y4(n) {
  let e = n.querySelectorAll(gn ? "span:not([class]):not([style])" : "span.Apple-converted-space");
  for (let t = 0; t < e.length; t++) {
    let r = e[t];
    r.childNodes.length == 1 && r.textContent == " " && r.parentNode && r.parentNode.replaceChild(n.ownerDocument.createTextNode(" "), r);
  }
}
function w4(n, e) {
  if (!n.size)
    return n;
  let t = n.content.firstChild.type.schema, r;
  try {
    r = JSON.parse(e);
  } catch {
    return n;
  }
  let { content: i, openStart: o, openEnd: a } = n;
  for (let l = r.length - 2; l >= 0; l -= 2) {
    let u = t.nodes[r[l]];
    if (!u || u.hasRequiredAttrs())
      break;
    i = ue.from(u.create(r[l + 1], i)), o++, a++;
  }
  return new ke(i, o, a);
}
const kn = {}, On = {}, b4 = { touchstart: !0, touchmove: !0 };
class x4 {
  constructor() {
    this.shiftKey = !1, this.mouseDown = null, this.lastKeyCode = null, this.lastKeyCodeTime = 0, this.lastClick = { time: 0, x: 0, y: 0, type: "" }, this.lastSelectionOrigin = null, this.lastSelectionTime = 0, this.lastIOSEnter = 0, this.lastIOSEnterFallbackTimeout = -1, this.lastFocus = 0, this.lastTouch = 0, this.lastAndroidDelete = 0, this.composing = !1, this.composingTimeout = -1, this.compositionNodes = [], this.compositionEndedAt = -2e8, this.compositionID = 1, this.compositionPendingChanges = 0, this.domChangeCount = 0, this.eventHandlers = /* @__PURE__ */ Object.create(null), this.hideSelectionGuard = null;
  }
}
function S4(n) {
  for (let e in kn) {
    let t = kn[e];
    n.dom.addEventListener(e, n.input.eventHandlers[e] = (r) => {
      E4(n, r) && !vh(n, r) && (n.editable || !(r.type in On)) && t(n, r);
    }, b4[e] ? { passive: !0 } : void 0);
  }
  En && n.dom.addEventListener("input", () => null), Nf(n);
}
function Li(n, e) {
  n.input.lastSelectionOrigin = e, n.input.lastSelectionTime = Date.now();
}
function C4(n) {
  n.domObserver.stop();
  for (let e in n.input.eventHandlers)
    n.dom.removeEventListener(e, n.input.eventHandlers[e]);
  clearTimeout(n.input.composingTimeout), clearTimeout(n.input.lastIOSEnterFallbackTimeout);
}
function Nf(n) {
  n.someProp("handleDOMEvents", (e) => {
    for (let t in e)
      n.input.eventHandlers[t] || n.dom.addEventListener(t, n.input.eventHandlers[t] = (r) => vh(n, r));
  });
}
function vh(n, e) {
  return n.someProp("handleDOMEvents", (t) => {
    let r = t[e.type];
    return r ? r(n, e) || e.defaultPrevented : !1;
  });
}
function E4(n, e) {
  if (!e.bubbles)
    return !0;
  if (e.defaultPrevented)
    return !1;
  for (let t = e.target; t != n.dom; t = t.parentNode)
    if (!t || t.nodeType == 11 || t.pmViewDesc && t.pmViewDesc.stopEvent(e))
      return !1;
  return !0;
}
function k4(n, e) {
  !vh(n, e) && kn[e.type] && (n.editable || !(e.type in On)) && kn[e.type](n, e);
}
On.keydown = (n, e) => {
  let t = e;
  if (n.input.shiftKey = t.keyCode == 16 || t.shiftKey, !mw(n, t) && (n.input.lastKeyCode = t.keyCode, n.input.lastKeyCodeTime = Date.now(), !(kr && gn && t.keyCode == 13)))
    if (t.keyCode != 229 && n.domObserver.forceFlush(), us && t.keyCode == 13 && !t.ctrlKey && !t.altKey && !t.metaKey) {
      let r = Date.now();
      n.input.lastIOSEnter = r, n.input.lastIOSEnterFallbackTimeout = setTimeout(() => {
        n.input.lastIOSEnter == r && (n.someProp("handleKeyDown", (i) => i(n, fo(13, "Enter"))), n.input.lastIOSEnter = 0);
      }, 200);
    } else
      n.someProp("handleKeyDown", (r) => r(n, t)) || p4(n, t) ? t.preventDefault() : Li(n, "key");
};
On.keyup = (n, e) => {
  e.keyCode == 16 && (n.input.shiftKey = !1);
};
On.keypress = (n, e) => {
  let t = e;
  if (mw(n, t) || !t.charCode || t.ctrlKey && !t.altKey || ur && t.metaKey)
    return;
  if (n.someProp("handleKeyPress", (i) => i(n, t))) {
    t.preventDefault();
    return;
  }
  let r = n.state.selection;
  if (!(r instanceof it) || !r.$from.sameParent(r.$to)) {
    let i = String.fromCharCode(t.charCode);
    !/[\r\n]/.test(i) && !n.someProp("handleTextInput", (o) => o(n, r.$from.pos, r.$to.pos, i)) && n.dispatch(n.state.tr.insertText(i).scrollIntoView()), t.preventDefault();
  }
};
function Gc(n) {
  return { left: n.clientX, top: n.clientY };
}
function O4(n, e) {
  let t = e.x - n.clientX, r = e.y - n.clientY;
  return t * t + r * r < 100;
}
function yh(n, e, t, r, i) {
  if (r == -1)
    return !1;
  let o = n.state.doc.resolve(r);
  for (let a = o.depth + 1; a > 0; a--)
    if (n.someProp(e, (l) => a > o.depth ? l(n, t, o.nodeAfter, o.before(a), i, !0) : l(n, t, o.node(a), o.before(a), i, !1)))
      return !0;
  return !1;
}
function rs(n, e, t) {
  n.focused || n.focus();
  let r = n.state.tr.setSelection(e);
  t == "pointer" && r.setMeta("pointer", !0), n.dispatch(r);
}
function T4(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.doc.resolve(e), r = t.nodeAfter;
  return r && r.isAtom && He.isSelectable(r) ? (rs(n, new He(t), "pointer"), !0) : !1;
}
function M4(n, e) {
  if (e == -1)
    return !1;
  let t = n.state.selection, r, i;
  t instanceof He && (r = t.node);
  let o = n.state.doc.resolve(e);
  for (let a = o.depth + 1; a > 0; a--) {
    let l = a > o.depth ? o.nodeAfter : o.node(a);
    if (He.isSelectable(l)) {
      r && t.$from.depth > 0 && a >= t.$from.depth && o.before(t.$from.depth + 1) == t.$from.pos ? i = o.before(t.$from.depth) : i = o.before(a);
      break;
    }
  }
  return i != null ? (rs(n, He.create(n.state.doc, i), "pointer"), !0) : !1;
}
function R4(n, e, t, r, i) {
  return yh(n, "handleClickOn", e, t, r) || n.someProp("handleClick", (o) => o(n, e, r)) || (i ? M4(n, t) : T4(n, t));
}
function D4(n, e, t, r) {
  return yh(n, "handleDoubleClickOn", e, t, r) || n.someProp("handleDoubleClick", (i) => i(n, e, r));
}
function I4(n, e, t, r) {
  return yh(n, "handleTripleClickOn", e, t, r) || n.someProp("handleTripleClick", (i) => i(n, e, r)) || A4(n, t, r);
}
function A4(n, e, t) {
  if (t.button != 0)
    return !1;
  let r = n.state.doc;
  if (e == -1)
    return r.inlineContent ? (rs(n, it.create(r, 0, r.content.size), "pointer"), !0) : !1;
  let i = r.resolve(e);
  for (let o = i.depth + 1; o > 0; o--) {
    let a = o > i.depth ? i.nodeAfter : i.node(o), l = i.before(o);
    if (a.inlineContent)
      rs(n, it.create(r, l + 1, l + 1 + a.content.size), "pointer");
    else if (He.isSelectable(a))
      rs(n, He.create(r, l), "pointer");
    else
      continue;
    return !0;
  }
}
function wh(n) {
  return pc(n);
}
const gw = ur ? "metaKey" : "ctrlKey";
kn.mousedown = (n, e) => {
  let t = e;
  n.input.shiftKey = t.shiftKey;
  let r = wh(n), i = Date.now(), o = "singleClick";
  i - n.input.lastClick.time < 500 && O4(t, n.input.lastClick) && !t[gw] && (n.input.lastClick.type == "singleClick" ? o = "doubleClick" : n.input.lastClick.type == "doubleClick" && (o = "tripleClick")), n.input.lastClick = { time: i, x: t.clientX, y: t.clientY, type: o };
  let a = n.posAtCoords(Gc(t));
  a && (o == "singleClick" ? (n.input.mouseDown && n.input.mouseDown.done(), n.input.mouseDown = new L4(n, a, t, !!r)) : (o == "doubleClick" ? D4 : I4)(n, a.pos, a.inside, t) ? t.preventDefault() : Li(n, "pointer"));
};
class L4 {
  constructor(e, t, r, i) {
    this.view = e, this.pos = t, this.event = r, this.flushed = i, this.delayedSelectionSync = !1, this.mightDrag = null, this.startDoc = e.state.doc, this.selectNode = !!r[gw], this.allowDefault = r.shiftKey;
    let o, a;
    if (t.inside > -1)
      o = e.state.doc.nodeAt(t.inside), a = t.inside;
    else {
      let h = e.state.doc.resolve(t.pos);
      o = h.parent, a = h.depth ? h.before() : 0;
    }
    const l = i ? null : r.target, u = l ? e.docView.nearestDesc(l, !0) : null;
    this.target = u ? u.dom : null;
    let { selection: d } = e.state;
    (r.button == 0 && o.type.spec.draggable && o.type.spec.selectable !== !1 || d instanceof He && d.from <= a && d.to > a) && (this.mightDrag = {
      node: o,
      pos: a,
      addAttr: !!(this.target && !this.target.draggable),
      setUneditable: !!(this.target && Tr && !this.target.hasAttribute("contentEditable"))
    }), this.target && this.mightDrag && (this.mightDrag.addAttr || this.mightDrag.setUneditable) && (this.view.domObserver.stop(), this.mightDrag.addAttr && (this.target.draggable = !0), this.mightDrag.setUneditable && setTimeout(() => {
      this.view.input.mouseDown == this && this.target.setAttribute("contentEditable", "false");
    }, 20), this.view.domObserver.start()), e.root.addEventListener("mouseup", this.up = this.up.bind(this)), e.root.addEventListener("mousemove", this.move = this.move.bind(this)), Li(e, "pointer");
  }
  done() {
    this.view.root.removeEventListener("mouseup", this.up), this.view.root.removeEventListener("mousemove", this.move), this.mightDrag && this.target && (this.view.domObserver.stop(), this.mightDrag.addAttr && this.target.removeAttribute("draggable"), this.mightDrag.setUneditable && this.target.removeAttribute("contentEditable"), this.view.domObserver.start()), this.delayedSelectionSync && setTimeout(() => ai(this.view)), this.view.input.mouseDown = null;
  }
  up(e) {
    if (this.done(), !this.view.dom.contains(e.target))
      return;
    let t = this.pos;
    this.view.state.doc != this.startDoc && (t = this.view.posAtCoords(Gc(e))), this.updateAllowDefault(e), this.allowDefault || !t ? Li(this.view, "pointer") : R4(this.view, t.pos, t.inside, e, this.selectNode) ? e.preventDefault() : e.button == 0 && (this.flushed || // Safari ignores clicks on draggable elements
    En && this.mightDrag && !this.mightDrag.node.isAtom || // Chrome will sometimes treat a node selection as a
    // cursor, but still report that the node is selected
    // when asked through getSelection. You'll then get a
    // situation where clicking at the point where that
    // (hidden) cursor is doesn't change the selection, and
    // thus doesn't get a reaction from ProseMirror. This
    // works around that.
    gn && !this.view.state.selection.visible && Math.min(Math.abs(t.pos - this.view.state.selection.from), Math.abs(t.pos - this.view.state.selection.to)) <= 2) ? (rs(this.view, rt.near(this.view.state.doc.resolve(t.pos)), "pointer"), e.preventDefault()) : Li(this.view, "pointer");
  }
  move(e) {
    this.updateAllowDefault(e), Li(this.view, "pointer"), e.buttons == 0 && this.done();
  }
  updateAllowDefault(e) {
    !this.allowDefault && (Math.abs(this.event.x - e.clientX) > 4 || Math.abs(this.event.y - e.clientY) > 4) && (this.allowDefault = !0);
  }
}
kn.touchstart = (n) => {
  n.input.lastTouch = Date.now(), wh(n), Li(n, "pointer");
};
kn.touchmove = (n) => {
  n.input.lastTouch = Date.now(), Li(n, "pointer");
};
kn.contextmenu = (n) => wh(n);
function mw(n, e) {
  return n.composing ? !0 : En && Math.abs(e.timeStamp - n.input.compositionEndedAt) < 500 ? (n.input.compositionEndedAt = -2e8, !0) : !1;
}
const P4 = kr ? 5e3 : -1;
On.compositionstart = On.compositionupdate = (n) => {
  if (!n.composing) {
    n.domObserver.flush();
    let { state: e } = n, t = e.selection.$from;
    if (e.selection.empty && (e.storedMarks || !t.textOffset && t.parentOffset && t.nodeBefore.marks.some((r) => r.type.spec.inclusive === !1)))
      n.markCursor = n.state.storedMarks || t.marks(), pc(n, !0), n.markCursor = null;
    else if (pc(n), Tr && e.selection.empty && t.parentOffset && !t.textOffset && t.nodeBefore.marks.length) {
      let r = n.domSelectionRange();
      for (let i = r.focusNode, o = r.focusOffset; i && i.nodeType == 1 && o != 0; ) {
        let a = o < 0 ? i.lastChild : i.childNodes[o - 1];
        if (!a)
          break;
        if (a.nodeType == 3) {
          n.domSelection().collapse(a, a.nodeValue.length);
          break;
        } else
          i = a, o = -1;
      }
    }
    n.input.composing = !0;
  }
  vw(n, P4);
};
On.compositionend = (n, e) => {
  n.composing && (n.input.composing = !1, n.input.compositionEndedAt = e.timeStamp, n.input.compositionPendingChanges = n.domObserver.pendingRecords().length ? n.input.compositionID : 0, n.input.compositionPendingChanges && Promise.resolve().then(() => n.domObserver.flush()), n.input.compositionID++, vw(n, 20));
};
function vw(n, e) {
  clearTimeout(n.input.composingTimeout), e > -1 && (n.input.composingTimeout = setTimeout(() => pc(n), e));
}
function yw(n) {
  for (n.composing && (n.input.composing = !1, n.input.compositionEndedAt = _4()); n.input.compositionNodes.length > 0; )
    n.input.compositionNodes.pop().markParentsDirty();
}
function _4() {
  let n = document.createEvent("Event");
  return n.initEvent("event", !0, !0), n.timeStamp;
}
function pc(n, e = !1) {
  if (!(kr && n.domObserver.flushingSoon >= 0)) {
    if (n.domObserver.forceFlush(), yw(n), e || n.docView && n.docView.dirty) {
      let t = gh(n);
      return t && !t.eq(n.state.selection) ? n.dispatch(n.state.tr.setSelection(t)) : n.updateState(n.state), !0;
    }
    return !1;
  }
}
function N4(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.dom.parentNode.appendChild(document.createElement("div"));
  t.appendChild(e), t.style.cssText = "position: fixed; left: -10000px; top: 10px";
  let r = getSelection(), i = document.createRange();
  i.selectNodeContents(e), n.dom.blur(), r.removeAllRanges(), r.addRange(i), setTimeout(() => {
    t.parentNode && t.parentNode.removeChild(t), n.focus();
  }, 50);
}
const ds = Pn && _i < 15 || us && LR < 604;
kn.copy = On.cut = (n, e) => {
  let t = e, r = n.state.selection, i = t.type == "cut";
  if (r.empty)
    return;
  let o = ds ? null : t.clipboardData, a = r.content(), { dom: l, text: u } = lw(n, a);
  o ? (t.preventDefault(), o.clearData(), o.setData("text/html", l.innerHTML), o.setData("text/plain", u)) : N4(n, l), i && n.dispatch(n.state.tr.deleteSelection().scrollIntoView().setMeta("uiEvent", "cut"));
};
function z4(n) {
  return n.openStart == 0 && n.openEnd == 0 && n.content.childCount == 1 ? n.content.firstChild : null;
}
function B4(n, e) {
  if (!n.dom.parentNode)
    return;
  let t = n.input.shiftKey || n.state.selection.$from.parent.type.spec.code, r = n.dom.parentNode.appendChild(document.createElement(t ? "textarea" : "div"));
  t || (r.contentEditable = "true"), r.style.cssText = "position: fixed; left: -10000px; top: 10px", r.focus();
  let i = n.input.shiftKey && n.input.lastKeyCode != 45;
  setTimeout(() => {
    n.focus(), r.parentNode && r.parentNode.removeChild(r), t ? pa(n, r.value, null, i, e) : pa(n, r.textContent, r.innerHTML, i, e);
  }, 50);
}
function pa(n, e, t, r, i) {
  let o = cw(n, e, t, r, n.state.selection.$from);
  if (n.someProp("handlePaste", (u) => u(n, i, o || ke.empty)))
    return !0;
  if (!o)
    return !1;
  let a = z4(o), l = a ? n.state.tr.replaceSelectionWith(a, r) : n.state.tr.replaceSelection(o);
  return n.dispatch(l.scrollIntoView().setMeta("paste", !0).setMeta("uiEvent", "paste")), !0;
}
On.paste = (n, e) => {
  let t = e;
  if (n.composing && !kr)
    return;
  let r = ds ? null : t.clipboardData, i = n.input.shiftKey && n.input.lastKeyCode != 45;
  r && pa(n, r.getData("text/plain"), r.getData("text/html"), i, t) ? t.preventDefault() : B4(n, t);
};
class F4 {
  constructor(e, t) {
    this.slice = e, this.move = t;
  }
}
const ww = ur ? "altKey" : "ctrlKey";
kn.dragstart = (n, e) => {
  let t = e, r = n.input.mouseDown;
  if (r && r.done(), !t.dataTransfer)
    return;
  let i = n.state.selection, o = i.empty ? null : n.posAtCoords(Gc(t));
  if (!(o && o.pos >= i.from && o.pos <= (i instanceof He ? i.to - 1 : i.to))) {
    if (r && r.mightDrag)
      n.dispatch(n.state.tr.setSelection(He.create(n.state.doc, r.mightDrag.pos)));
    else if (t.target && t.target.nodeType == 1) {
      let d = n.docView.nearestDesc(t.target, !0);
      d && d.node.type.spec.draggable && d != n.docView && n.dispatch(n.state.tr.setSelection(He.create(n.state.doc, d.posBefore)));
    }
  }
  let a = n.state.selection.content(), { dom: l, text: u } = lw(n, a);
  t.dataTransfer.clearData(), t.dataTransfer.setData(ds ? "Text" : "text/html", l.innerHTML), t.dataTransfer.effectAllowed = "copyMove", ds || t.dataTransfer.setData("text/plain", u), n.dragging = new F4(a, !t[ww]);
};
kn.dragend = (n) => {
  let e = n.dragging;
  window.setTimeout(() => {
    n.dragging == e && (n.dragging = null);
  }, 50);
};
On.dragover = On.dragenter = (n, e) => e.preventDefault();
On.drop = (n, e) => {
  let t = e, r = n.dragging;
  if (n.dragging = null, !t.dataTransfer)
    return;
  let i = n.posAtCoords(Gc(t));
  if (!i)
    return;
  let o = n.state.doc.resolve(i.pos), a = r && r.slice;
  a ? n.someProp("transformPasted", (m) => {
    a = m(a, n);
  }) : a = cw(n, t.dataTransfer.getData(ds ? "Text" : "text/plain"), ds ? null : t.dataTransfer.getData("text/html"), !1, o);
  let l = !!(r && !t[ww]);
  if (n.someProp("handleDrop", (m) => m(n, t, a || ke.empty, l))) {
    t.preventDefault();
    return;
  }
  if (!a)
    return;
  t.preventDefault();
  let u = a ? WM(n.state.doc, o.pos, a) : o.pos;
  u == null && (u = o.pos);
  let d = n.state.tr;
  l && d.deleteSelection();
  let h = d.mapping.map(u), p = a.openStart == 0 && a.openEnd == 0 && a.content.childCount == 1, g = d.doc;
  if (p ? d.replaceRangeWith(h, h, a.content.firstChild) : d.replaceRange(h, h, a), d.doc.eq(g))
    return;
  let v = d.doc.resolve(h);
  if (p && He.isSelectable(a.content.firstChild) && v.nodeAfter && v.nodeAfter.sameMarkup(a.content.firstChild))
    d.setSelection(new He(v));
  else {
    let m = d.mapping.map(u);
    d.mapping.maps[d.mapping.maps.length - 1].forEach((w, b, C, M) => m = M), d.setSelection(mh(n, v, d.doc.resolve(m)));
  }
  n.focus(), n.dispatch(d.setMeta("uiEvent", "drop"));
};
kn.focus = (n) => {
  n.input.lastFocus = Date.now(), n.focused || (n.domObserver.stop(), n.dom.classList.add("ProseMirror-focused"), n.domObserver.start(), n.focused = !0, setTimeout(() => {
    n.docView && n.hasFocus() && !n.domObserver.currentSelection.eq(n.domSelectionRange()) && ai(n);
  }, 20));
};
kn.blur = (n, e) => {
  let t = e;
  n.focused && (n.domObserver.stop(), n.dom.classList.remove("ProseMirror-focused"), n.domObserver.start(), t.relatedTarget && n.dom.contains(t.relatedTarget) && n.domObserver.currentSelection.clear(), n.focused = !1);
};
kn.beforeinput = (n, e) => {
  if (gn && kr && e.inputType == "deleteContentBackward") {
    n.domObserver.flushSoon();
    let { domChangeCount: r } = n.input;
    setTimeout(() => {
      if (n.input.domChangeCount != r || (n.dom.blur(), n.focus(), n.someProp("handleKeyDown", (o) => o(n, fo(8, "Backspace")))))
        return;
      let { $cursor: i } = n.state.selection;
      i && i.pos > 0 && n.dispatch(n.state.tr.delete(i.pos - 1, i.pos).scrollIntoView());
    }, 50);
  }
};
for (let n in On)
  kn[n] = On[n];
function ga(n, e) {
  if (n == e)
    return !0;
  for (let t in n)
    if (n[t] !== e[t])
      return !1;
  for (let t in e)
    if (!(t in n))
      return !1;
  return !0;
}
class gc {
  constructor(e, t) {
    this.toDOM = e, this.spec = t || yo, this.side = this.spec.side || 0;
  }
  map(e, t, r, i) {
    let { pos: o, deleted: a } = e.mapResult(t.from + i, this.side < 0 ? -1 : 1);
    return a ? null : new fr(o - r, o - r, this);
  }
  valid() {
    return !0;
  }
  eq(e) {
    return this == e || e instanceof gc && (this.spec.key && this.spec.key == e.spec.key || this.toDOM == e.toDOM && ga(this.spec, e.spec));
  }
  destroy(e) {
    this.spec.destroy && this.spec.destroy(e);
  }
}
class zi {
  constructor(e, t) {
    this.attrs = e, this.spec = t || yo;
  }
  map(e, t, r, i) {
    let o = e.map(t.from + i, this.spec.inclusiveStart ? -1 : 1) - r, a = e.map(t.to + i, this.spec.inclusiveEnd ? 1 : -1) - r;
    return o >= a ? null : new fr(o, a, this);
  }
  valid(e, t) {
    return t.from < t.to;
  }
  eq(e) {
    return this == e || e instanceof zi && ga(this.attrs, e.attrs) && ga(this.spec, e.spec);
  }
  static is(e) {
    return e.type instanceof zi;
  }
  destroy() {
  }
}
class bh {
  constructor(e, t) {
    this.attrs = e, this.spec = t || yo;
  }
  map(e, t, r, i) {
    let o = e.mapResult(t.from + i, 1);
    if (o.deleted)
      return null;
    let a = e.mapResult(t.to + i, -1);
    return a.deleted || a.pos <= o.pos ? null : new fr(o.pos - r, a.pos - r, this);
  }
  valid(e, t) {
    let { index: r, offset: i } = e.content.findIndex(t.from), o;
    return i == t.from && !(o = e.child(r)).isText && i + o.nodeSize == t.to;
  }
  eq(e) {
    return this == e || e instanceof bh && ga(this.attrs, e.attrs) && ga(this.spec, e.spec);
  }
  destroy() {
  }
}
class fr {
  /**
  @internal
  */
  constructor(e, t, r) {
    this.from = e, this.to = t, this.type = r;
  }
  /**
  @internal
  */
  copy(e, t) {
    return new fr(e, t, this.type);
  }
  /**
  @internal
  */
  eq(e, t = 0) {
    return this.type.eq(e.type) && this.from + t == e.from && this.to + t == e.to;
  }
  /**
  @internal
  */
  map(e, t, r) {
    return this.type.map(e, this, t, r);
  }
  /**
  Creates a widget decoration, which is a DOM node that's shown in
  the document at the given position. It is recommended that you
  delay rendering the widget by passing a function that will be
  called when the widget is actually drawn in a view, but you can
  also directly pass a DOM node. `getPos` can be used to find the
  widget's current document position.
  */
  static widget(e, t, r) {
    return new fr(e, e, new gc(t, r));
  }
  /**
  Creates an inline decoration, which adds the given attributes to
  each inline node between `from` and `to`.
  */
  static inline(e, t, r, i) {
    return new fr(e, t, new zi(r, i));
  }
  /**
  Creates a node decoration. `from` and `to` should point precisely
  before and after a node in the document. That node, and only that
  node, will receive the given attributes.
  */
  static node(e, t, r, i) {
    return new fr(e, t, new bh(r, i));
  }
  /**
  The spec provided when creating this decoration. Can be useful
  if you've stored extra information in that object.
  */
  get spec() {
    return this.type.spec;
  }
  /**
  @internal
  */
  get inline() {
    return this.type instanceof zi;
  }
  /**
  @internal
  */
  get widget() {
    return this.type instanceof gc;
  }
}
const Ko = [], yo = {};
class Ut {
  /**
  @internal
  */
  constructor(e, t) {
    this.local = e.length ? e : Ko, this.children = t.length ? t : Ko;
  }
  /**
  Create a set of decorations, using the structure of the given
  document. This will consume (modify) the `decorations` array, so
  you must make a copy if you want need to preserve that.
  */
  static create(e, t) {
    return t.length ? mc(t, e, 0, yo) : dn;
  }
  /**
  Find all decorations in this set which touch the given range
  (including decorations that start or end directly at the
  boundaries) and match the given predicate on their spec. When
  `start` and `end` are omitted, all decorations in the set are
  considered. When `predicate` isn't given, all decorations are
  assumed to match.
  */
  find(e, t, r) {
    let i = [];
    return this.findInner(e ?? 0, t ?? 1e9, i, 0, r), i;
  }
  findInner(e, t, r, i, o) {
    for (let a = 0; a < this.local.length; a++) {
      let l = this.local[a];
      l.from <= t && l.to >= e && (!o || o(l.spec)) && r.push(l.copy(l.from + i, l.to + i));
    }
    for (let a = 0; a < this.children.length; a += 3)
      if (this.children[a] < t && this.children[a + 1] > e) {
        let l = this.children[a] + 1;
        this.children[a + 2].findInner(e - l, t - l, r, i + l, o);
      }
  }
  /**
  Map the set of decorations in response to a change in the
  document.
  */
  map(e, t, r) {
    return this == dn || e.maps.length == 0 ? this : this.mapInner(e, t, 0, 0, r || yo);
  }
  /**
  @internal
  */
  mapInner(e, t, r, i, o) {
    let a;
    for (let l = 0; l < this.local.length; l++) {
      let u = this.local[l].map(e, r, i);
      u && u.type.valid(t, u) ? (a || (a = [])).push(u) : o.onRemove && o.onRemove(this.local[l].spec);
    }
    return this.children.length ? V4(this.children, a || [], e, t, r, i, o) : a ? new Ut(a.sort(wo), Ko) : dn;
  }
  /**
  Add the given array of decorations to the ones in the set,
  producing a new set. Consumes the `decorations` array. Needs
  access to the current document to create the appropriate tree
  structure.
  */
  add(e, t) {
    return t.length ? this == dn ? Ut.create(e, t) : this.addInner(e, t, 0) : this;
  }
  addInner(e, t, r) {
    let i, o = 0;
    e.forEach((l, u) => {
      let d = u + r, h;
      if (h = xw(t, l, d)) {
        for (i || (i = this.children.slice()); o < i.length && i[o] < u; )
          o += 3;
        i[o] == u ? i[o + 2] = i[o + 2].addInner(l, h, d + 1) : i.splice(o, 0, u, u + l.nodeSize, mc(h, l, d + 1, yo)), o += 3;
      }
    });
    let a = bw(o ? Sw(t) : t, -r);
    for (let l = 0; l < a.length; l++)
      a[l].type.valid(e, a[l]) || a.splice(l--, 1);
    return new Ut(a.length ? this.local.concat(a).sort(wo) : this.local, i || this.children);
  }
  /**
  Create a new set that contains the decorations in this set, minus
  the ones in the given array.
  */
  remove(e) {
    return e.length == 0 || this == dn ? this : this.removeInner(e, 0);
  }
  removeInner(e, t) {
    let r = this.children, i = this.local;
    for (let o = 0; o < r.length; o += 3) {
      let a, l = r[o] + t, u = r[o + 1] + t;
      for (let h = 0, p; h < e.length; h++)
        (p = e[h]) && p.from > l && p.to < u && (e[h] = null, (a || (a = [])).push(p));
      if (!a)
        continue;
      r == this.children && (r = this.children.slice());
      let d = r[o + 2].removeInner(a, l + 1);
      d != dn ? r[o + 2] = d : (r.splice(o, 3), o -= 3);
    }
    if (i.length) {
      for (let o = 0, a; o < e.length; o++)
        if (a = e[o])
          for (let l = 0; l < i.length; l++)
            i[l].eq(a, t) && (i == this.local && (i = this.local.slice()), i.splice(l--, 1));
    }
    return r == this.children && i == this.local ? this : i.length || r.length ? new Ut(i, r) : dn;
  }
  /**
  @internal
  */
  forChild(e, t) {
    if (this == dn)
      return this;
    if (t.isLeaf)
      return Ut.empty;
    let r, i;
    for (let l = 0; l < this.children.length; l += 3)
      if (this.children[l] >= e) {
        this.children[l] == e && (r = this.children[l + 2]);
        break;
      }
    let o = e + 1, a = o + t.content.size;
    for (let l = 0; l < this.local.length; l++) {
      let u = this.local[l];
      if (u.from < a && u.to > o && u.type instanceof zi) {
        let d = Math.max(o, u.from) - o, h = Math.min(a, u.to) - o;
        d < h && (i || (i = [])).push(u.copy(d, h));
      }
    }
    if (i) {
      let l = new Ut(i.sort(wo), Ko);
      return r ? new Di([l, r]) : l;
    }
    return r || dn;
  }
  /**
  @internal
  */
  eq(e) {
    if (this == e)
      return !0;
    if (!(e instanceof Ut) || this.local.length != e.local.length || this.children.length != e.children.length)
      return !1;
    for (let t = 0; t < this.local.length; t++)
      if (!this.local[t].eq(e.local[t]))
        return !1;
    for (let t = 0; t < this.children.length; t += 3)
      if (this.children[t] != e.children[t] || this.children[t + 1] != e.children[t + 1] || !this.children[t + 2].eq(e.children[t + 2]))
        return !1;
    return !0;
  }
  /**
  @internal
  */
  locals(e) {
    return xh(this.localsInner(e));
  }
  /**
  @internal
  */
  localsInner(e) {
    if (this == dn)
      return Ko;
    if (e.inlineContent || !this.local.some(zi.is))
      return this.local;
    let t = [];
    for (let r = 0; r < this.local.length; r++)
      this.local[r].type instanceof zi || t.push(this.local[r]);
    return t;
  }
}
Ut.empty = new Ut([], []);
Ut.removeOverlap = xh;
const dn = Ut.empty;
class Di {
  constructor(e) {
    this.members = e;
  }
  map(e, t) {
    const r = this.members.map((i) => i.map(e, t, yo));
    return Di.from(r);
  }
  forChild(e, t) {
    if (t.isLeaf)
      return Ut.empty;
    let r = [];
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].forChild(e, t);
      o != dn && (o instanceof Di ? r = r.concat(o.members) : r.push(o));
    }
    return Di.from(r);
  }
  eq(e) {
    if (!(e instanceof Di) || e.members.length != this.members.length)
      return !1;
    for (let t = 0; t < this.members.length; t++)
      if (!this.members[t].eq(e.members[t]))
        return !1;
    return !0;
  }
  locals(e) {
    let t, r = !0;
    for (let i = 0; i < this.members.length; i++) {
      let o = this.members[i].localsInner(e);
      if (o.length)
        if (!t)
          t = o;
        else {
          r && (t = t.slice(), r = !1);
          for (let a = 0; a < o.length; a++)
            t.push(o[a]);
        }
    }
    return t ? xh(r ? t : t.sort(wo)) : Ko;
  }
  // Create a group for the given array of decoration sets, or return
  // a single set when possible.
  static from(e) {
    switch (e.length) {
      case 0:
        return dn;
      case 1:
        return e[0];
      default:
        return new Di(e.every((t) => t instanceof Ut) ? e : e.reduce((t, r) => t.concat(r instanceof Ut ? r : r.members), []));
    }
  }
}
function V4(n, e, t, r, i, o, a) {
  let l = n.slice();
  for (let d = 0, h = o; d < t.maps.length; d++) {
    let p = 0;
    t.maps[d].forEach((g, v, m, w) => {
      let b = w - m - (v - g);
      for (let C = 0; C < l.length; C += 3) {
        let M = l[C + 1];
        if (M < 0 || g > M + h - p)
          continue;
        let k = l[C] + h - p;
        v >= k ? l[C + 1] = g <= k ? -2 : -1 : m >= i && b && (l[C] += b, l[C + 1] += b);
      }
      p += b;
    }), h = t.maps[d].map(h, -1);
  }
  let u = !1;
  for (let d = 0; d < l.length; d += 3)
    if (l[d + 1] < 0) {
      if (l[d + 1] == -2) {
        u = !0, l[d + 1] = -1;
        continue;
      }
      let h = t.map(n[d] + o), p = h - i;
      if (p < 0 || p >= r.content.size) {
        u = !0;
        continue;
      }
      let g = t.map(n[d + 1] + o, -1), v = g - i, { index: m, offset: w } = r.content.findIndex(p), b = r.maybeChild(m);
      if (b && w == p && w + b.nodeSize == v) {
        let C = l[d + 2].mapInner(t, b, h + 1, n[d] + o + 1, a);
        C != dn ? (l[d] = p, l[d + 1] = v, l[d + 2] = C) : (l[d + 1] = -2, u = !0);
      } else
        u = !0;
    }
  if (u) {
    let d = W4(l, n, e, t, i, o, a), h = mc(d, r, 0, a);
    e = h.local;
    for (let p = 0; p < l.length; p += 3)
      l[p + 1] < 0 && (l.splice(p, 3), p -= 3);
    for (let p = 0, g = 0; p < h.children.length; p += 3) {
      let v = h.children[p];
      for (; g < l.length && l[g] < v; )
        g += 3;
      l.splice(g, 0, h.children[p], h.children[p + 1], h.children[p + 2]);
    }
  }
  return new Ut(e.sort(wo), l);
}
function bw(n, e) {
  if (!e || !n.length)
    return n;
  let t = [];
  for (let r = 0; r < n.length; r++) {
    let i = n[r];
    t.push(new fr(i.from + e, i.to + e, i.type));
  }
  return t;
}
function W4(n, e, t, r, i, o, a) {
  function l(u, d) {
    for (let h = 0; h < u.local.length; h++) {
      let p = u.local[h].map(r, i, d);
      p ? t.push(p) : a.onRemove && a.onRemove(u.local[h].spec);
    }
    for (let h = 0; h < u.children.length; h += 3)
      l(u.children[h + 2], u.children[h] + d + 1);
  }
  for (let u = 0; u < n.length; u += 3)
    n[u + 1] == -1 && l(n[u + 2], e[u] + o + 1);
  return t;
}
function xw(n, e, t) {
  if (e.isLeaf)
    return null;
  let r = t + e.nodeSize, i = null;
  for (let o = 0, a; o < n.length; o++)
    (a = n[o]) && a.from > t && a.to < r && ((i || (i = [])).push(a), n[o] = null);
  return i;
}
function Sw(n) {
  let e = [];
  for (let t = 0; t < n.length; t++)
    n[t] != null && e.push(n[t]);
  return e;
}
function mc(n, e, t, r) {
  let i = [], o = !1;
  e.forEach((l, u) => {
    let d = xw(n, l, u + t);
    if (d) {
      o = !0;
      let h = mc(d, l, t + u + 1, r);
      h != dn && i.push(u, u + l.nodeSize, h);
    }
  });
  let a = bw(o ? Sw(n) : n, -t).sort(wo);
  for (let l = 0; l < a.length; l++)
    a[l].type.valid(e, a[l]) || (r.onRemove && r.onRemove(a[l].spec), a.splice(l--, 1));
  return a.length || i.length ? new Ut(a, i) : dn;
}
function wo(n, e) {
  return n.from - e.from || n.to - e.to;
}
function xh(n) {
  let e = n;
  for (let t = 0; t < e.length - 1; t++) {
    let r = e[t];
    if (r.from != r.to)
      for (let i = t + 1; i < e.length; i++) {
        let o = e[i];
        if (o.from == r.from) {
          o.to != r.to && (e == n && (e = n.slice()), e[i] = o.copy(o.from, r.to), Em(e, i + 1, o.copy(r.to, o.to)));
          continue;
        } else {
          o.from < r.to && (e == n && (e = n.slice()), e[t] = r.copy(r.from, o.from), Em(e, i, r.copy(o.from, r.to)));
          break;
        }
      }
  }
  return e;
}
function Em(n, e, t) {
  for (; e < n.length && wo(t, n[e]) > 0; )
    e++;
  n.splice(e, 0, t);
}
function Nd(n) {
  let e = [];
  return n.someProp("decorations", (t) => {
    let r = t(n.state);
    r && r != dn && e.push(r);
  }), n.cursorWrapper && e.push(Ut.create(n.state.doc, [n.cursorWrapper.deco])), Di.from(e);
}
const H4 = {
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0,
  attributes: !0,
  attributeOldValue: !0,
  subtree: !0
}, $4 = Pn && _i <= 11;
class U4 {
  constructor() {
    this.anchorNode = null, this.anchorOffset = 0, this.focusNode = null, this.focusOffset = 0;
  }
  set(e) {
    this.anchorNode = e.anchorNode, this.anchorOffset = e.anchorOffset, this.focusNode = e.focusNode, this.focusOffset = e.focusOffset;
  }
  clear() {
    this.anchorNode = this.focusNode = null;
  }
  eq(e) {
    return e.anchorNode == this.anchorNode && e.anchorOffset == this.anchorOffset && e.focusNode == this.focusNode && e.focusOffset == this.focusOffset;
  }
}
class Z4 {
  constructor(e, t) {
    this.view = e, this.handleDOMChange = t, this.queue = [], this.flushingSoon = -1, this.observer = null, this.currentSelection = new U4(), this.onCharData = null, this.suppressingSelectionUpdates = !1, this.observer = window.MutationObserver && new window.MutationObserver((r) => {
      for (let i = 0; i < r.length; i++)
        this.queue.push(r[i]);
      Pn && _i <= 11 && r.some((i) => i.type == "childList" && i.removedNodes.length || i.type == "characterData" && i.oldValue.length > i.target.nodeValue.length) ? this.flushSoon() : this.flush();
    }), $4 && (this.onCharData = (r) => {
      this.queue.push({ target: r.target, type: "characterData", oldValue: r.prevValue }), this.flushSoon();
    }), this.onSelectionChange = this.onSelectionChange.bind(this);
  }
  flushSoon() {
    this.flushingSoon < 0 && (this.flushingSoon = window.setTimeout(() => {
      this.flushingSoon = -1, this.flush();
    }, 20));
  }
  forceFlush() {
    this.flushingSoon > -1 && (window.clearTimeout(this.flushingSoon), this.flushingSoon = -1, this.flush());
  }
  start() {
    this.observer && (this.observer.takeRecords(), this.observer.observe(this.view.dom, H4)), this.onCharData && this.view.dom.addEventListener("DOMCharacterDataModified", this.onCharData), this.connectSelection();
  }
  stop() {
    if (this.observer) {
      let e = this.observer.takeRecords();
      if (e.length) {
        for (let t = 0; t < e.length; t++)
          this.queue.push(e[t]);
        window.setTimeout(() => this.flush(), 20);
      }
      this.observer.disconnect();
    }
    this.onCharData && this.view.dom.removeEventListener("DOMCharacterDataModified", this.onCharData), this.disconnectSelection();
  }
  connectSelection() {
    this.view.dom.ownerDocument.addEventListener("selectionchange", this.onSelectionChange);
  }
  disconnectSelection() {
    this.view.dom.ownerDocument.removeEventListener("selectionchange", this.onSelectionChange);
  }
  suppressSelectionUpdates() {
    this.suppressingSelectionUpdates = !0, setTimeout(() => this.suppressingSelectionUpdates = !1, 50);
  }
  onSelectionChange() {
    if (mm(this.view)) {
      if (this.suppressingSelectionUpdates)
        return ai(this.view);
      if (Pn && _i <= 11 && !this.view.state.selection.empty) {
        let e = this.view.domSelectionRange();
        if (e.focusNode && So(e.focusNode, e.focusOffset, e.anchorNode, e.anchorOffset))
          return this.flushSoon();
      }
      this.flush();
    }
  }
  setCurSelection() {
    this.currentSelection.set(this.view.domSelectionRange());
  }
  ignoreSelectionChange(e) {
    if (!e.focusNode)
      return !0;
    let t = /* @__PURE__ */ new Set(), r;
    for (let o = e.focusNode; o; o = ha(o))
      t.add(o);
    for (let o = e.anchorNode; o; o = ha(o))
      if (t.has(o)) {
        r = o;
        break;
      }
    let i = r && this.view.docView.nearestDesc(r);
    if (i && i.ignoreMutation({
      type: "selection",
      target: r.nodeType == 3 ? r.parentNode : r
    }))
      return this.setCurSelection(), !0;
  }
  pendingRecords() {
    if (this.observer)
      for (let e of this.observer.takeRecords())
        this.queue.push(e);
    return this.queue;
  }
  flush() {
    let { view: e } = this;
    if (!e.docView || this.flushingSoon > -1)
      return;
    let t = this.pendingRecords();
    t.length && (this.queue = []);
    let r = e.domSelectionRange(), i = !this.suppressingSelectionUpdates && !this.currentSelection.eq(r) && mm(e) && !this.ignoreSelectionChange(r), o = -1, a = -1, l = !1, u = [];
    if (e.editable)
      for (let h = 0; h < t.length; h++) {
        let p = this.registerMutation(t[h], u);
        p && (o = o < 0 ? p.from : Math.min(p.from, o), a = a < 0 ? p.to : Math.max(p.to, a), p.typeOver && (l = !0));
      }
    if (Tr && u.length > 1) {
      let h = u.filter((p) => p.nodeName == "BR");
      if (h.length == 2) {
        let p = h[0], g = h[1];
        p.parentNode && p.parentNode.parentNode == g.parentNode ? g.remove() : p.remove();
      }
    }
    let d = null;
    o < 0 && i && e.input.lastFocus > Date.now() - 200 && Math.max(e.input.lastTouch, e.input.lastClick.time) < Date.now() - 300 && Yc(r) && (d = gh(e)) && d.eq(rt.near(e.state.doc.resolve(0), 1)) ? (e.input.lastFocus = 0, ai(e), this.currentSelection.set(r), e.scrollToSelection()) : (o > -1 || i) && (o > -1 && (e.docView.markDirty(o, a), j4(e)), this.handleDOMChange(o, a, l, u), e.docView && e.docView.dirty ? e.updateState(e.state) : this.currentSelection.eq(r) || ai(e), this.currentSelection.set(r));
  }
  registerMutation(e, t) {
    if (t.indexOf(e.target) > -1)
      return null;
    let r = this.view.docView.nearestDesc(e.target);
    if (e.type == "attributes" && (r == this.view.docView || e.attributeName == "contenteditable" || // Firefox sometimes fires spurious events for null/empty styles
    e.attributeName == "style" && !e.oldValue && !e.target.getAttribute("style")) || !r || r.ignoreMutation(e))
      return null;
    if (e.type == "childList") {
      for (let h = 0; h < e.addedNodes.length; h++)
        t.push(e.addedNodes[h]);
      if (r.contentDOM && r.contentDOM != r.dom && !r.contentDOM.contains(e.target))
        return { from: r.posBefore, to: r.posAfter };
      let i = e.previousSibling, o = e.nextSibling;
      if (Pn && _i <= 11 && e.addedNodes.length)
        for (let h = 0; h < e.addedNodes.length; h++) {
          let { previousSibling: p, nextSibling: g } = e.addedNodes[h];
          (!p || Array.prototype.indexOf.call(e.addedNodes, p) < 0) && (i = p), (!g || Array.prototype.indexOf.call(e.addedNodes, g) < 0) && (o = g);
        }
      let a = i && i.parentNode == e.target ? Cn(i) + 1 : 0, l = r.localPosFromDOM(e.target, a, -1), u = o && o.parentNode == e.target ? Cn(o) : e.target.childNodes.length, d = r.localPosFromDOM(e.target, u, 1);
      return { from: l, to: d };
    } else
      return e.type == "attributes" ? { from: r.posAtStart - r.border, to: r.posAtEnd + r.border } : {
        from: r.posAtStart,
        to: r.posAtEnd,
        // An event was generated for a text change that didn't change
        // any text. Mark the dom change to fall back to assuming the
        // selection was typed over with an identical value if it can't
        // find another change.
        typeOver: e.target.nodeValue == e.oldValue
      };
  }
}
let km = /* @__PURE__ */ new WeakMap(), Om = !1;
function j4(n) {
  if (!km.has(n) && (km.set(n, null), ["normal", "nowrap", "pre-line"].indexOf(getComputedStyle(n.dom).whiteSpace) !== -1)) {
    if (n.requiresGeckoHackNode = Tr, Om)
      return;
    console.warn("ProseMirror expects the CSS white-space property to be set, preferably to 'pre-wrap'. It is recommended to load style/prosemirror.css from the prosemirror-view package."), Om = !0;
  }
}
function Y4(n) {
  let e;
  function t(u) {
    u.preventDefault(), u.stopImmediatePropagation(), e = u.getTargetRanges()[0];
  }
  n.dom.addEventListener("beforeinput", t, !0), document.execCommand("indent"), n.dom.removeEventListener("beforeinput", t, !0);
  let r = e.startContainer, i = e.startOffset, o = e.endContainer, a = e.endOffset, l = n.domAtPos(n.state.selection.anchor);
  return So(l.node, l.offset, o, a) && ([r, i, o, a] = [o, a, r, i]), { anchorNode: r, anchorOffset: i, focusNode: o, focusOffset: a };
}
function q4(n, e, t) {
  let { node: r, fromOffset: i, toOffset: o, from: a, to: l } = n.docView.parseRange(e, t), u = n.domSelectionRange(), d, h = u.anchorNode;
  if (h && n.dom.contains(h.nodeType == 1 ? h : h.parentNode) && (d = [{ node: h, offset: u.anchorOffset }], Yc(u) || d.push({ node: u.focusNode, offset: u.focusOffset })), gn && n.input.lastKeyCode === 8)
    for (let b = o; b > i; b--) {
      let C = r.childNodes[b - 1], M = C.pmViewDesc;
      if (C.nodeName == "BR" && !M) {
        o = b;
        break;
      }
      if (!M || M.size)
        break;
    }
  let p = n.state.doc, g = n.someProp("domParser") || xo.fromSchema(n.state.schema), v = p.resolve(a), m = null, w = g.parse(r, {
    topNode: v.parent,
    topMatch: v.parent.contentMatchAt(v.index()),
    topOpen: !0,
    from: i,
    to: o,
    preserveWhitespace: v.parent.type.whitespace == "pre" ? "full" : !0,
    findPositions: d,
    ruleFromNode: G4,
    context: v
  });
  if (d && d[0].pos != null) {
    let b = d[0].pos, C = d[1] && d[1].pos;
    C == null && (C = b), m = { anchor: b + a, head: C + a };
  }
  return { doc: w, sel: m, from: a, to: l };
}
function G4(n) {
  let e = n.pmViewDesc;
  if (e)
    return e.parseRule();
  if (n.nodeName == "BR" && n.parentNode) {
    if (En && /^(ul|ol)$/i.test(n.parentNode.nodeName)) {
      let t = document.createElement("div");
      return t.appendChild(document.createElement("li")), { skip: t };
    } else if (n.parentNode.lastChild == n || En && /^(tr|table)$/i.test(n.parentNode.nodeName))
      return { ignore: !0 };
  } else if (n.nodeName == "IMG" && n.getAttribute("mark-placeholder"))
    return { ignore: !0 };
  return null;
}
const K4 = /^(a|abbr|acronym|b|bd[io]|big|br|button|cite|code|data(list)?|del|dfn|em|i|ins|kbd|label|map|mark|meter|output|q|ruby|s|samp|small|span|strong|su[bp]|time|u|tt|var)$/i;
function X4(n, e, t, r, i) {
  let o = n.input.compositionPendingChanges || (n.composing ? n.input.compositionID : 0);
  if (n.input.compositionPendingChanges = 0, e < 0) {
    let K = n.input.lastSelectionTime > Date.now() - 50 ? n.input.lastSelectionOrigin : null, $ = gh(n, K);
    if ($ && !n.state.selection.eq($)) {
      if (gn && kr && n.input.lastKeyCode === 13 && Date.now() - 100 < n.input.lastKeyCodeTime && n.someProp("handleKeyDown", (Y) => Y(n, fo(13, "Enter"))))
        return;
      let F = n.state.tr.setSelection($);
      K == "pointer" ? F.setMeta("pointer", !0) : K == "key" && F.scrollIntoView(), o && F.setMeta("composition", o), n.dispatch(F);
    }
    return;
  }
  let a = n.state.doc.resolve(e), l = a.sharedDepth(t);
  e = a.before(l + 1), t = n.state.doc.resolve(t).after(l + 1);
  let u = n.state.selection, d = q4(n, e, t), h = n.state.doc, p = h.slice(d.from, d.to), g, v;
  n.input.lastKeyCode === 8 && Date.now() - 100 < n.input.lastKeyCodeTime ? (g = n.state.selection.to, v = "end") : (g = n.state.selection.from, v = "start"), n.input.lastKeyCode = null;
  let m = eD(p.content, d.doc.content, d.from, g, v);
  if ((us && n.input.lastIOSEnter > Date.now() - 225 || kr) && i.some((K) => K.nodeType == 1 && !K4.test(K.nodeName)) && (!m || m.endA >= m.endB) && n.someProp("handleKeyDown", (K) => K(n, fo(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (!m)
    if (r && u instanceof it && !u.empty && u.$head.sameParent(u.$anchor) && !n.composing && !(d.sel && d.sel.anchor != d.sel.head))
      m = { start: u.from, endA: u.to, endB: u.to };
    else {
      if (d.sel) {
        let K = Tm(n, n.state.doc, d.sel);
        if (K && !K.eq(n.state.selection)) {
          let $ = n.state.tr.setSelection(K);
          o && $.setMeta("composition", o), n.dispatch($);
        }
      }
      return;
    }
  if (gn && n.cursorWrapper && d.sel && d.sel.anchor == n.cursorWrapper.deco.from && d.sel.head == d.sel.anchor) {
    let K = m.endB - m.start;
    d.sel = { anchor: d.sel.anchor + K, head: d.sel.anchor + K };
  }
  n.input.domChangeCount++, n.state.selection.from < n.state.selection.to && m.start == m.endB && n.state.selection instanceof it && (m.start > n.state.selection.from && m.start <= n.state.selection.from + 2 && n.state.selection.from >= d.from ? m.start = n.state.selection.from : m.endA < n.state.selection.to && m.endA >= n.state.selection.to - 2 && n.state.selection.to <= d.to && (m.endB += n.state.selection.to - m.endA, m.endA = n.state.selection.to)), Pn && _i <= 11 && m.endB == m.start + 1 && m.endA == m.start && m.start > d.from && d.doc.textBetween(m.start - d.from - 1, m.start - d.from + 1) == "  " && (m.start--, m.endA--, m.endB--);
  let w = d.doc.resolveNoCache(m.start - d.from), b = d.doc.resolveNoCache(m.endB - d.from), C = h.resolve(m.start), M = w.sameParent(b) && w.parent.inlineContent && C.end() >= m.endA, k;
  if ((us && n.input.lastIOSEnter > Date.now() - 225 && (!M || i.some((K) => K.nodeName == "DIV" || K.nodeName == "P")) || !M && w.pos < d.doc.content.size && !w.sameParent(b) && (k = rt.findFrom(d.doc.resolve(w.pos + 1), 1, !0)) && k.head == b.pos) && n.someProp("handleKeyDown", (K) => K(n, fo(13, "Enter")))) {
    n.input.lastIOSEnter = 0;
    return;
  }
  if (n.state.selection.anchor > m.start && Q4(h, m.start, m.endA, w, b) && n.someProp("handleKeyDown", (K) => K(n, fo(8, "Backspace")))) {
    kr && gn && n.domObserver.suppressSelectionUpdates();
    return;
  }
  gn && kr && m.endB == m.start && (n.input.lastAndroidDelete = Date.now()), kr && !M && w.start() != b.start() && b.parentOffset == 0 && w.depth == b.depth && d.sel && d.sel.anchor == d.sel.head && d.sel.head == m.endA && (m.endB -= 2, b = d.doc.resolveNoCache(m.endB - d.from), setTimeout(() => {
    n.someProp("handleKeyDown", function(K) {
      return K(n, fo(13, "Enter"));
    });
  }, 20));
  let D = m.start, T = m.endA, R, _, Z;
  if (M) {
    if (w.pos == b.pos)
      Pn && _i <= 11 && w.parentOffset == 0 && (n.domObserver.suppressSelectionUpdates(), setTimeout(() => ai(n), 20)), R = n.state.tr.delete(D, T), _ = h.resolve(m.start).marksAcross(h.resolve(m.endA));
    else if (
      // Adding or removing a mark
      m.endA == m.endB && (Z = J4(w.parent.content.cut(w.parentOffset, b.parentOffset), C.parent.content.cut(C.parentOffset, m.endA - C.start())))
    )
      R = n.state.tr, Z.type == "add" ? R.addMark(D, T, Z.mark) : R.removeMark(D, T, Z.mark);
    else if (w.parent.child(w.index()).isText && w.index() == b.index() - (b.textOffset ? 0 : 1)) {
      let K = w.parent.textBetween(w.parentOffset, b.parentOffset);
      if (n.someProp("handleTextInput", ($) => $(n, D, T, K)))
        return;
      R = n.state.tr.insertText(K, D, T);
    }
  }
  if (R || (R = n.state.tr.replace(D, T, d.doc.slice(m.start - d.from, m.endB - d.from))), d.sel) {
    let K = Tm(n, R.doc, d.sel);
    K && !(gn && kr && n.composing && K.empty && (m.start != m.endB || n.input.lastAndroidDelete < Date.now() - 100) && (K.head == D || K.head == R.mapping.map(T) - 1) || Pn && K.empty && K.head == D) && R.setSelection(K);
  }
  _ && R.ensureMarks(_), o && R.setMeta("composition", o), n.dispatch(R.scrollIntoView());
}
function Tm(n, e, t) {
  return Math.max(t.anchor, t.head) > e.content.size ? null : mh(n, e.resolve(t.anchor), e.resolve(t.head));
}
function J4(n, e) {
  let t = n.firstChild.marks, r = e.firstChild.marks, i = t, o = r, a, l, u;
  for (let h = 0; h < r.length; h++)
    i = r[h].removeFromSet(i);
  for (let h = 0; h < t.length; h++)
    o = t[h].removeFromSet(o);
  if (i.length == 1 && o.length == 0)
    l = i[0], a = "add", u = (h) => h.mark(l.addToSet(h.marks));
  else if (i.length == 0 && o.length == 1)
    l = o[0], a = "remove", u = (h) => h.mark(l.removeFromSet(h.marks));
  else
    return null;
  let d = [];
  for (let h = 0; h < e.childCount; h++)
    d.push(u(e.child(h)));
  if (ue.from(d).eq(n))
    return { mark: l, type: a };
}
function Q4(n, e, t, r, i) {
  if (!r.parent.isTextblock || // The content must have shrunk
  t - e <= i.pos - r.pos || // newEnd must point directly at or after the end of the block that newStart points into
  zd(r, !0, !1) < i.pos)
    return !1;
  let o = n.resolve(e);
  if (o.parentOffset < o.parent.content.size || !o.parent.isTextblock)
    return !1;
  let a = n.resolve(zd(o, !0, !0));
  return !a.parent.isTextblock || a.pos > t || zd(a, !0, !1) < t ? !1 : r.parent.content.cut(r.parentOffset).eq(a.parent.content);
}
function zd(n, e, t) {
  let r = n.depth, i = e ? n.end() : n.pos;
  for (; r > 0 && (e || n.indexAfter(r) == n.node(r).childCount); )
    r--, i++, e = !1;
  if (t) {
    let o = n.node(r).maybeChild(n.indexAfter(r));
    for (; o && !o.isLeaf; )
      o = o.firstChild, i++;
  }
  return i;
}
function eD(n, e, t, r, i) {
  let o = n.findDiffStart(e, t);
  if (o == null)
    return null;
  let { a, b: l } = n.findDiffEnd(e, t + n.size, t + e.size);
  if (i == "end") {
    let u = Math.max(0, o - Math.min(a, l));
    r -= a + u - o;
  }
  if (a < o && n.size < e.size) {
    let u = r <= o && r >= a ? o - r : 0;
    o -= u, l = o + (l - a), a = o;
  } else if (l < o) {
    let u = r <= o && r >= l ? o - r : 0;
    o -= u, a = o + (a - l), l = o;
  }
  return { start: o, endA: a, endB: l };
}
class tD {
  /**
  Create a view. `place` may be a DOM node that the editor should
  be appended to, a function that will place it into the document,
  or an object whose `mount` property holds the node to use as the
  document container. If it is `null`, the editor will not be
  added to the document.
  */
  constructor(e, t) {
    this._root = null, this.focused = !1, this.trackWrites = null, this.mounted = !1, this.markCursor = null, this.cursorWrapper = null, this.lastSelectedViewDesc = void 0, this.input = new x4(), this.prevDirectPlugins = [], this.pluginViews = [], this.requiresGeckoHackNode = !1, this.dragging = null, this._props = t, this.state = t.state, this.directPlugins = t.plugins || [], this.directPlugins.forEach(Am), this.dispatch = this.dispatch.bind(this), this.dom = e && e.mount || document.createElement("div"), e && (e.appendChild ? e.appendChild(this.dom) : typeof e == "function" ? e(this.dom) : e.mount && (this.mounted = !0)), this.editable = Dm(this), Rm(this), this.nodeViews = Im(this), this.docView = um(this.state.doc, Mm(this), Nd(this), this.dom, this), this.domObserver = new Z4(this, (r, i, o, a) => X4(this, r, i, o, a)), this.domObserver.start(), S4(this), this.updatePluginViews();
  }
  /**
  Holds `true` when a
  [composition](https://w3c.github.io/uievents/#events-compositionevents)
  is active.
  */
  get composing() {
    return this.input.composing;
  }
  /**
  The view's current [props](https://prosemirror.net/docs/ref/#view.EditorProps).
  */
  get props() {
    if (this._props.state != this.state) {
      let e = this._props;
      this._props = {};
      for (let t in e)
        this._props[t] = e[t];
      this._props.state = this.state;
    }
    return this._props;
  }
  /**
  Update the view's props. Will immediately cause an update to
  the DOM.
  */
  update(e) {
    e.handleDOMEvents != this._props.handleDOMEvents && Nf(this);
    let t = this._props;
    this._props = e, e.plugins && (e.plugins.forEach(Am), this.directPlugins = e.plugins), this.updateStateInner(e.state, t);
  }
  /**
  Update the view by updating existing props object with the object
  given as argument. Equivalent to `view.update(Object.assign({},
  view.props, props))`.
  */
  setProps(e) {
    let t = {};
    for (let r in this._props)
      t[r] = this._props[r];
    t.state = this.state;
    for (let r in e)
      t[r] = e[r];
    this.update(t);
  }
  /**
  Update the editor's `state` prop, without touching any of the
  other props.
  */
  updateState(e) {
    this.updateStateInner(e, this._props);
  }
  updateStateInner(e, t) {
    let r = this.state, i = !1, o = !1;
    e.storedMarks && this.composing && (yw(this), o = !0), this.state = e;
    let a = r.plugins != e.plugins || this._props.plugins != t.plugins;
    if (a || this._props.plugins != t.plugins || this._props.nodeViews != t.nodeViews) {
      let g = Im(this);
      rD(g, this.nodeViews) && (this.nodeViews = g, i = !0);
    }
    (a || t.handleDOMEvents != this._props.handleDOMEvents) && Nf(this), this.editable = Dm(this), Rm(this);
    let l = Nd(this), u = Mm(this), d = r.plugins != e.plugins && !r.doc.eq(e.doc) ? "reset" : e.scrollToSelection > r.scrollToSelection ? "to selection" : "preserve", h = i || !this.docView.matchesNode(e.doc, u, l);
    (h || !e.selection.eq(r.selection)) && (o = !0);
    let p = d == "preserve" && o && this.dom.style.overflowAnchor == null && NR(this);
    if (o) {
      this.domObserver.stop();
      let g = h && (Pn || gn) && !this.composing && !r.selection.empty && !e.selection.empty && nD(r.selection, e.selection);
      if (h) {
        let v = gn ? this.trackWrites = this.domSelectionRange().focusNode : null;
        (i || !this.docView.update(e.doc, u, l, this)) && (this.docView.updateOuterDeco([]), this.docView.destroy(), this.docView = um(e.doc, u, l, this.dom, this)), v && !this.trackWrites && (g = !0);
      }
      g || !(this.input.mouseDown && this.domObserver.currentSelection.eq(this.domSelectionRange()) && a4(this)) ? ai(this, g) : (ow(this, e.selection), this.domObserver.setCurSelection()), this.domObserver.start();
    }
    this.updatePluginViews(r), d == "reset" ? this.dom.scrollTop = 0 : d == "to selection" ? this.scrollToSelection() : p && zR(p);
  }
  /**
  @internal
  */
  scrollToSelection() {
    let e = this.domSelectionRange().focusNode;
    if (!this.someProp("handleScrollToSelection", (t) => t(this)))
      if (this.state.selection instanceof He) {
        let t = this.docView.domAfterPos(this.state.selection.from);
        t.nodeType == 1 && im(this, t.getBoundingClientRect(), e);
      } else
        im(this, this.coordsAtPos(this.state.selection.head, 1), e);
  }
  destroyPluginViews() {
    let e;
    for (; e = this.pluginViews.pop(); )
      e.destroy && e.destroy();
  }
  updatePluginViews(e) {
    if (!e || e.plugins != this.state.plugins || this.directPlugins != this.prevDirectPlugins) {
      this.prevDirectPlugins = this.directPlugins, this.destroyPluginViews();
      for (let t = 0; t < this.directPlugins.length; t++) {
        let r = this.directPlugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
      for (let t = 0; t < this.state.plugins.length; t++) {
        let r = this.state.plugins[t];
        r.spec.view && this.pluginViews.push(r.spec.view(this));
      }
    } else
      for (let t = 0; t < this.pluginViews.length; t++) {
        let r = this.pluginViews[t];
        r.update && r.update(this, e);
      }
  }
  someProp(e, t) {
    let r = this._props && this._props[e], i;
    if (r != null && (i = t ? t(r) : r))
      return i;
    for (let a = 0; a < this.directPlugins.length; a++) {
      let l = this.directPlugins[a].props[e];
      if (l != null && (i = t ? t(l) : l))
        return i;
    }
    let o = this.state.plugins;
    if (o)
      for (let a = 0; a < o.length; a++) {
        let l = o[a].props[e];
        if (l != null && (i = t ? t(l) : l))
          return i;
      }
  }
  /**
  Query whether the view has focus.
  */
  hasFocus() {
    if (Pn) {
      let e = this.root.activeElement;
      if (e == this.dom)
        return !0;
      if (!e || !this.dom.contains(e))
        return !1;
      for (; e && this.dom != e && this.dom.contains(e); ) {
        if (e.contentEditable == "false")
          return !1;
        e = e.parentElement;
      }
      return !0;
    }
    return this.root.activeElement == this.dom;
  }
  /**
  Focus the editor.
  */
  focus() {
    this.domObserver.stop(), this.editable && BR(this.dom), ai(this), this.domObserver.start();
  }
  /**
  Get the document root in which the editor exists. This will
  usually be the top-level `document`, but might be a [shadow
  DOM](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Shadow_DOM)
  root if the editor is inside one.
  */
  get root() {
    let e = this._root;
    if (e == null) {
      for (let t = this.dom.parentNode; t; t = t.parentNode)
        if (t.nodeType == 9 || t.nodeType == 11 && t.host)
          return t.getSelection || (Object.getPrototypeOf(t).getSelection = () => t.ownerDocument.getSelection()), this._root = t;
    }
    return e || document;
  }
  /**
  When an existing editor view is moved to a new document or
  shadow tree, call this to make it recompute its root.
  */
  updateRoot() {
    this._root = null;
  }
  /**
  Given a pair of viewport coordinates, return the document
  position that corresponds to them. May return null if the given
  coordinates aren't inside of the editor. When an object is
  returned, its `pos` property is the position nearest to the
  coordinates, and its `inside` property holds the position of the
  inner node that the position falls inside of, or -1 if it is at
  the top level, not in any node.
  */
  posAtCoords(e) {
    return $R(this, e);
  }
  /**
  Returns the viewport rectangle at a given document position.
  `left` and `right` will be the same number, as this returns a
  flat cursor-ish rectangle. If the position is between two things
  that aren't directly adjacent, `side` determines which element
  is used. When < 0, the element before the position is used,
  otherwise the element after.
  */
  coordsAtPos(e, t = 1) {
    return Xy(this, e, t);
  }
  /**
  Find the DOM position that corresponds to the given document
  position. When `side` is negative, find the position as close as
  possible to the content before the position. When positive,
  prefer positions close to the content after the position. When
  zero, prefer as shallow a position as possible.
  
  Note that you should **not** mutate the editor's internal DOM,
  only inspect it (and even that is usually not necessary).
  */
  domAtPos(e, t = 0) {
    return this.docView.domFromPos(e, t);
  }
  /**
  Find the DOM node that represents the document node after the
  given position. May return `null` when the position doesn't point
  in front of a node or if the node is inside an opaque node view.
  
  This is intended to be able to call things like
  `getBoundingClientRect` on that DOM node. Do **not** mutate the
  editor DOM directly, or add styling this way, since that will be
  immediately overriden by the editor as it redraws the node.
  */
  nodeDOM(e) {
    let t = this.docView.descAt(e);
    return t ? t.nodeDOM : null;
  }
  /**
  Find the document position that corresponds to a given DOM
  position. (Whenever possible, it is preferable to inspect the
  document structure directly, rather than poking around in the
  DOM, but sometimes—for example when interpreting an event
  target—you don't have a choice.)
  
  The `bias` parameter can be used to influence which side of a DOM
  node to use when the position is inside a leaf node.
  */
  posAtDOM(e, t, r = -1) {
    let i = this.docView.posFromDOM(e, t, r);
    if (i == null)
      throw new RangeError("DOM position not inside the editor");
    return i;
  }
  /**
  Find out whether the selection is at the end of a textblock when
  moving in a given direction. When, for example, given `"left"`,
  it will return true if moving left from the current cursor
  position would leave that position's parent textblock. Will apply
  to the view's current state by default, but it is possible to
  pass a different state.
  */
  endOfTextblock(e, t) {
    return qR(this, t || this.state, e);
  }
  /**
  Run the editor's paste logic with the given HTML string. The
  `event`, if given, will be passed to the
  [`handlePaste`](https://prosemirror.net/docs/ref/#view.EditorProps.handlePaste) hook.
  */
  pasteHTML(e, t) {
    return pa(this, "", e, !1, t || new ClipboardEvent("paste"));
  }
  /**
  Run the editor's paste logic with the given plain-text input.
  */
  pasteText(e, t) {
    return pa(this, e, null, !0, t || new ClipboardEvent("paste"));
  }
  /**
  Removes the editor from the DOM and destroys all [node
  views](https://prosemirror.net/docs/ref/#view.NodeView).
  */
  destroy() {
    this.docView && (C4(this), this.destroyPluginViews(), this.mounted ? (this.docView.update(this.state.doc, [], Nd(this), this), this.dom.textContent = "") : this.dom.parentNode && this.dom.parentNode.removeChild(this.dom), this.docView.destroy(), this.docView = null);
  }
  /**
  This is true when the view has been
  [destroyed](https://prosemirror.net/docs/ref/#view.EditorView.destroy) (and thus should not be
  used anymore).
  */
  get isDestroyed() {
    return this.docView == null;
  }
  /**
  Used for testing.
  */
  dispatchEvent(e) {
    return k4(this, e);
  }
  /**
  Dispatch a transaction. Will call
  [`dispatchTransaction`](https://prosemirror.net/docs/ref/#view.DirectEditorProps.dispatchTransaction)
  when given, and otherwise defaults to applying the transaction to
  the current state and calling
  [`updateState`](https://prosemirror.net/docs/ref/#view.EditorView.updateState) with the result.
  This method is bound to the view instance, so that it can be
  easily passed around.
  */
  dispatch(e) {
    let t = this._props.dispatchTransaction;
    t ? t.call(this, e) : this.updateState(this.state.apply(e));
  }
  /**
  @internal
  */
  domSelectionRange() {
    return En && this.root.nodeType === 11 && RR(this.dom.ownerDocument) == this.dom ? Y4(this) : this.domSelection();
  }
  /**
  @internal
  */
  domSelection() {
    return this.root.getSelection();
  }
}
function Mm(n) {
  let e = /* @__PURE__ */ Object.create(null);
  return e.class = "ProseMirror", e.contenteditable = String(n.editable), n.someProp("attributes", (t) => {
    if (typeof t == "function" && (t = t(n.state)), t)
      for (let r in t)
        r == "class" ? e.class += " " + t[r] : r == "style" ? e.style = (e.style ? e.style + ";" : "") + t[r] : !e[r] && r != "contenteditable" && r != "nodeName" && (e[r] = String(t[r]));
  }), e.translate || (e.translate = "no"), [fr.node(0, n.state.doc.content.size, e)];
}
function Rm(n) {
  if (n.markCursor) {
    let e = document.createElement("img");
    e.className = "ProseMirror-separator", e.setAttribute("mark-placeholder", "true"), e.setAttribute("alt", ""), n.cursorWrapper = { dom: e, deco: fr.widget(n.state.selection.head, e, { raw: !0, marks: n.markCursor }) };
  } else
    n.cursorWrapper = null;
}
function Dm(n) {
  return !n.someProp("editable", (e) => e(n.state) === !1);
}
function nD(n, e) {
  let t = Math.min(n.$anchor.sharedDepth(n.head), e.$anchor.sharedDepth(e.head));
  return n.$anchor.start(t) != e.$anchor.start(t);
}
function Im(n) {
  let e = /* @__PURE__ */ Object.create(null);
  function t(r) {
    for (let i in r)
      Object.prototype.hasOwnProperty.call(e, i) || (e[i] = r[i]);
  }
  return n.someProp("nodeViews", t), n.someProp("markViews", t), e;
}
function rD(n, e) {
  let t = 0, r = 0;
  for (let i in n) {
    if (n[i] != e[i])
      return !0;
    t++;
  }
  for (let i in e)
    r++;
  return t != r;
}
function Am(n) {
  if (n.spec.state || n.spec.filterTransaction || n.spec.appendTransaction)
    throw new RangeError("Plugins passed directly to the view must not have a state component");
}
class Lt extends rt {
  /**
  Create a gap cursor.
  */
  constructor(e) {
    super(e, e);
  }
  map(e, t) {
    let r = e.resolve(t.map(this.head));
    return Lt.valid(r) ? new Lt(r) : rt.near(r);
  }
  content() {
    return ke.empty;
  }
  eq(e) {
    return e instanceof Lt && e.head == this.head;
  }
  toJSON() {
    return { type: "gapcursor", pos: this.head };
  }
  /**
  @internal
  */
  static fromJSON(e, t) {
    if (typeof t.pos != "number")
      throw new RangeError("Invalid input for GapCursor.fromJSON");
    return new Lt(e.resolve(t.pos));
  }
  /**
  @internal
  */
  getBookmark() {
    return new Sh(this.anchor);
  }
  /**
  @internal
  */
  static valid(e) {
    let t = e.parent;
    if (t.isTextblock || !iD(e) || !oD(e))
      return !1;
    let r = t.type.spec.allowGapCursor;
    if (r != null)
      return r;
    let i = t.contentMatchAt(e.index()).defaultType;
    return i && i.isTextblock;
  }
  /**
  @internal
  */
  static findGapCursorFrom(e, t, r = !1) {
    e:
      for (; ; ) {
        if (!r && Lt.valid(e))
          return e;
        let i = e.pos, o = null;
        for (let a = e.depth; ; a--) {
          let l = e.node(a);
          if (t > 0 ? e.indexAfter(a) < l.childCount : e.index(a) > 0) {
            o = l.child(t > 0 ? e.indexAfter(a) : e.index(a) - 1);
            break;
          } else if (a == 0)
            return null;
          i += t;
          let u = e.doc.resolve(i);
          if (Lt.valid(u))
            return u;
        }
        for (; ; ) {
          let a = t > 0 ? o.firstChild : o.lastChild;
          if (!a) {
            if (o.isAtom && !o.isText && !He.isSelectable(o)) {
              e = e.doc.resolve(i + o.nodeSize * t), r = !1;
              continue e;
            }
            break;
          }
          o = a, i += t;
          let l = e.doc.resolve(i);
          if (Lt.valid(l))
            return l;
        }
        return null;
      }
  }
}
Lt.prototype.visible = !1;
Lt.findFrom = Lt.findGapCursorFrom;
rt.jsonID("gapcursor", Lt);
class Sh {
  constructor(e) {
    this.pos = e;
  }
  map(e) {
    return new Sh(e.map(this.pos));
  }
  resolve(e) {
    let t = e.resolve(this.pos);
    return Lt.valid(t) ? new Lt(t) : rt.near(t);
  }
}
function iD(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.index(e), r = n.node(e);
    if (t == 0) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t - 1); ; i = i.lastChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function oD(n) {
  for (let e = n.depth; e >= 0; e--) {
    let t = n.indexAfter(e), r = n.node(e);
    if (t == r.childCount) {
      if (r.type.spec.isolating)
        return !0;
      continue;
    }
    for (let i = r.child(t); ; i = i.firstChild) {
      if (i.childCount == 0 && !i.inlineContent || i.isAtom || i.type.spec.isolating)
        return !0;
      if (i.inlineContent)
        return !1;
    }
  }
  return !0;
}
function sD() {
  return new Ma({
    props: {
      decorations: uD,
      createSelectionBetween(n, e, t) {
        return e.pos == t.pos && Lt.valid(t) ? new Lt(t) : null;
      },
      handleClick: lD,
      handleKeyDown: aD,
      handleDOMEvents: { beforeinput: cD }
    }
  });
}
const aD = OR({
  ArrowLeft: Ll("horiz", -1),
  ArrowRight: Ll("horiz", 1),
  ArrowUp: Ll("vert", -1),
  ArrowDown: Ll("vert", 1)
});
function Ll(n, e) {
  const t = n == "vert" ? e > 0 ? "down" : "up" : e > 0 ? "right" : "left";
  return function(r, i, o) {
    let a = r.selection, l = e > 0 ? a.$to : a.$from, u = a.empty;
    if (a instanceof it) {
      if (!o.endOfTextblock(t) || l.depth == 0)
        return !1;
      u = !1, l = r.doc.resolve(e > 0 ? l.after() : l.before());
    }
    let d = Lt.findGapCursorFrom(l, e, u);
    return d ? (i && i(r.tr.setSelection(new Lt(d))), !0) : !1;
  };
}
function lD(n, e, t) {
  if (!n || !n.editable)
    return !1;
  let r = n.state.doc.resolve(e);
  if (!Lt.valid(r))
    return !1;
  let i = n.posAtCoords({ left: t.clientX, top: t.clientY });
  return i && i.inside > -1 && He.isSelectable(n.state.doc.nodeAt(i.inside)) ? !1 : (n.dispatch(n.state.tr.setSelection(new Lt(r))), !0);
}
function cD(n, e) {
  if (e.inputType != "insertCompositionText" || !(n.state.selection instanceof Lt))
    return !1;
  let { $from: t } = n.state.selection, r = t.parent.contentMatchAt(t.index()).findWrapping(n.state.schema.nodes.text);
  if (!r)
    return !1;
  let i = ue.empty;
  for (let a = r.length - 1; a >= 0; a--)
    i = ue.from(r[a].createAndFill(null, i));
  let o = n.state.tr.replace(t.pos, t.pos, new ke(i, 0, 0));
  return o.setSelection(it.near(o.doc.resolve(t.pos + 1))), n.dispatch(o), !1;
}
function uD(n) {
  if (!(n.selection instanceof Lt))
    return null;
  let e = document.createElement("div");
  return e.className = "ProseMirror-gapcursor", Ut.create(n.doc, [fr.widget(n.selection.head, e, { key: "gapcursor" })]);
}
var vc = 200, Kt = function() {
};
Kt.prototype.append = function(e) {
  return e.length ? (e = Kt.from(e), !this.length && e || e.length < vc && this.leafAppend(e) || this.length < vc && e.leafPrepend(this) || this.appendInner(e)) : this;
};
Kt.prototype.prepend = function(e) {
  return e.length ? Kt.from(e).append(this) : this;
};
Kt.prototype.appendInner = function(e) {
  return new dD(this, e);
};
Kt.prototype.slice = function(e, t) {
  return e === void 0 && (e = 0), t === void 0 && (t = this.length), e >= t ? Kt.empty : this.sliceInner(Math.max(0, e), Math.min(this.length, t));
};
Kt.prototype.get = function(e) {
  if (!(e < 0 || e >= this.length))
    return this.getInner(e);
};
Kt.prototype.forEach = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length), t <= r ? this.forEachInner(e, t, r, 0) : this.forEachInvertedInner(e, t, r, 0);
};
Kt.prototype.map = function(e, t, r) {
  t === void 0 && (t = 0), r === void 0 && (r = this.length);
  var i = [];
  return this.forEach(function(o, a) {
    return i.push(e(o, a));
  }, t, r), i;
};
Kt.from = function(e) {
  return e instanceof Kt ? e : e && e.length ? new Cw(e) : Kt.empty;
};
var Cw = /* @__PURE__ */ function(n) {
  function e(r) {
    n.call(this), this.values = r;
  }
  n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e;
  var t = { length: { configurable: !0 }, depth: { configurable: !0 } };
  return e.prototype.flatten = function() {
    return this.values;
  }, e.prototype.sliceInner = function(i, o) {
    return i == 0 && o == this.length ? this : new e(this.values.slice(i, o));
  }, e.prototype.getInner = function(i) {
    return this.values[i];
  }, e.prototype.forEachInner = function(i, o, a, l) {
    for (var u = o; u < a; u++)
      if (i(this.values[u], l + u) === !1)
        return !1;
  }, e.prototype.forEachInvertedInner = function(i, o, a, l) {
    for (var u = o - 1; u >= a; u--)
      if (i(this.values[u], l + u) === !1)
        return !1;
  }, e.prototype.leafAppend = function(i) {
    if (this.length + i.length <= vc)
      return new e(this.values.concat(i.flatten()));
  }, e.prototype.leafPrepend = function(i) {
    if (this.length + i.length <= vc)
      return new e(i.flatten().concat(this.values));
  }, t.length.get = function() {
    return this.values.length;
  }, t.depth.get = function() {
    return 0;
  }, Object.defineProperties(e.prototype, t), e;
}(Kt);
Kt.empty = new Cw([]);
var dD = /* @__PURE__ */ function(n) {
  function e(t, r) {
    n.call(this), this.left = t, this.right = r, this.length = t.length + r.length, this.depth = Math.max(t.depth, r.depth) + 1;
  }
  return n && (e.__proto__ = n), e.prototype = Object.create(n && n.prototype), e.prototype.constructor = e, e.prototype.flatten = function() {
    return this.left.flatten().concat(this.right.flatten());
  }, e.prototype.getInner = function(r) {
    return r < this.left.length ? this.left.get(r) : this.right.get(r - this.left.length);
  }, e.prototype.forEachInner = function(r, i, o, a) {
    var l = this.left.length;
    if (i < l && this.left.forEachInner(r, i, Math.min(o, l), a) === !1 || o > l && this.right.forEachInner(r, Math.max(i - l, 0), Math.min(this.length, o) - l, a + l) === !1)
      return !1;
  }, e.prototype.forEachInvertedInner = function(r, i, o, a) {
    var l = this.left.length;
    if (i > l && this.right.forEachInvertedInner(r, i - l, Math.max(o, l) - l, a + l) === !1 || o < l && this.left.forEachInvertedInner(r, Math.min(i, l), o, a) === !1)
      return !1;
  }, e.prototype.sliceInner = function(r, i) {
    if (r == 0 && i == this.length)
      return this;
    var o = this.left.length;
    return i <= o ? this.left.slice(r, i) : r >= o ? this.right.slice(r - o, i - o) : this.left.slice(r, o).append(this.right.slice(0, i - o));
  }, e.prototype.leafAppend = function(r) {
    var i = this.right.leafAppend(r);
    if (i)
      return new e(this.left, i);
  }, e.prototype.leafPrepend = function(r) {
    var i = this.left.leafPrepend(r);
    if (i)
      return new e(i, this.right);
  }, e.prototype.appendInner = function(r) {
    return this.left.depth >= Math.max(this.right.depth, r.depth) + 1 ? new e(this.left, new e(this.right, r)) : new e(this, r);
  }, e;
}(Kt);
const fD = 500;
class Or {
  constructor(e, t) {
    this.items = e, this.eventCount = t;
  }
  // Pop the latest event off the branch's history and apply it
  // to a document transform.
  popEvent(e, t) {
    if (this.eventCount == 0)
      return null;
    let r = this.items.length;
    for (; ; r--)
      if (this.items.get(r - 1).selection) {
        --r;
        break;
      }
    let i, o;
    t && (i = this.remapping(r, this.items.length), o = i.maps.length);
    let a = e.tr, l, u, d = [], h = [];
    return this.items.forEach((p, g) => {
      if (!p.step) {
        i || (i = this.remapping(r, g + 1), o = i.maps.length), o--, h.push(p);
        return;
      }
      if (i) {
        h.push(new Lr(p.map));
        let v = p.step.map(i.slice(o)), m;
        v && a.maybeStep(v).doc && (m = a.mapping.maps[a.mapping.maps.length - 1], d.push(new Lr(m, void 0, void 0, d.length + h.length))), o--, m && i.appendMap(m, o);
      } else
        a.maybeStep(p.step);
      if (p.selection)
        return l = i ? p.selection.map(i.slice(o)) : p.selection, u = new Or(this.items.slice(0, r).append(h.reverse().concat(d)), this.eventCount - 1), !1;
    }, this.items.length, 0), { remaining: u, transform: a, selection: l };
  }
  // Create a new branch with the given transform added.
  addTransform(e, t, r, i) {
    let o = [], a = this.eventCount, l = this.items, u = !i && l.length ? l.get(l.length - 1) : null;
    for (let h = 0; h < e.steps.length; h++) {
      let p = e.steps[h].invert(e.docs[h]), g = new Lr(e.mapping.maps[h], p, t), v;
      (v = u && u.merge(g)) && (g = v, h ? o.pop() : l = l.slice(0, l.length - 1)), o.push(g), t && (a++, t = void 0), i || (u = g);
    }
    let d = a - r.depth;
    return d > pD && (l = hD(l, d), a -= d), new Or(l.append(o), a);
  }
  remapping(e, t) {
    let r = new ts();
    return this.items.forEach((i, o) => {
      let a = i.mirrorOffset != null && o - i.mirrorOffset >= e ? r.maps.length - i.mirrorOffset : void 0;
      r.appendMap(i.map, a);
    }, e, t), r;
  }
  addMaps(e) {
    return this.eventCount == 0 ? this : new Or(this.items.append(e.map((t) => new Lr(t))), this.eventCount);
  }
  // When the collab module receives remote changes, the history has
  // to know about those, so that it can adjust the steps that were
  // rebased on top of the remote changes, and include the position
  // maps for the remote changes in its array of items.
  rebased(e, t) {
    if (!this.eventCount)
      return this;
    let r = [], i = Math.max(0, this.items.length - t), o = e.mapping, a = e.steps.length, l = this.eventCount;
    this.items.forEach((g) => {
      g.selection && l--;
    }, i);
    let u = t;
    this.items.forEach((g) => {
      let v = o.getMirror(--u);
      if (v == null)
        return;
      a = Math.min(a, v);
      let m = o.maps[v];
      if (g.step) {
        let w = e.steps[v].invert(e.docs[v]), b = g.selection && g.selection.map(o.slice(u + 1, v));
        b && l++, r.push(new Lr(m, w, b));
      } else
        r.push(new Lr(m));
    }, i);
    let d = [];
    for (let g = t; g < a; g++)
      d.push(new Lr(o.maps[g]));
    let h = this.items.slice(0, i).append(d).append(r), p = new Or(h, l);
    return p.emptyItemCount() > fD && (p = p.compress(this.items.length - r.length)), p;
  }
  emptyItemCount() {
    let e = 0;
    return this.items.forEach((t) => {
      t.step || e++;
    }), e;
  }
  // Compressing a branch means rewriting it to push the air (map-only
  // items) out. During collaboration, these naturally accumulate
  // because each remote change adds one. The `upto` argument is used
  // to ensure that only the items below a given level are compressed,
  // because `rebased` relies on a clean, untouched set of items in
  // order to associate old items with rebased steps.
  compress(e = this.items.length) {
    let t = this.remapping(0, e), r = t.maps.length, i = [], o = 0;
    return this.items.forEach((a, l) => {
      if (l >= e)
        i.push(a), a.selection && o++;
      else if (a.step) {
        let u = a.step.map(t.slice(r)), d = u && u.getMap();
        if (r--, d && t.appendMap(d, r), u) {
          let h = a.selection && a.selection.map(t.slice(r));
          h && o++;
          let p = new Lr(d.invert(), u, h), g, v = i.length - 1;
          (g = i.length && i[v].merge(p)) ? i[v] = g : i.push(p);
        }
      } else
        a.map && r--;
    }, this.items.length, 0), new Or(Kt.from(i.reverse()), o);
  }
}
Or.empty = new Or(Kt.empty, 0);
function hD(n, e) {
  let t;
  return n.forEach((r, i) => {
    if (r.selection && e-- == 0)
      return t = i, !1;
  }), n.slice(t);
}
class Lr {
  constructor(e, t, r, i) {
    this.map = e, this.step = t, this.selection = r, this.mirrorOffset = i;
  }
  merge(e) {
    if (this.step && e.step && !e.selection) {
      let t = e.step.merge(this.step);
      if (t)
        return new Lr(t.getMap().invert(), t, this.selection);
    }
  }
}
class Mi {
  constructor(e, t, r, i, o) {
    this.done = e, this.undone = t, this.prevRanges = r, this.prevTime = i, this.prevComposition = o;
  }
}
const pD = 20;
function gD(n, e, t, r) {
  let i = t.getMeta(Bi), o;
  if (i)
    return i.historyState;
  t.getMeta(vD) && (n = new Mi(n.done, n.undone, null, 0, -1));
  let a = t.getMeta("appendedTransaction");
  if (t.steps.length == 0)
    return n;
  if (a && a.getMeta(Bi))
    return a.getMeta(Bi).redo ? new Mi(n.done.addTransform(t, void 0, r, ql(e)), n.undone, Lm(t.mapping.maps[t.steps.length - 1]), n.prevTime, n.prevComposition) : new Mi(n.done, n.undone.addTransform(t, void 0, r, ql(e)), null, n.prevTime, n.prevComposition);
  if (t.getMeta("addToHistory") !== !1 && !(a && a.getMeta("addToHistory") === !1)) {
    let l = t.getMeta("composition"), u = n.prevTime == 0 || !a && n.prevComposition != l && (n.prevTime < (t.time || 0) - r.newGroupDelay || !mD(t, n.prevRanges)), d = a ? Bd(n.prevRanges, t.mapping) : Lm(t.mapping.maps[t.steps.length - 1]);
    return new Mi(n.done.addTransform(t, u ? e.selection.getBookmark() : void 0, r, ql(e)), Or.empty, d, t.time, l ?? n.prevComposition);
  } else
    return (o = t.getMeta("rebased")) ? new Mi(n.done.rebased(t, o), n.undone.rebased(t, o), Bd(n.prevRanges, t.mapping), n.prevTime, n.prevComposition) : new Mi(n.done.addMaps(t.mapping.maps), n.undone.addMaps(t.mapping.maps), Bd(n.prevRanges, t.mapping), n.prevTime, n.prevComposition);
}
function mD(n, e) {
  if (!e)
    return !1;
  if (!n.docChanged)
    return !0;
  let t = !1;
  return n.mapping.maps[0].forEach((r, i) => {
    for (let o = 0; o < e.length; o += 2)
      r <= e[o + 1] && i >= e[o] && (t = !0);
  }), t;
}
function Lm(n) {
  let e = [];
  return n.forEach((t, r, i, o) => e.push(i, o)), e;
}
function Bd(n, e) {
  if (!n)
    return null;
  let t = [];
  for (let r = 0; r < n.length; r += 2) {
    let i = e.map(n[r], 1), o = e.map(n[r + 1], -1);
    i <= o && t.push(i, o);
  }
  return t;
}
function Ew(n, e, t, r) {
  let i = ql(e), o = Bi.get(e).spec.config, a = (r ? n.undone : n.done).popEvent(e, i);
  if (!a)
    return;
  let l = a.selection.resolve(a.transform.doc), u = (r ? n.done : n.undone).addTransform(a.transform, e.selection.getBookmark(), o, i), d = new Mi(r ? u : a.remaining, r ? a.remaining : u, null, 0, -1);
  t(a.transform.setSelection(l).setMeta(Bi, { redo: r, historyState: d }).scrollIntoView());
}
let Fd = !1, Pm = null;
function ql(n) {
  let e = n.plugins;
  if (Pm != e) {
    Fd = !1, Pm = e;
    for (let t = 0; t < e.length; t++)
      if (e[t].spec.historyPreserveItems) {
        Fd = !0;
        break;
      }
  }
  return Fd;
}
const Bi = new By("history"), vD = new By("closeHistory");
function yD(n = {}) {
  return n = {
    depth: n.depth || 100,
    newGroupDelay: n.newGroupDelay || 500
  }, new Ma({
    key: Bi,
    state: {
      init() {
        return new Mi(Or.empty, Or.empty, null, 0, -1);
      },
      apply(e, t, r) {
        return gD(t, r, e, n);
      }
    },
    config: n,
    props: {
      handleDOMEvents: {
        beforeinput(e, t) {
          let r = t.inputType, i = r == "historyUndo" ? kw : r == "historyRedo" ? Ow : null;
          return i ? (t.preventDefault(), i(e.state, e.dispatch)) : !1;
        }
      }
    }
  });
}
const kw = (n, e) => {
  let t = Bi.getState(n);
  return !t || t.done.eventCount == 0 ? !1 : (e && Ew(t, n, e, !1), !0);
}, Ow = (n, e) => {
  let t = Bi.getState(n);
  return !t || t.undone.eventCount == 0 ? !1 : (e && Ew(t, n, e, !0), !0);
};
class qi {
  // :: (RegExp, union<string, (state: EditorState, match: [string], start: number, end: number) → ?Transaction>)
  /**
  Create an input rule. The rule applies when the user typed
  something and the text directly in front of the cursor matches
  `match`, which should end with `$`.
  
  The `handler` can be a string, in which case the matched text, or
  the first matched group in the regexp, is replaced by that
  string.
  
  Or a it can be a function, which will be called with the match
  array produced by
  [`RegExp.exec`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/exec),
  as well as the start and end of the matched range, and which can
  return a [transaction](https://prosemirror.net/docs/ref/#state.Transaction) that describes the
  rule's effect, or null to indicate the input was not handled.
  */
  constructor(e, t) {
    this.match = e, this.match = e, this.handler = typeof t == "string" ? wD(t) : t;
  }
}
function wD(n) {
  return function(e, t, r, i) {
    let o = n;
    if (t[1]) {
      let a = t[0].lastIndexOf(t[1]);
      o += t[0].slice(a + t[1].length), r += a;
      let l = r - i;
      l > 0 && (o = t[0].slice(a - l, a) + o, r = i);
    }
    return e.tr.insertText(o, r, i);
  };
}
const bD = 500;
function xD({ rules: n }) {
  let e = new Ma({
    state: {
      init() {
        return null;
      },
      apply(t, r) {
        let i = t.getMeta(this);
        return i || (t.selectionSet || t.docChanged ? null : r);
      }
    },
    props: {
      handleTextInput(t, r, i, o) {
        return _m(t, r, i, o, n, e);
      },
      handleDOMEvents: {
        compositionend: (t) => {
          setTimeout(() => {
            let { $cursor: r } = t.state.selection;
            r && _m(t, r.pos, r.pos, "", n, e);
          });
        }
      }
    },
    isInputRules: !0
  });
  return e;
}
function _m(n, e, t, r, i, o) {
  if (n.composing)
    return !1;
  let a = n.state, l = a.doc.resolve(e);
  if (l.parent.type.spec.code)
    return !1;
  let u = l.parent.textBetween(Math.max(0, l.parentOffset - bD), l.parentOffset, null, "￼") + r;
  for (let d = 0; d < i.length; d++) {
    let h = i[d].match.exec(u), p = h && i[d].handler(a, h, e - (h[0].length - r.length), t);
    if (p)
      return n.dispatch(p.setMeta(o, { transform: p, from: e, to: t, text: r })), !0;
  }
  return !1;
}
const SD = (n, e) => {
  let t = n.plugins;
  for (let r = 0; r < t.length; r++) {
    let i = t[r], o;
    if (i.spec.isInputRules && (o = i.getState(n))) {
      if (e) {
        let a = n.tr, l = o.transform;
        for (let u = l.steps.length - 1; u >= 0; u--)
          a.step(l.steps[u].invert(l.docs[u]));
        if (o.text) {
          let u = a.doc.resolve(o.from).marks();
          a.replaceWith(o.from, o.to, n.schema.text(o.text, u));
        } else
          a.delete(o.from, o.to);
        e(a);
      }
      return !0;
    }
  }
  return !1;
}, CD = new qi(/--$/, "—"), ED = new qi(/\.\.\.$/, "…"), kD = new qi(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(")$/, "“"), OD = new qi(/"$/, "”"), TD = new qi(/(?:^|[\s\{\[\(\<'"\u2018\u201C])(')$/, "‘"), MD = new qi(/'$/, "’"), RD = [kD, OD, TD, MD];
function Ch(n, e, t = null, r) {
  return new qi(n, (i, o, a, l) => {
    let u = t instanceof Function ? t(o) : t, d = i.tr.delete(a, l), h = d.doc.resolve(a), p = h.blockRange(), g = p && IM(p, e, u);
    if (!g)
      return null;
    d.wrap(p, g);
    let v = d.doc.resolve(a - 1).nodeBefore;
    return v && v.type == e && Ta(d.doc, a - 1) && (!r || r(o, v)) && d.join(a - 1), d;
  });
}
function Tw(n, e, t = null) {
  return new qi(n, (r, i, o, a) => {
    let l = r.doc.resolve(o), u = t instanceof Function ? t(i) : t;
    return l.node(-1).canReplaceWith(l.index(-1), l.indexAfter(-1), e) ? r.tr.delete(o, a).setBlockType(o, o, e, u) : null;
  });
}
function Kc(n, e) {
  if (typeof n == "string") {
    if (!e.marks[n])
      throw Error(`There is no mark type named '${n}'!`);
    return e.marks[n];
  }
  return n;
}
function DD(n, e) {
  const t = Kc(e, n.schema), { from: r, to: i, empty: o } = n.selection, a = [];
  o ? (n.storedMarks && a.push(...n.storedMarks), a.push(...n.selection.$head.marks())) : n.doc.nodesBetween(r, i, (u) => {
    a.push(...u.marks);
  });
  const l = a.find((u) => u.type.name === t.name);
  return l ? { ...l.attrs } : {};
}
const Ia = (n, e = {}) => (t, r) => {
  const i = t.tr.setSelection(t.selection), { selection: o } = i, { empty: a, ranges: l } = o, u = Kc(n, t.schema);
  if (a) {
    const d = DD(t, u);
    i.addStoredMark(
      u.create({
        ...d,
        ...e
      })
    );
  } else
    l.forEach((d) => {
      const h = d.$from.pos, p = d.$to.pos;
      t.doc.nodesBetween(h, p, (g, v) => {
        const m = Math.max(v, h), w = Math.min(v + g.nodeSize, p);
        g.marks.find((C) => C.type === u) ? g.marks.forEach((C) => {
          u === C.type && i.addMark(
            m,
            w,
            u.create({
              ...C.attrs,
              ...e
            })
          );
        }) : i.addMark(m, w, u.create(e));
      });
    });
  return r ? (r(i), !0) : !1;
};
function yc(n, e) {
  const t = Object.keys(e);
  return t.length ? t.every((r) => e[r] === n[r]) : !0;
}
function zf(n, e, t = {}) {
  const { empty: r, ranges: i } = n.selection, o = e ? Kc(e, n.schema) : null;
  if (r)
    return !!(n.storedMarks || n.selection.$from.marks()).filter((p) => o ? o.name === p.type.name : !0).find((p) => yc(p.attrs, t));
  let a = 0;
  const l = [];
  if (i.forEach(({ $from: p, $to: g }) => {
    const v = p.pos, m = g.pos;
    n.doc.nodesBetween(v, m, (w, b) => {
      if (!w.isText && !w.marks.length)
        return;
      const C = Math.max(v, b), M = Math.min(m, b + w.nodeSize), k = M - C;
      a += k, l.push(
        ...w.marks.map((D) => ({
          mark: D,
          from: C,
          to: M
        }))
      );
    });
  }), a === 0)
    return !1;
  const u = l.filter((p) => o ? o.name === p.mark.type.name : !0).filter((p) => yc(p.mark.attrs, t)).reduce((p, g) => p + g.to - g.from, 0), d = l.filter((p) => o ? p.mark.type !== o && p.mark.type.excludes(o) : !0).reduce((p, g) => p + g.to - g.from, 0);
  return (u > 0 ? u + d : u) >= a;
}
function Bf(n, e, t = {}) {
  return n.find((r) => r.type === e && yc(r.attrs, t));
}
function ID(n, e, t = {}) {
  return !!Bf(n, e, t);
}
function AD(n, e, t = {}) {
  if (!n || !e)
    return;
  let r = n.parent.childAfter(n.parentOffset);
  if (n.parentOffset === r.offset && r.offset !== 0 && (r = n.parent.childBefore(n.parentOffset)), !r.node)
    return;
  const i = Bf([...r.node.marks], e, t);
  if (!i)
    return;
  let o = r.index, a = n.start() + r.offset, l = o + 1, u = a + r.node.nodeSize;
  for (Bf([...r.node.marks], e, t); o > 0 && i.isInSet(n.parent.child(o - 1).marks); )
    o -= 1, a -= n.parent.child(o).nodeSize;
  for (; l < n.parent.childCount && ID([...n.parent.child(l).marks], e, t); )
    u += n.parent.child(l).nodeSize, l += 1;
  return {
    from: a,
    to: u
  };
}
const Xc = (n, e = {}) => (t, r) => {
  var p;
  const { extendEmptyMarkRange: i = !1 } = e, o = t.tr, { selection: a } = o, l = t.schema.mark(n), { $from: u, empty: d, ranges: h } = a;
  if (d && i) {
    let { from: g, to: v } = a;
    const m = (p = u.marks().find((b) => b.type === l.type)) == null ? void 0 : p.attrs, w = AD(u, l.type, m);
    w && (g = w.from, v = w.to), o.removeMark(g, v, l);
  } else
    h.forEach((g) => {
      o.removeMark(g.$from.pos, g.$to.pos, l);
    });
  return o.removeStoredMark(l), r ? (r(o), !0) : !1;
}, Eh = (n, e = {}, t = {}) => (r, i, ...o) => {
  const a = Kc(n, r.schema);
  return zf(r, a) ? Xc(a, t)(r, i, ...o) : Ia(a, e)(r, i, ...o);
}, wc = (...n) => Eh("bold")(...n), LD = (...n) => Xc("bold")(...n), PD = (...n) => Ia("bold")(...n), Vd = (n, e) => {
  const t = n.tr.setSelection(n.selection), { $from: r, $to: i } = t.selection, o = r.blockRange(i);
  return o && e ? (e(
    n.tr.removeMark(
      o.start,
      o.end,
      n.schema.mark("bold")
    )
  ), !0) : !1;
}, bc = (...n) => Eh("italic")(...n), _D = (...n) => Xc("italic")(...n), ND = (...n) => Ia("italic")(...n), Wd = (n, e) => {
  const { $from: t, $to: r } = n.selection, i = t.blockRange(r);
  if (i && e) {
    const o = n.schema.mark("bold");
    return e(n.tr.removeMark(i.start, i.end, o)), !0;
  }
  return !1;
}, un = (n) => (e, t) => {
  const r = e.tr, { doc: i } = r, { from: o, to: a } = n, l = it.atStart(i).from, u = it.atEnd(i).to, d = Math.min(Math.max(o, l), u), h = Math.min(Math.max(a, l), u), p = it.create(i, d, h);
  return r.setSelection(p), t ? (t(r), !0) : !1;
}, Cr = (n, e, ...t) => (un({ from: 0, to: n.doc.content.size })(n, e, ...t), !0), zD = (n, e) => BD((t) => ({ type: t.type.schema.nodes.paragraph, attrs: t.attrs }))(n, e);
function BD(n) {
  return (e, t) => {
    const { $from: r, $to: i } = e.selection;
    if (e.selection instanceof He && e.selection.node.isBlock)
      return !r.parentOffset || !vo(e.doc, r.pos) ? !1 : (t && t(e.tr.split(r.pos).scrollIntoView()), !0);
    if (!r.parent.isBlock)
      return !1;
    const o = i.parentOffset === i.parent.content.size, a = e.tr;
    (e.selection instanceof it || e.selection instanceof Ln) && a.deleteSelection();
    const l = r.depth === 0 ? null : FD(r.node(-1).contentMatchAt(r.indexAfter(-1))), u = n && n(i.parent, o);
    let d = u ? [u] : o && l ? [{ type: l }] : void 0, h = vo(a.doc, a.mapping.map(r.pos), 1, d);
    if (!d && !h && vo(
      a.doc,
      a.mapping.map(r.pos),
      1,
      l ? [{ type: l }] : void 0
    ) && (l && (d = [{ type: l }]), h = !0), h && (a.split(a.mapping.map(r.pos), 1, d), !o && !r.parentOffset && r.parent.type !== l)) {
      const g = a.mapping.map(r.before()), v = a.doc.resolve(g);
      l && r.node(-1).canReplaceWith(v.index(), v.index() + 1, l) && a.setNodeMarkup(a.mapping.map(r.before()), l);
    }
    const p = e.storedMarks || e.selection.$to.parentOffset && e.selection.$from.marks();
    return p && a.ensureMarks(p), t && t(a), !0;
  };
}
function FD(n) {
  for (let e = 0; e < n.edgeCount; e++) {
    const { type: t } = n.edge(e);
    if (t.isTextblock && !t.hasRequiredAttrs())
      return t;
  }
  return null;
}
function VD(n, e) {
  const t = {};
  let r;
  function i(o, a) {
    if (e) {
      const l = e[o];
      if (l === !1)
        return;
      l && (o = l);
    }
    t[o] = a;
  }
  if (i("Mod-z", kw), i("Mod-y", Ow), i("Mod-a", Cr), i("Backspace", SD), i("Alt-ArrowUp", oR), i("Alt-ArrowDown", sR), i("Mod-BracketLeft", aR), i("Escape", hR), (r = n.marks.bold) && (i("Mod-b", wc), i("Mod-B", wc)), (r = n.marks.italic) && (i("Mod-i", bc), i("Mod-I", bc)), i("Enter", zD), r = n.nodes.hard_break) {
    const o = r, a = jc(Hy, (l, u) => (u && u(l.tr.replaceSelectionWith(o.create()).scrollIntoView()), !0));
    i("Mod-Enter", a), i("Shift-Enter", a), jT && i("Ctrl-Enter", a);
  }
  return (r = n.nodes.paragraph) && i("Shift-Ctrl-0", yR(r)), t;
}
const WD = () => new Ma({
  view() {
    return {
      update: function(n, e) {
        const t = n.state;
        if (!(e && e.doc.eq(t.doc) && e.selection.eq(t.selection))) {
          if (e && !e.doc.eq(t.doc)) {
            n.events.emit("update", n);
            return;
          }
          n.events.emit("selectionUpdate", n);
        }
      }
    };
  }
});
function HD(n) {
  return Ch(/^\s*>\s$/, n);
}
function $D(n) {
  return Ch(
    /^(\d+)\.\s$/,
    n,
    (e) => ({ order: +e[1] }),
    (e, t) => t.childCount + t.attrs.order === +e[1]
  );
}
function UD(n) {
  return Ch(/^\s*([-+*])\s$/, n);
}
function ZD(n) {
  return Tw(/^```$/, n);
}
function jD(n, e) {
  return Tw(
    new RegExp("^(#{1," + e + "})\\s$"),
    n,
    (t) => ({
      level: t[1].length
    })
  );
}
function YD(n) {
  const e = RD.concat(ED, CD);
  let t;
  return (t = n.nodes.blockquote) && e.push(HD(t)), (t = n.nodes.ordered_list) && e.push($D(t)), (t = n.nodes.bullet_list) && e.push(UD(t)), (t = n.nodes.code_block) && e.push(ZD(t)), (t = n.nodes.heading) && e.push(jD(t, 6)), xD({ rules: e });
}
function qD(n) {
  const e = /* @__PURE__ */ Object.create(null);
  for (const t in n)
    e[Bt(t)] = n[t];
  return e;
}
function Nm(n) {
  return new Ma({ props: { handleKeyDown: GD(n) } });
}
function GD(n) {
  const e = qD(n);
  return function(t, r) {
    r.stopPropagation();
    const i = fh(r), o = e[Hl(i, r)];
    let a;
    if (o && o(t.state, t.dispatch, t))
      return !0;
    if (i.length === 1 && i !== " ") {
      if (r.shiftKey) {
        const l = e[Hl(i, r, !1)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
      if ((r.shiftKey || r.altKey || r.metaKey || i.charCodeAt(0) > 127) && (a = ci[r.keyCode]) && a !== i) {
        const l = e[Hl(a, r)];
        if (l && l(t.state, t.dispatch, t))
          return !0;
      }
    }
    return !1;
  };
}
const KD = {
  parseDOM: [
    { tag: "strong" },
    // This works around a Google Docs misbehavior where
    // pasted content will be inexplicably wrapped in `<b>`
    // tags with a font-weight normal.
    {
      tag: "b",
      getAttrs: (n) => n.style.fontWeight !== "normal" && null
    },
    {
      style: "font-weight",
      getAttrs: (n) => /^(bold(er)?|[5-9]\d{2,})$/.test(n) && null
    }
  ],
  toDOM() {
    return ["strong", 0];
  }
}, XD = {
  content: "listItem+",
  group: "block",
  attrs: {
    align: { default: null },
    style: { default: "list-style-type: disc;padding-left: 1.7em;margin:0;" }
  },
  parseDOM: [{ tag: "ul" }],
  toDOM(n) {
    return ["ul", n.attrs, 0];
  }
}, JD = {
  parseDOM: [{ tag: "i" }, { tag: "em" }, { style: "font-style=italic" }],
  toDOM() {
    return ["em", 0];
  }
}, QD = {
  content: "paragraph block*",
  parseDOM: [{ tag: "li" }],
  attrs: {
    align: { default: null },
    style: { default: "display: list-item; " }
  },
  toDOM(n) {
    return ["li", n.attrs, 0];
  },
  defining: !0
}, eI = {
  attrs: {
    textAlign: { default: null },
    color: { default: null },
    fontFamily: { default: null },
    fontSize: { default: null },
    lineHeight: { default: null },
    letterSpacing: { default: null },
    textTransform: { default: null },
    marginLeft: { default: null },
    indent: { default: null },
    listType: { default: "" }
  },
  content: "inline*",
  group: "block",
  parseDOM: [{ tag: "p", getAttrs: (n) => tI(n) }],
  toDOM: (n) => nI(n)
}, tI = (n) => {
  const {
    lineHeight: e,
    letterSpacing: t,
    textTransform: r,
    textAlign: i,
    fontFamily: o,
    fontSize: a,
    color: l
  } = n.style, u = n.getAttribute("data-indent"), d = u ? parseInt(u, 10) : 0, h = d && n.getAttribute("data-list-type") === "ordered" ? "ordered" : "";
  return {
    textAlign: i,
    textTransform: r,
    lineHeight: e,
    letterSpacing: parseFloat(t),
    fontFamily: o.replaceAll('"', ""),
    fontSize: a,
    color: l,
    indent: d,
    listType: h
  };
}, nI = (n) => {
  const {
    textAlign: e,
    textTransform: t,
    lineHeight: r,
    letterSpacing: i,
    fontFamily: o,
    fontSize: a,
    color: l,
    indent: u,
    listType: d
  } = n.attrs, h = {};
  let p = "";
  if (e && e !== "left" && (p += `text-align: ${e};`), o && (p += `font-family: ${o};`), t && (p += `text-transform: ${t};`), a && (p += `font-size: ${a};`), l && (p += `color: ${l};`), u)
    if (p += `--indent-level: ${u};`, p += "display: list-item;", h["data-indent"] = String(u), h["data-list-type"] = d, d === "ordered") {
      p += "list-style-type: none;";
      const g = ["decimal", "lower-alpha", "lower-roman"], v = g[(u - 1) % g.length];
      p += `--counter-list-marker: ${v};`;
    } else
      p += "list-style-type: disc;";
  return p += `line-height: ${r || 1.4};`, p += `letter-spacing: ${i}em;`, p && (h.style = p), ["p", h, 0];
}, rI = {
  attrs: {
    color: { default: "" }
  },
  inline: !0,
  group: "inline",
  parseDOM: [
    {
      style: "color",
      getAttrs: (n) => ({
        color: n
      })
    }
  ],
  toDOM(n) {
    const { color: e } = n.attrs;
    let t = "";
    return e && (t += `color: ${e};`), ["span", { style: t }, 0];
  }
}, iI = {
  parseDOM: [
    { tag: "u" },
    {
      style: "text-decoration-line",
      getAttrs: (n) => n === "underline" && null
    },
    {
      style: "text-decoration",
      getAttrs: (n) => n === "underline" && null
    }
  ],
  toDOM() {
    return ["u", 0];
  }
}, oI = ["br"], sI = {
  /// NodeSpec The top level document node.
  doc: {
    content: "block+"
  },
  /// A plain paragraph textblock. Represented in the DOM
  /// as a `<p>` element.
  paragraph: eI,
  listItem: QD,
  bulletList: XD,
  /// The text node.
  text: {
    group: "inline"
  },
  /// A hard line break, represented in the DOM as `<br>`.
  hard_break: {
    inline: !0,
    group: "inline",
    selectable: !1,
    parseDOM: [{ tag: "br" }],
    toDOM() {
      return oI;
    }
  }
}, aI = {
  link: {
    attrs: {
      href: {},
      title: { default: null }
    },
    inclusive: !1,
    parseDOM: [
      {
        tag: "a[href]",
        getAttrs(n) {
          return {
            href: n.getAttribute("href"),
            title: n.getAttribute("title")
          };
        }
      }
    ],
    toDOM(n) {
      const { href: e, title: t } = n.attrs;
      return ["a", { href: e, title: t }, 0];
    }
  },
  italic: JD,
  bold: KD,
  underline: iI,
  color: rI
}, zm = new Sy({ nodes: sI, marks: aI });
class lI {
  constructor() {
    this.callbacks = {};
  }
  on(e, t) {
    return this.callbacks[e] || (this.callbacks[e] = []), this.callbacks[e].push(t), this;
  }
  emit(e, ...t) {
    const r = this.callbacks[e];
    return r && r.forEach((i) => i.apply(this, t)), this;
  }
  off(e, t) {
    const r = this.callbacks[e];
    return r && (t ? this.callbacks[e] = r.filter((i) => i !== t) : delete this.callbacks[e]), this;
  }
}
const Hd = new Sy({
  nodes: zm.spec.nodes,
  marks: zm.spec.marks
}), Mw = ({
  content: n,
  ele: e = null,
  handleDOMEvents: t = {}
}) => {
  const r = document.createElement("div");
  r.innerHTML = n;
  const i = Xo.create({
    doc: xo.fromSchema(Hd).parse(r),
    plugins: [
      YD(Hd),
      Nm(VD(Hd)),
      Nm(bR),
      sD(),
      yD(),
      WD()
    ]
  }), o = new tD(e, {
    attributes: { class: "lidojs-text" },
    state: i,
    handleDOMEvents: t
  });
  return o.events = new lI(), o;
}, Rw = ({
  text: n,
  boxSize: e,
  scale: t,
  fonts: r,
  colors: i,
  fontSizes: o,
  effect: a,
  rotate: l,
  position: u,
  ...d
}) => {
  const { actions: h, id: p, pageIndex: g } = gs(), { selectedLayerIds: v } = rn(), { textEditor: m } = je((C) => ({
    textEditor: C.textEditor
  }));
  be(() => {
    const C = Mw({ content: n });
    C && h.setTextEditor(C);
  }, []);
  const w = Ie(() => {
    v.includes(p) && h.openTextEditor();
  }, [h, p, v]), b = pe(() => m ? m.pageIndex === g && m.layerId === p : !1, [p, g, m]);
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        transformOrigin: "0 0"
      },
      style: {
        width: e.width / t,
        height: e.height / t,
        transform: `scale(${t})`,
        opacity: b ? 0 : 1
      },
      onDoubleClick: w,
      children: /* @__PURE__ */ x(
        u8,
        {
          boxSize: e,
          colors: i,
          effect: a,
          fontSizes: o,
          fonts: r,
          position: u,
          rotate: l,
          scale: t,
          text: n,
          ...d
        }
      )
    }
  );
};
Rw.info = {
  name: "Text",
  type: "Text"
};
const Dw = ({
  video: n,
  boxSize: e,
  position: t,
  rotate: r,
  ...i
}) => {
  const { actions: o, pageIndex: a, id: l } = gs(), { selectedLayerIds: u } = rn(), { imageEditor: d } = je((h) => ({
    imageEditor: h.imageEditor
  }));
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        pointerEvents: "auto",
        visibility: d && d.pageIndex === a && d.layerId === l ? "hidden" : void 0
      },
      onDoubleClick: () => u.includes(l) && o.openImageEditor({ position: t, rotate: r, boxSize: e, video: n }),
      children: /* @__PURE__ */ x(
        d8,
        {
          boxSize: e,
          position: t,
          rotate: r,
          video: n,
          ...i
        }
      )
    }
  );
};
Dw.info = {
  name: "Video",
  type: "Video"
};
const js = {
  RootLayer: oy,
  ShapeLayer: sy,
  TextLayer: Rw,
  ImageLayer: ry,
  GroupLayer: ny,
  FrameLayer: ty,
  SvgLayer: ay,
  LineLayer: iy,
  VideoLayer: Dw
}, cI = (n) => {
  const e = typeof n == "string" ? "string" : n.name;
  return (() => {
    if (js[e])
      return e;
    for (let r = 0; r < Object.keys(js).length; r++) {
      const i = Object.keys(js)[r];
      if (js[i] === n)
        return i;
    }
    return n;
  })();
}, Sr = () => nM(), Yn = (n) => {
  const { type: e, props: t } = uI(n);
  return {
    ...e.info,
    comp: e,
    props: t,
    locked: n.locked,
    child: n.child,
    parent: n.parent
  };
}, uI = (n) => {
  const {
    type: { resolvedName: e },
    props: t
  } = n, r = js[e];
  return Xl(r, t);
}, Aa = (n, e) => {
  let t = {};
  return t[e] = {
    type: {
      resolvedName: cI(n[e].data.comp)
    },
    props: n[e].data.props,
    locked: n[e].data.locked,
    child: n[e].data.child,
    parent: n[e].data.parent
  }, n[e].data.child.forEach((r) => {
    t = { ...t, ...Aa(n, r) };
  }), t;
}, Fi = (n) => n.data.type === "Root", dI = (n) => n.data.parent === "ROOT", fs = (n) => n.data.type === "Group", ui = (n) => n.data.type === "Text", Vi = (n) => n.data.type === "Frame", kh = (n) => n.data.type === "Svg", Jo = (n) => n.data.type === "Image", xc = (n) => n.data.type === "Shape", Iw = (n) => n.data.type === "Line", Pl = (n) => n.data.type === "Video", Aw = () => {
  const n = ge(!1);
  return be(() => {
    const e = (t) => {
      n.current = t.shiftKey;
    };
    return window.addEventListener("keydown", e, { capture: !0 }), window.addEventListener("keyup", e, { capture: !0 }), () => {
      window.removeEventListener("keydown", e, {
        capture: !0
      }), window.removeEventListener("keyup", e, { capture: !0 });
    };
  }, []), n;
}, fI = ({
  frameRef: n,
  pageListRef: e
}) => {
  const t = ge(null), r = ge(null), i = Aw(), [, o, a] = Pi({}), [, l, u] = Pi(), { selectedLayers: d, selectedLayerIds: h } = rn(), {
    actions: p,
    state: g,
    hoveredLayer: v,
    controlBox: m,
    scale: w,
    hoveredPage: b,
    activePage: C,
    pageSize: M,
    layers: k,
    mainLayers: D,
    isPageLocked: T
  } = je((F, Y) => {
    const Q = parseInt(Object.keys(F.hoveredLayer)[0]), ee = F.hoveredLayer[Q];
    return {
      scale: F.scale,
      hoveredPage: Q,
      isPageLocked: F.pages.length > 0 && F.pages[F.activePage] ? F.pages[F.activePage].layers.ROOT.data.locked : !1,
      controlBox: F.controlBox,
      hoveredLayer: ee ? F.pages[Q].layers[ee] : null,
      activePage: F.activePage,
      pageSize: Y.getPageSize(),
      fontList: F.fontList,
      layers: F.pages[Q] && F.pages[Q].layers,
      mainLayers: F.pages[Q] && ey(
        F.pages[Q].layers.ROOT.data.child.map(
          (ie) => F.pages[Q].layers[ie]
        )
      )
    };
  }), R = ({ clientX: F, clientY: Y }) => {
    var se;
    const Q = o(), ee = (se = t.current) == null ? void 0 : se.start, ie = (F - ee.clientX) / w, re = (Y - ee.clientY) / w, oe = {
      layers: {}
    };
    Object.entries(Q).forEach(([we, Oe]) => {
      oe.layers[we] = {
        x: Oe.position.x + ie,
        y: Oe.position.y + re
      };
    });
    const de = l();
    return de && (oe.controlBox = {
      x: de.position.x + ie,
      y: de.position.y + re
    }), oe;
  }, _ = Te.throttle((F) => {
    if (!t.current)
      return;
    const { clientX: Y, clientY: Q } = Wt(F);
    t.current.last = {
      clientX: Y + n.current.scrollLeft,
      clientY: Q + n.current.scrollTop
    }, t.current.e = F;
    const ee = R(t.current.last), ie = l(), re = ee.controlBox && ie && !i.current ? Bm(
      { ...ie, position: ee.controlBox },
      Object.keys(ee.layers),
      k,
      w
    ) : null;
    !i.current && (t.current.last.clientX !== t.current.start.clientX || t.current.last.clientY !== t.current.start.clientY) && p.setGuideline({
      horizontal: (re == null ? void 0 : re.line.horizontal) || [],
      vertical: (re == null ? void 0 : re.line.vertical) || []
    }), p.setDragData(!0, Object.keys(ee.layers)), Object.entries(ee.layers).forEach(([se, we]) => {
      t.current && p.history.merge().setProp(t.current.pageIndex, se, {
        position: {
          x: we.x + ((re == null ? void 0 : re.x) || 0),
          y: we.y + ((re == null ? void 0 : re.y) || 0)
        }
      });
    });
    const oe = Object.keys(ee.layers), de = g.pages[t.current.pageIndex].layers[oe[0]];
    if (oe.length === 1 && Jo(de)) {
      const se = D.find((we) => {
        if (we.id !== de.id) {
          const Oe = new WebKitCSSMatrix(
            ut({
              rotate: we.data.props.rotate
            })
          ), le = e.current[C].getBoundingClientRect(), Ce = oi(
            {
              width: we.data.props.boxSize.width * w,
              height: we.data.props.boxSize.height * w
            },
            Oe,
            {
              x: le.x + we.data.props.position.x * w,
              y: le.y + we.data.props.position.y * w
            }
          );
          if (Jl({ x: Y, y: Q }, Ce))
            return !0;
        }
        return !1;
      });
      if (r.current && (p.history.merge().setProp(t.current.pageIndex, de.id, {
        transparency: r.current.imageLayer.data.props.image.transparency || 1
      }), p.history.merge().setProp(
        t.current.pageIndex,
        r.current.affectedFrame.id,
        {
          image: r.current.affectedFrame.data.props.image ? {
            url: r.current.affectedFrame.data.props.image.url,
            boxSize: r.current.affectedFrame.data.props.image.boxSize,
            position: r.current.affectedFrame.data.props.image.position,
            rotate: r.current.affectedFrame.data.props.image.rotate
          } : null
        }
      ), r.current = null), se && Vi(se)) {
        const we = de.data.props.image, Oe = se.data.props.boxSize.width / se.data.props.boxSize.height, le = we.boxSize.width / we.boxSize.height;
        r.current = {
          imageLayer: Te.cloneDeep(de),
          affectedFrame: Te.cloneDeep(se)
        }, p.history.merge().setProp(t.current.pageIndex, de.id, {
          transparency: 0.5
        }), Oe > le ? p.history.merge().setProp(
          t.current.pageIndex,
          se.id,
          {
            image: {
              url: we.url,
              thumb: we.thumb,
              boxSize: {
                width: se.data.props.boxSize.width / se.data.props.scale,
                height: se.data.props.boxSize.width / se.data.props.scale / le
              },
              rotate: 0,
              position: {
                x: 0,
                y: -(se.data.props.boxSize.width / se.data.props.scale / le - se.data.props.boxSize.height / se.data.props.scale) / 2
              }
            }
          }
        ) : p.history.merge().setProp(
          t.current.pageIndex,
          se.id,
          {
            image: {
              url: we.url,
              thumb: we.thumb,
              boxSize: {
                width: se.data.props.boxSize.height / se.data.props.scale * le,
                height: se.data.props.boxSize.height / se.data.props.scale
              },
              position: {
                x: -(se.data.props.boxSize.height / se.data.props.scale * le - se.data.props.boxSize.width / se.data.props.scale) / 2,
                y: 0
              },
              rotate: 0
            }
          }
        );
      }
    }
    ee.controlBox && ie && (p.setDragData(!0, oe), p.setControlBox({
      ...ie,
      position: {
        x: ee.controlBox.x + ((re == null ? void 0 : re.x) || 0),
        y: ee.controlBox.y + ((re == null ? void 0 : re.y) || 0)
      }
    }));
  }, 16), Z = () => {
    var Q;
    if (!t.current)
      return;
    const { clientX: F, clientY: Y } = t.current.last;
    if (p.setGuideline({ vertical: [], horizontal: [] }), F === t.current.start.clientX && Y === t.current.start.clientY)
      v && p.selectLayers(
        b,
        v.id,
        i.current ? "add" : "replace"
      ), p.history.back();
    else {
      const ee = l();
      let ie = !1;
      const re = R({ clientX: F, clientY: Y }), oe = re.controlBox && ee && !i.current ? Bm(
        { ...ee, position: re.controlBox },
        Object.keys(re.layers),
        k,
        w
      ) : null;
      if (re.controlBox && ee) {
        const de = {
          ...ee,
          position: {
            x: re.controlBox.x + ((oe == null ? void 0 : oe.x) || 0),
            y: re.controlBox.y + ((oe == null ? void 0 : oe.y) || 0)
          }
        }, se = hr(
          de.boxSize,
          de.position,
          de.rotate
        );
        (se.x >= M.width || se.y >= M.height || se.x + se.width < 0 || se.y + se.height < 0) && (p.deleteLayer(
          (Q = t.current) == null ? void 0 : Q.pageIndex,
          Object.keys(re.layers)
        ), ie = !0);
      }
      !ie && Object.entries(re.layers).forEach(([de, se]) => {
        t.current && p.history.merge().setProp(t.current.pageIndex, de, {
          position: {
            x: se.x + ((oe == null ? void 0 : oe.x) || 0),
            y: se.y + ((oe == null ? void 0 : oe.y) || 0)
          }
        });
      }), r.current && (p.history.merge().deleteLayer(
        t.current.pageIndex,
        r.current.imageLayer.id
      ), r.current = null), re.controlBox && ee && !ie && p.setControlBox({
        ...ee,
        position: {
          x: re.controlBox.x + ((oe == null ? void 0 : oe.x) || 0),
          y: re.controlBox.y + ((oe == null ? void 0 : oe.y) || 0)
        }
      });
    }
    t.current = null, a({}), p.setDragData(!1), window.removeEventListener("mousemove", _), window.removeEventListener("mouseup", Z), window.removeEventListener("mouseleave", Z), window.removeEventListener("touchmove", _), window.removeEventListener("touchend", Z);
  }, K = () => {
    p.history.new(), window.addEventListener("touchmove", _), window.addEventListener("mousemove", _), window.addEventListener("mouseup", Z, { once: !0 }), window.addEventListener("mouseleave", Z, { once: !0 }), window.addEventListener("touchend", Z, { once: !0 });
  };
  return be(() => {
    const F = () => {
      t.current && _(t.current.e);
    }, Y = n.current;
    return Y == null || Y.addEventListener("scroll", F), () => {
      Y == null || Y.removeEventListener("scroll", F);
    };
  }, [n, _]), {
    onDragStart: (F) => {
      const { clientX: Y, clientY: Q } = Wt(F);
      t.current = {
        start: {
          clientX: Y + n.current.scrollLeft,
          clientY: Q + n.current.scrollTop
        },
        last: {
          clientX: Y + n.current.scrollLeft,
          clientY: Q + n.current.scrollTop
        },
        pageIndex: C,
        e: F
      };
      const ee = {};
      let ie = !1, re = !1, oe = !1;
      if (m) {
        const de = new WebKitCSSMatrix(
          ut({
            rotate: m.rotate
          })
        ), se = e.current[C].getBoundingClientRect(), we = oi(
          {
            width: m.boxSize.width * w,
            height: m.boxSize.height * w
          },
          de,
          {
            x: se.x + m.position.x * w,
            y: se.y + m.position.y * w
          }
        );
        ie = Jl(
          { x: Y, y: Q },
          we
        ), ie && v && !h.includes(v.id) && (re = M1(
          v.data.props,
          m
        ));
      }
      if ((i.current || ie && !re) && d.forEach(
        ({
          id: de,
          data: {
            props: { position: se, boxSize: we, rotate: Oe, scale: le },
            locked: Ce,
            type: Ne
          }
        }) => {
          Ce || (oe = Ce), ee[de] = Te.cloneDeep({
            position: se,
            boxSize: we,
            rotate: Oe,
            scale: le,
            type: Ne
          });
        }
      ), v && (!ie || ie && re)) {
        const { position: de, boxSize: se, rotate: we, scale: Oe } = v.data.props;
        ee[v.id] = Te.cloneDeep({
          position: de,
          boxSize: se,
          rotate: we,
          scale: Oe,
          type: v.data.type
        }), oe || (oe = v.data.locked), t.current && (t.current.pageIndex = b);
        const le = oa(ee);
        le && u(le);
      } else
        m && (oe = !!d.find(
          ({ data: { locked: de } }) => de
        ), u(m));
      a(ee), !oe && !T ? (Hc && p.setDragData(!0, Object.keys(ee)), K()) : t.current = null;
    }
  };
}, Bm = (n, e, t, r) => {
  const i = {
    x: null,
    y: null,
    line: {
      horizontal: [],
      vertical: []
    }
  };
  if (n && n) {
    const o = hr(
      n.boxSize,
      n.position,
      n.rotate
    ), a = {
      top: o.y,
      left: o.x,
      right: o.x + o.width,
      bottom: o.y + o.height,
      centerX: o.centerX,
      centerY: o.centerY
    };
    Object.entries(t).forEach(([l, u]) => {
      if (e.includes(l) || u.data.parent !== "ROOT")
        return;
      const d = hr(
        u.data.props.boxSize,
        u.data.props.position,
        u.data.props.rotate
      ), h = {
        top: d.y,
        left: d.x,
        right: d.x + d.width,
        bottom: d.y + d.height,
        centerX: d.centerX,
        centerY: d.centerY
      }, p = ["top", "bottom", "centerY"], g = ["left", "right", "centerX"];
      Object.keys(a).forEach((v) => {
        p.includes(v) && p.forEach((m) => {
          Fm(
            a[v],
            h[m],
            r
          ) && ((i.y === null || i.y < h[m] - a[v]) && (i.y = h[m] - a[v]), a[v] + i.y === h[m] && i.line.horizontal.push({
            y: h[m],
            x1: Math.min(a.left, h.left),
            x2: Math.max(a.right, h.right)
          }));
        }), g.includes(v) && g.forEach((m) => {
          Fm(
            a[v],
            h[m],
            r
          ) && ((i.x === null || i.x < h[m] - a[v]) && (i.x = h[m] - a[v]), a[v] + i.x === h[m] && i.line.vertical.push({
            x: h[m],
            y1: Math.min(a.top, h.top),
            y2: Math.max(a.bottom, h.bottom)
          }));
        });
      });
    });
  }
  return i;
}, hI = 4, Fm = (n, e, t) => Math.abs(Math.round(n) - Math.round(e)) <= hI / t, pI = ({
  frameRef: n,
  pageListRef: e,
  selectionBoxRef: t
}) => {
  const [r, i] = Le(), [o, a] = Pi({
    clientX: 0,
    clientY: 0,
    moveClientX: 0,
    moveClientY: 0,
    isMultipleSelect: !1
  }), { actions: l, scale: u, isSelecting: d, pages: h } = je((M) => ({
    scale: M.scale,
    isSelecting: M.selectData.status,
    pages: M.pages
  })), p = () => h.map(({ layers: M }, k) => ({
    layers: [...M.ROOT.data.child, "ROOT"].reverse().reduce((D, T) => {
      var F, Y;
      const {
        id: R,
        data: { props: _ }
      } = M[T];
      if (!e.current[k])
        return D;
      const Z = e.current[k].getBoundingClientRect(), K = new WebKitCSSMatrix(
        ut({ rotate: _.rotate })
      ), $ = oi(
        {
          width: _.boxSize.width * u,
          height: _.boxSize.height * u
        },
        K,
        {
          x: Z.x + (((F = n.current) == null ? void 0 : F.scrollLeft) || 0) + _.position.x * u,
          y: Z.y + (((Y = n.current) == null ? void 0 : Y.scrollTop) || 0) + _.position.y * u
        }
      );
      return D.push({
        id: R,
        delta: [
          $.nw,
          $.ne,
          $.se,
          $.sw
        ]
      }), D;
    }, [])
  })), g = Ie(
    ({ clientX: M, clientY: k }, D = !1) => {
      if (t.current && n.current) {
        const T = n.current.getBoundingClientRect(), R = n.current.scrollTop || 0, _ = n.current.scrollLeft || 0, Z = a(), K = Math.abs(M + _ - Z.clientX), $ = Math.abs(k + R - Z.clientY), F = M + _ > Z.clientX ? Z.clientX : M + _, Y = k + R > Z.clientY ? Z.clientY : k + R;
        t.current.style.left = `${F - T.x}px`, t.current.style.top = `${Y - T.y}px`, t.current.style.width = `${K}px`, t.current.style.height = `${$}px`;
        const Q = [
          { x: F, y: Y },
          { x: F + K, y: Y },
          { x: F + K, y: Y + $ },
          { x: F, y: Y + $ }
        ], ee = {};
        let ie = null;
        if (p().forEach(({ layers: re }, oe) => {
          var we;
          const de = e.current[oe].getBoundingClientRect();
          re.forEach(({ id: Oe, delta: le }) => {
            var Ce, Ne;
            g0(Q, le) && (ie === null || ie === oe) && Oe !== "ROOT" && (D && ie === null || !D) && (ie = oe, ee[Oe] = {
              boxSize: {
                width: h[ie].layers[Oe].data.props.boxSize.width * u,
                height: h[ie].layers[Oe].data.props.boxSize.height * u
              },
              position: {
                x: de.x - T.x + (((Ce = n.current) == null ? void 0 : Ce.scrollLeft) || 0) + h[ie].layers[Oe].data.props.position.x * u,
                y: de.y - T.y + (((Ne = n.current) == null ? void 0 : Ne.scrollTop) || 0) + h[ie].layers[Oe].data.props.position.y * u
              },
              rotate: h[ie].layers[Oe].data.props.rotate
            });
          });
          const se = re.find((Oe) => Oe.id === "ROOT");
          D && se && g0(Q, se.delta) && ie === null && (ie = oe, ee.ROOT = {
            boxSize: {
              width: h[ie].layers.ROOT.data.props.boxSize.width * u,
              height: h[ie].layers.ROOT.data.props.boxSize.height * u
            },
            position: {
              x: de.x - T.x + h[ie].layers.ROOT.data.props.position.x * u,
              y: de.y - T.y + (((we = n.current) == null ? void 0 : we.scrollTop) || 0) + h[ie].layers.ROOT.data.props.position.y * u
            },
            rotate: h[ie].layers.ROOT.data.props.rotate
          });
        }), ie !== null)
          return {
            selectedPage: ie,
            selectedLayers: ee
          };
      }
    },
    [p, a]
  ), v = Ie(
    (M) => {
      l.setSelectData(!0);
      const { clientX: k, clientY: D } = Wt(M);
      o.current.moveClientX = k, o.current.moveClientY = D;
      const T = g({ clientX: k, clientY: D });
      i(T);
    },
    [g]
  ), m = Ie(
    (M) => {
      const { clientX: k, clientY: D } = Wt(M), T = g(
        { clientX: k, clientY: D },
        k + n.current.scrollLeft === a().clientX && D + n.current.scrollTop === a().clientY
      );
      T ? l.selectLayers(
        T.selectedPage,
        Object.keys(T.selectedLayers),
        a().isMultipleSelect ? "add" : "replace"
      ) : (l.resetSelectLayer(), l.setSidebar()), b(), l.setSelectData(!1);
    },
    [g]
  ), w = Ie(() => {
    window.addEventListener("mousemove", v), window.addEventListener("mouseup", m, { once: !0 });
  }, [v, m]), b = Ie(() => {
    window.removeEventListener("mousemove", v), window.removeEventListener("mouseup", m);
  }, [v]), C = (M) => {
    const { clientX: k, clientY: D } = Wt(M);
    i(void 0), l.setSelectData(!0), o.current.clientX = k + n.current.scrollLeft, o.current.clientY = D + n.current.scrollTop, w();
  };
  return be(() => {
    var k;
    const M = () => {
      if (d) {
        const D = g({
          clientX: o.current.moveClientX || o.current.clientX,
          clientY: o.current.moveClientY || o.current.clientY
        });
        D && i(D);
      }
    };
    return (k = n.current) == null || k.addEventListener("scroll", M), () => {
      var D;
      (D = n.current) == null || D.removeEventListener("scroll", M);
    };
  }, [d]), {
    tmpSelected: r,
    onSelectStart: C
  };
}, Lw = async (n, { pageIndex: e, layerIds: t }) => {
  const r = [];
  t.forEach((i) => {
    r.push({
      rootId: i,
      layers: Aa(n.pages[e].layers, i)
    });
  }), await navigator.clipboard.writeText(JSON.stringify(r));
}, Oh = (n, {
  pageIndex: e,
  layerIds: t,
  actions: r
}) => {
  const i = [];
  t.forEach((o) => {
    i.push({
      rootId: o,
      layers: Te.cloneDeep(
        Aa(n.pages[e].layers, o)
      )
    });
  }), r.addLayerTrees(
    i.map((o) => (Object.entries(o.layers).forEach(([a]) => {
      o.layers[a].props.position.x += 10, o.layers[a].props.position.y += 10;
    }), o))
  );
}, Pw = async ({ actions: n }) => {
  const e = await navigator.clipboard.readText();
  try {
    JSON.parse(e).forEach((r) => {
      Object.entries(r.layers).forEach(([i]) => {
        r.layers[i].props.position.x += 10, r.layers[i].props.position.y += 10;
      }), n.addLayerTree(r);
    });
  } catch (t) {
    console.error(t);
  }
}, gI = (n) => {
  const { actions: e, state: t, activePage: r, rootLayer: i, scale: o } = je(
    (T) => ({
      rootLayer: T.pages[T.activePage] && T.pages[T.activePage].layers.ROOT,
      activePage: T.activePage,
      scale: T.scale
    })
  ), { selectedLayerIds: a } = rn(), l = Ie(async () => {
    await Pw({ actions: e }), e.hideContextMenu();
  }, [e]), u = Ie(async () => {
    await Lw(t, { pageIndex: r, layerIds: a }), e.hideContextMenu();
  }, [e, t, r, a]), d = Ie(() => {
    Oh(t, {
      pageIndex: r,
      layerIds: a,
      actions: e
    }), e.hideContextMenu();
  }, [t, r, a, e]), h = Ie(() => {
    a.includes("ROOT") || e.deleteLayer(t.activePage, a);
  }, [a, t, e]), p = (i == null ? void 0 : i.data.child.findIndex((T) => a.includes(T))) === 0, g = (i == null ? void 0 : i.data.child.findLastIndex((T) => a.includes(T))) === ((i == null ? void 0 : i.data.child.length) || 0) - 1, v = Ie(() => {
    g || e.bringForward(r, a);
  }, [e, r, g, a]), m = Ie(() => {
    g || e.bringToFront(r, a);
  }, [e, r, g, a]), w = Ie(() => {
    p || e.sendBackward(r, a);
  }, [e, r, p, a]), b = Ie(() => {
    p || e.sendToBack(r, a);
  }, [e, r, p, a]), C = Ie(() => {
    o >= 4 ? e.setScale(5) : o >= 3 ? e.setScale(4) : o >= 2 ? e.setScale(3) : o >= 1.5 ? e.setScale(2) : o >= 1.25 ? e.setScale(1.5) : o >= 1 ? e.setScale(1.25) : o >= 0.75 ? e.setScale(1) : o >= 0.5 ? e.setScale(0.75) : o >= 0.25 ? e.setScale(0.5) : e.setScale(0.25);
  }, [e, o]), M = Ie(() => {
    o <= 0.25 ? e.setScale(0.1) : o <= 0.5 ? e.setScale(0.25) : o <= 0.75 ? e.setScale(0.5) : o <= 1 ? e.setScale(0.75) : o <= 1.25 ? e.setScale(1) : o <= 1.5 ? e.setScale(1.25) : o <= 2 ? e.setScale(1.5) : o <= 3 ? e.setScale(2) : o <= 4 ? e.setScale(3) : e.setScale(4);
  }, [e, o]), k = Ie(() => {
    e.setScale(1);
  }, [e]), D = Ie(
    async (T) => {
      const R = fh(T), _ = Hl(R, T), Z = a.length > 0;
      switch (_) {
        case Bt("Mod-a"):
          e.selectAllLayers(), T.preventDefault();
          break;
        case Bt("Mod-z"):
          e.history.undo(), T.preventDefault();
          break;
        case Bt("Mod-y"):
          e.history.redo(), T.preventDefault();
          break;
        case Bt("Mod-v"):
          await l(), T.preventDefault();
          break;
        case Bt("Mod-c"):
          Z && await u(), T.preventDefault();
          break;
        case Bt("Mod-d"):
          Z && await d(), T.preventDefault();
          break;
        case Bt("Mod-]"):
          Z && v(), T.preventDefault();
          break;
        case Bt("Mod-Alt-]"):
          Z && m(), T.preventDefault();
          break;
        case Bt("Mod-["):
          Z && w(), T.preventDefault();
          break;
        case Bt("Mod-Alt-["):
          Z && b(), T.preventDefault();
          break;
        case Bt("Delete"):
        case Bt("Backspace"):
          Z && h(), T.preventDefault();
          break;
        case Bt("ArrowLeft"):
          e.moveSelectedLayers("left", 1);
          break;
        case Bt("ArrowRight"):
          e.moveSelectedLayers("right", 1);
          break;
        case Bt("ArrowUp"):
          e.moveSelectedLayers("top", 1);
          break;
        case Bt("ArrowDown"):
          e.moveSelectedLayers("bottom", 1);
          break;
        case Bt("Mod-0"):
          k(), T.preventDefault();
          break;
        case Bt("Mod--"):
          M(), T.preventDefault();
          break;
        case Bt("Mod-="):
          C(), T.preventDefault();
          break;
      }
    },
    [
      a.length,
      e,
      l,
      u,
      d,
      v,
      m,
      w,
      b,
      h,
      k,
      M,
      C
    ]
  );
  be(() => {
    const T = (R) => {
      if (R.ctrlKey) {
        const _ = Math.exp(-R.deltaY / 600), Z = Math.min(Math.max(o * _, 0.1), 5);
        e.setScale(Z), R.preventDefault(), R.stopPropagation();
      }
    };
    return n == null || n.addEventListener("wheel", T, {
      passive: !1
    }), () => {
      n == null || n.removeEventListener("wheel", T);
    };
  }, [e, n, o]), be(() => (n == null || n.addEventListener("keydown", D), () => {
    n == null || n.removeEventListener("keydown", D);
  }), [n, D]);
}, mI = (n, e, t) => {
  const r = ge({
    isMoving: !1,
    isZoom: !1,
    touchStart: [
      { clientX: 0, clientY: 0 },
      { clientX: 0, clientY: 0 }
    ],
    lastTouch: [
      { clientX: 0, clientY: 0 },
      { clientX: 0, clientY: 0 }
    ],
    start: { clientX: 0, clientY: 0 },
    last: { clientX: 0, clientY: 0 }
  }), [i, o] = Le({
    scale: 1,
    x: 0,
    y: 0
  }), {
    actions: a,
    scale: l,
    activePage: u,
    pageSize: d,
    isDragging: h,
    isRotating: p,
    isResizing: g,
    openImageEditor: v,
    openTextEditor: m,
    pageLength: w
  } = je((F, Y) => ({
    scale: F.scale,
    activePage: F.activePage,
    pageSize: Y.getPageSize(),
    isDragging: F.dragData.status,
    isRotating: F.rotateData.status,
    isResizing: F.resizeData.status,
    openImageEditor: !!F.imageEditor,
    openTextEditor: !!F.textEditor,
    pageLength: F.pages.length
  })), b = Ie(() => {
    r.current.isZoom = !0, r.current.isMoving = !1;
  }, []), C = Ie(
    (F) => {
      if (n.current && r.current.isZoom && e.current) {
        const ie = window.innerWidth - 32, re = window.innerHeight - 70 - 72 - 16 * 2, { x: oe, y: de } = i, se = d.width * l, we = d.height * l, Oe = (ie - se) / 2, le = (re - we) / 2, Ce = Oe === oe ? 0 : oe - Oe, Ne = le === de ? 0 : de - le;
        e.current[u].style.transform = ut({
          position: {
            x: oe + Ce * (F - 1),
            y: de + Ne * (F - 1)
          },
          scale: F
        });
      }
    },
    [
      u,
      n,
      e,
      d.height,
      d.width,
      i,
      l
    ]
  ), M = Ie(
    (F) => {
      if (n.current && r.current.isZoom && e.current) {
        r.current.isZoom = !1;
        let Y = F;
        const { x: Q, y: ee } = i, ie = 70, re = 72, oe = 16, de = window.innerWidth - oe * 2, se = window.innerHeight - ie - re - oe * 2;
        let we = d.width * l * Y;
        we < de && (Y = de / l / d.width, we = de);
        const Oe = d.width * l, le = d.height * l * Y, Ce = d.height * l, Ne = (de - Oe) / 2, me = (se - Ce) / 2, U = (we - Oe) / 2 - (Ne === Q ? 0 : Q - Ne) * (Y - 1), ae = (le - Ce) / 2 - (me === ee ? 0 : ee - me) * (Y - 1), G = Math.max(
          -(we - de),
          Math.min(Q - U, 0)
        ), xe = Math.max(
          -(le - se / 2),
          Math.min(ee - ae, se / 2)
        );
        Y > F && (e.current[u].style.transform = ut({
          position: { x: G, y: xe },
          scale: 1
        })), o({ scale: 1, x: G, y: xe }), a.setScale(Math.max(l * Y));
      }
    },
    [
      n,
      e,
      i,
      d.width,
      d.height,
      l,
      a,
      u
    ]
  ), k = Ie(
    (F) => {
      const { touches: Y } = F.nativeEvent;
      Y.length === 2 && (r.current.touchStart = [Y[0], Y[1]], r.current.lastTouch = [Y[0], Y[1]], b());
    },
    [b]
  ), D = Ie(
    () => Te.throttle((F) => {
      const { touches: Y } = F.nativeEvent;
      if (Y.length !== 2)
        return;
      const Q = Hs(
        r.current.touchStart[0],
        r.current.touchStart[1]
      ), ie = Hs(Y[0], Y[1]) / Q;
      r.current.lastTouch = [Y[0], Y[1]], C(ie);
    }, 16),
    [C]
  ), T = Ie(
    (F) => {
      const { touches: Y } = F.nativeEvent;
      if (r.current.isZoom) {
        const Q = Hs(
          r.current.touchStart[0],
          r.current.touchStart[1]
        ), ie = Hs(
          r.current.lastTouch[0],
          r.current.lastTouch[1]
        ) / Q;
        r.current.lastTouch = [Y[0], Y[1]], M(ie);
      }
    },
    [M]
  ), R = (F) => {
    const { clientX: Y, clientY: Q } = Wt(F);
    r.current.isMoving = !0, r.current.start = {
      clientX: Y,
      clientY: Q
    }, r.current.last = {
      clientX: Y,
      clientY: Q
    };
  }, _ = (F) => {
    if (!r.current.isMoving)
      return;
    const Y = 70, Q = 72, ee = 16, ie = window.innerWidth - ee * 2, re = window.innerHeight - Y - Q - ee * 2;
    if (r.current.isZoom || !r.current.isMoving || ie >= d.width * l)
      return;
    const { clientX: oe, clientY: de } = Wt(F.nativeEvent);
    r.current.last = {
      clientX: oe,
      clientY: de
    };
    const se = d.width * l, we = d.height * l, Oe = Math.max(
      -(se - ie),
      Math.min(
        i.x + oe - r.current.start.clientX,
        0
      )
    ), le = Math.max(
      -(we - re / 2),
      Math.min(
        i.y + de - r.current.start.clientY,
        re / 2
      )
    );
    e.current && (e.current[u].style.transform = ut({
      position: { x: Oe, y: le },
      scale: i.scale
    }));
  }, Z = () => {
    if (!r.current.isMoving)
      return;
    const F = 70, Y = 72, Q = 16, ee = window.innerWidth - Q * 2, ie = window.innerHeight - F - Y - Q * 2;
    if (r.current.isZoom || !r.current.isMoving || ee >= d.width * l)
      return;
    const { clientX: re, clientY: oe } = r.current.last, de = re - r.current.start.clientX, se = d.width * l, we = d.height * l, Oe = Math.max(
      -(se - ee),
      Math.min(i.x + de, 0)
    ), le = Math.max(
      -(we - ie / 2),
      Math.min(
        i.y + oe - r.current.start.clientY,
        ie / 2
      )
    );
    o({ scale: i.scale, x: Oe, y: le }), r.current.isMoving = !1;
  }, K = (F) => {
    if (!t.current || r.current.isZoom || !r.current.isMoving || p || g || h || v || m)
      return;
    const { clientX: Y, clientY: Q } = Wt(F.nativeEvent);
    r.current.last = {
      clientX: Y,
      clientY: Q
    };
    const ee = 16, ie = Y - r.current.start.clientX;
    window.innerWidth - ee * 2 >= d.width * l && (t.current.style.transform = ut({
      position: { x: -(window.innerWidth * u) + ie, y: 0 }
    }));
  }, $ = () => {
    if (!t.current || r.current.isZoom || !r.current.isMoving || p || g || h || v || m)
      return;
    const { clientX: F } = r.current.last, Y = 16, Q = F - r.current.start.clientX;
    window.innerWidth - Y * 2 >= d.width * l && (Q <= -(window.innerWidth * 0.35) && u + 1 <= w - 1 ? (t.current.style.transform = ut({
      position: { x: -(window.innerWidth * (u + 1)), y: 0 }
    }), a.setActivePage(Math.min(u + 1, w - 1))) : Q >= window.innerWidth * 0.35 && u - 1 >= 0 ? (t.current.style.transform = ut({
      position: { x: -(window.innerWidth * (u - 1)), y: 0 }
    }), a.setActivePage(Math.max(u - 1, 0))) : t.current.style.transform = ut({
      position: { x: -(window.innerWidth * u), y: 0 }
    }));
  };
  return be(() => {
    (() => {
      if (n.current) {
        const Y = d.width / d.height, Q = window.innerWidth <= 900 ? 16 : 56, ee = n.current.clientWidth - Q * 2, ie = {
          width: ee,
          height: ee * Y
        }, re = Math.min(1, ie.width / d.width);
        if (a.setScale(re), Hc) {
          const oe = (window.innerWidth - d.width * re - 32) / 2, de = 70, se = 72, we = 16, Oe = (window.innerHeight - d.height * re - de - se - we) / 2;
          o({ scale: 1, x: oe, y: Oe });
        }
      }
    })();
  }, [a, n, d, o]), be(() => {
    const F = (ee) => {
      ee.preventDefault(), b(), document.addEventListener("gesturechange", Y), document.addEventListener("gestureend", Q, { once: !0 });
    }, Y = Te.throttle((ee) => {
      C(ee.scale), ee.preventDefault();
    }, 16), Q = (ee) => {
      M(ee.scale), ee.preventDefault(), document.removeEventListener("gesturechange", Y), document.removeEventListener("gestureend", Q);
    };
    return document.addEventListener("gesturestart", F), () => {
      document.removeEventListener("gesturestart", F);
    };
  }, [
    l,
    i,
    o,
    a,
    b,
    C,
    M
  ]), {
    pageTransform: i,
    onZoomStart: k,
    onZoomMove: D,
    onZoomEnd: T,
    onMoveStart: R,
    onMove: _,
    onMoveEnd: Z,
    onMovePage: K,
    onMovePageEnd: $
  };
};
var Th = function(e) {
  return /* @__PURE__ */ Pc("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    width: "1em",
    height: "1em"
  }, e, {
    children: [/* @__PURE__ */ q("path", {
      fill: "none",
      d: "M0 0h256v256H0z"
    }), /* @__PURE__ */ q("path", {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 12,
      d: "M168 168h48V40H88v48"
    }), /* @__PURE__ */ q("path", {
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      strokeWidth: 12,
      d: "M40 88h128v128H40z"
    }), /* @__PURE__ */ q("path", {
      fill: "currentColor",
      d: "M138.14 152.43a4.46 4.46 0 0 1-4.45 4.46h-25.26v25.25a4.46 4.46 0 0 1-8.92 0v-25.25H74.26a4.46 4.46 0 0 1 0-8.92h25.25v-25.26a4.46 4.46 0 0 1 8.92 0V148h25.26a4.46 4.46 0 0 1 4.45 4.43Z"
    })]
  }));
}, Vm = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      fill: "currentColor",
      d: "m19.474 12.838 1.697.835a1 1 0 0 1 0 1.795L13.32 19.33a3 3 0 0 1-2.649 0L2.82 15.468a1 1 0 0 1 0-1.795l1.697-.835 1.698.836-1.821.896 6.94 3.415a1.5 1.5 0 0 0 1.324 0l6.94-3.415-1.822-.896 1.7-.836ZM13.32 4.673l7.852 3.864a1 1 0 0 1 0 1.794l-7.852 3.864a3 3 0 0 1-2.649 0L2.82 10.33a1 1 0 0 1 0-1.794l7.851-3.864a3 3 0 0 1 2.65 0Zm-1.986 8.176a1.5 1.5 0 0 0 1.324 0l6.94-3.415-6.94-3.415a1.5 1.5 0 0 0-1.324 0l-6.94 3.415 6.94 3.415Z"
    })
  }));
}, vI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 216a8 8 0 0 1-8 8H40a8 8 0 0 1 0-16h176a8 8 0 0 1 8 8Zm-88-40V80a16 16 0 0 1 16-16h40a16 16 0 0 1 16 16v96a16 16 0 0 1-16 16h-40a16 16 0 0 1-16-16Zm16 0h40V80h-40Zm-104 0V40a16 16 0 0 1 16-16h40a16 16 0 0 1 16 16v136a16 16 0 0 1-16 16H64a16 16 0 0 1-16-16Zm16 0h40V40H64Z"
    })
  }));
}, yI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M208 136h-72v-16h48a16 16 0 0 0 16-16V64a16 16 0 0 0-16-16h-48V32a8 8 0 0 0-16 0v16H72a16 16 0 0 0-16 16v40a16 16 0 0 0 16 16h48v16H48a16 16 0 0 0-16 16v40a16 16 0 0 0 16 16h72v16a8 8 0 0 0 16 0v-16h72a16 16 0 0 0 16-16v-40a16 16 0 0 0-16-16ZM72 64h112v40H72Zm136 128H48v-40h160v40Z"
    })
  }));
}, wI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 120h-16V72a16 16 0 0 0-16-16h-40a16 16 0 0 0-16 16v48h-16V48a16 16 0 0 0-16-16H64a16 16 0 0 0-16 16v72H32a8 8 0 0 0 0 16h16v72a16 16 0 0 0 16 16h40a16 16 0 0 0 16-16v-72h16v48a16 16 0 0 0 16 16h40a16 16 0 0 0 16-16v-48h16a8 8 0 0 0 0-16Zm-120 88H64V48h40Zm88-24h-40V72h40Z"
    })
  }));
}, Wm = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M48 40v176a8 8 0 0 1-16 0V40a8 8 0 0 1 16 0Zm16 64V64a16 16 0 0 1 16-16h96a16 16 0 0 1 16 16v40a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16Zm16 0h96V64H80Zm152 48v40a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16v-40a16 16 0 0 1 16-16h136a16 16 0 0 1 16 16Zm-16 40v-40H80v40h136Z"
    })
  }));
}, bI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 40v176a8 8 0 0 1-16 0V40a8 8 0 0 1 16 0Zm-32 24v40a16 16 0 0 1-16 16H80a16 16 0 0 1-16-16V64a16 16 0 0 1 16-16h96a16 16 0 0 1 16 16Zm-16 0H80v40h96Zm16 88v40a16 16 0 0 1-16 16H40a16 16 0 0 1-16-16v-40a16 16 0 0 1 16-16h136a16 16 0 0 1 16 16Zm-16 0H40v40h136Z"
    })
  }));
}, xI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 40a8 8 0 0 1-8 8H40a8 8 0 0 1 0-16h176a8 8 0 0 1 8 8Zm-16 40v96a16 16 0 0 1-16 16h-40a16 16 0 0 1-16-16V80a16 16 0 0 1 16-16h40a16 16 0 0 1 16 16Zm-16 0h-40v96h40Zm-72 0v136a16 16 0 0 1-16 16H64a16 16 0 0 1-16-16V80a16 16 0 0 1 16-16h40a16 16 0 0 1 16 16Zm-16 0H64v136h40Z"
    })
  }));
}, _w = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M208 96a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16h-32a16 16 0 0 0-16 16v8H96v-8a16 16 0 0 0-16-16H48a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h8v64h-8a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16v-8h64v8a16 16 0 0 0 16 16h32a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16h-8V96Zm-32-48h32v32h-32ZM48 48h32v15.9a.51.51 0 0 0 0 .2V80H48Zm32 160H48v-32h32v15.9a.51.51 0 0 0 0 .2V208Zm128 0h-32v-32h32Zm-24-48h-8a16 16 0 0 0-16 16v8H96v-8a16 16 0 0 0-16-16h-8V96h8a16 16 0 0 0 16-16v-8h64v8a16 16 0 0 0 16 16h8Z"
    })
  }));
}, SI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M201.54 54.46A104 104 0 0 0 54.46 201.54 104 104 0 0 0 201.54 54.46Zm-11.31 135.77a88 88 0 1 1 0-124.46 88.11 88.11 0 0 1 0 124.46ZM165.66 82.34a8 8 0 0 1 0 11.32l-32 32a8 8 0 0 1-11.32 0l-32-32a8 8 0 0 1 11.32-11.32L128 108.69l26.34-26.35a8 8 0 0 1 11.32 0Zm0 56a8 8 0 0 1 0 11.32l-32 32a8 8 0 0 1-11.32 0l-32-32a8 8 0 0 1 11.32-11.32L128 164.69l26.34-26.35a8 8 0 0 1 11.32 0Z"
    })
  }));
}, CI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M201.54 54.46A104 104 0 0 0 54.46 201.54 104 104 0 0 0 201.54 54.46Zm-11.31 135.77a88 88 0 1 1 0-124.46 88.11 88.11 0 0 1 0 124.46Zm-24.57-27.89a8 8 0 0 1-11.32 11.32L128 147.31l-26.34 26.35a8 8 0 0 1-11.32-11.32l32-32a8 8 0 0 1 11.32 0Zm0-56a8 8 0 0 1-11.32 11.32L128 91.31l-26.34 26.35a8 8 0 0 1-11.32-11.32l32-32a8 8 0 0 1 11.32 0Z"
    })
  }));
}, EI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm0 192a88 88 0 1 1 88-88 88.1 88.1 0 0 1-88 88Zm45.66-109.66a8 8 0 0 1 0 11.32l-40 40a8 8 0 0 1-11.32 0l-40-40a8 8 0 0 1 11.32-11.32L128 140.69l34.34-34.35a8 8 0 0 1 11.32 0Z"
    })
  }));
}, kI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M128 24a104 104 0 1 0 104 104A104.11 104.11 0 0 0 128 24Zm0 192a88 88 0 1 1 88-88 88.1 88.1 0 0 1-88 88Zm45.66-77.66a8 8 0 0 1-11.32 11.32L128 115.31l-34.34 34.35a8 8 0 0 1-11.32-11.32l40-40a8 8 0 0 1 11.32 0Z"
    })
  }));
}, OI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M200 32h-36.26a47.92 47.92 0 0 0-71.48 0H56a16 16 0 0 0-16 16v168a16 16 0 0 0 16 16h144a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16Zm-72 0a32 32 0 0 1 32 32H96a32 32 0 0 1 32-32Zm72 184H56V48h26.75A47.93 47.93 0 0 0 80 64v8a8 8 0 0 0 8 8h80a8 8 0 0 0 8-8v-8a47.93 47.93 0 0 0-2.75-16H200Z"
    })
  }));
}, TI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M216 32H88a8 8 0 0 0-8 8v40H40a8 8 0 0 0-8 8v128a8 8 0 0 0 8 8h128a8 8 0 0 0 8-8v-40h40a8 8 0 0 0 8-8V40a8 8 0 0 0-8-8Zm-56 176H48V96h112Zm48-48h-32V88a8 8 0 0 0-8-8H96V48h112Z"
    })
  }));
}, ma = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M128 112a28 28 0 0 0-8 54.83V184a8 8 0 0 0 16 0v-17.17a28 28 0 0 0-8-54.83Zm0 40a12 12 0 1 1 12-12 12 12 0 0 1-12 12Zm80-72h-32V56a48 48 0 0 0-96 0v24H48a16 16 0 0 0-16 16v112a16 16 0 0 0 16 16h160a16 16 0 0 0 16-16V96a16 16 0 0 0-16-16ZM96 56a32 32 0 0 1 64 0v24H96Zm112 152H48V96h160v112Z"
    })
  }));
}, Gl = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M160 80H48a16 16 0 0 0-16 16v112a16 16 0 0 0 16 16h112a16 16 0 0 0 16-16V96a16 16 0 0 0-16-16Zm0 128H48V96h112ZM136 40a8 8 0 0 1 8-8h16a8 8 0 0 1 0 16h-16a8 8 0 0 1-8-8Zm88 8v8a8 8 0 0 1-16 0v-8h-8a8 8 0 0 1 0-16h8a16 16 0 0 1 16 16Zm0 48v16a8 8 0 0 1-16 0V96a8 8 0 0 1 16 0Zm0 56v8a16 16 0 0 1-16 16h-8a8 8 0 0 1 0-16h8v-8a8 8 0 0 1 16 0ZM80 56v-8a16 16 0 0 1 16-16h8a8 8 0 0 1 0 16h-8v8a8 8 0 0 1-16 0Z"
    })
  }));
}, Hm = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M64 216a8 8 0 0 1-8 8h-8a16 16 0 0 1-16-16v-8a8 8 0 0 1 16 0v8h8a8 8 0 0 1 8 8Zm48-8H96a8 8 0 0 0 0 16h16a8 8 0 0 0 0-16Zm-72-40a8 8 0 0 0 8-8v-16a8 8 0 0 0-16 0v16a8 8 0 0 0 8 8Zm128 24a8 8 0 0 0-8 8v8h-8a8 8 0 0 0 0 16h8a16 16 0 0 0 16-16v-8a8 8 0 0 0-8-8Zm0-80a8 8 0 0 0 8-8v-8a16 16 0 0 0-16-16h-8a8 8 0 0 0 0 16h8v8a8 8 0 0 0 8 8ZM56 80h-8a16 16 0 0 0-16 16v8a8 8 0 0 0 16 0v-8h8a8 8 0 0 0 0-16Zm152-48H96a16 16 0 0 0-16 16v40a4.44 4.44 0 0 0 0 .55A8 8 0 0 0 88 96h24a8 8 0 0 0 0-16H96V48h112v112h-32v-16a8 8 0 0 0-16 0v24a8 8 0 0 0 8 8h40a16 16 0 0 0 16-16V48a16 16 0 0 0-16-16Z"
    })
  }));
}, MI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M71.59 61.47a8 8 0 0 0-15.18 0l-40 120A8 8 0 0 0 24 192h80a8 8 0 0 0 7.59-10.53ZM35.1 176 64 89.3 92.9 176ZM208 76a52 52 0 1 0-52 52 52.06 52.06 0 0 0 52-52Zm-88 0a36 36 0 1 1 36 36 36 36 0 0 1-36-36Zm104 68h-88a8 8 0 0 0-8 8v56a8 8 0 0 0 8 8h88a8 8 0 0 0 8-8v-56a8 8 0 0 0-8-8Zm-8 56h-72v-40h72Z"
    })
  }));
}, Mh = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M216 48h-40v-8a24 24 0 0 0-24-24h-48a24 24 0 0 0-24 24v8H40a8 8 0 0 0 0 16h8v144a16 16 0 0 0 16 16h128a16 16 0 0 0 16-16V64h8a8 8 0 0 0 0-16ZM96 40a8 8 0 0 1 8-8h48a8 8 0 0 1 8 8v8H96Zm96 168H64V64h128Zm-80-104v64a8 8 0 0 1-16 0v-64a8 8 0 0 1 16 0Zm48 0v64a8 8 0 0 1-16 0v-64a8 8 0 0 1 16 0Z"
    })
  }));
}, Ro = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M205.66 194.34a8 8 0 0 1-11.32 11.32L128 139.31l-66.34 66.35a8 8 0 0 1-11.32-11.32L116.69 128 50.34 61.66a8 8 0 0 1 11.32-11.32L128 116.69l66.34-66.35a8 8 0 0 1 11.32 11.32L139.31 128Z"
    })
  }));
}, Nw = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "m181.66 133.66-80 80a8 8 0 0 1-11.32-11.32L164.69 128 90.34 53.66a8 8 0 0 1 11.32-11.32l80 80a8 8 0 0 1 0 11.32Z"
    })
  }));
};
const kt = ({
  name: n,
  icon: e,
  shortcut: t,
  disabled: r = !1,
  children: i,
  onClick: o
}) => {
  const [a, l] = Le(!1);
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        padding: "8px 16px 8px 8px",
        display: "flex",
        alignItems: "center",
        position: "relative",
        color: r ? "rgba(36,49,61,.4)" : "rgb(13, 18, 22)",
        cursor: r ? "not-allowed" : "pointer",
        ":hover": {
          background: r ? void 0 : "rgba(64,87,109,.07)"
        }
      },
      onClick: () => !r && o && o(),
      onMouseLeave: () => l(!1),
      onMouseOut: () => l(!1),
      onMouseOver: () => l(!0),
      children: [
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              fontSize: 20
            },
            children: e
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: { marginLeft: 8, fontSize: 14, flexGrow: 1, whiteSpace: "nowrap" },
            children: n
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              width: 48,
              paddingLeft: 8,
              "@media (max-width: 900px)": {
                display: "none"
              }
            }
          }
        ),
        (i || t) && /* @__PURE__ */ W(
          "div",
          {
            css: {
              height: 24,
              lineHeight: "24px",
              fontSize: t ? 12 : 20,
              padding: t ? "0 8px" : 0,
              marginLeft: 8,
              background: t ? "rgba(64,87,109,.07)" : void 0,
              borderRadius: 4,
              whiteSpace: "nowrap",
              "@media (max-width: 900px)": {
                display: "none"
              }
            },
            children: [
              t,
              i && /* @__PURE__ */ x(Nw, {})
            ]
          }
        ),
        a && i
      ]
    }
  );
}, $m = ({
  transform: n,
  children: e
}) => {
  const t = ge(null), [r, i] = Le({
    x: -9999,
    y: -9999
  });
  return be(() => {
    if (t.current && t.current.parentElement) {
      const o = {
        x: 0,
        y: 0
      }, a = t.current.parentElement, l = t.current.getBoundingClientRect();
      n.y + a.offsetTop + l.height > window.innerHeight ? o.y = a.offsetTop - (n.y + a.offsetTop + l.height - window.innerHeight) : o.y = a.offsetTop, n.x + a.offsetWidth + l.width > window.innerWidth ? o.x = -l.width : o.x = a.offsetLeft + a.offsetWidth, i(o);
    }
  }, [n]), /* @__PURE__ */ x(
    "div",
    {
      ref: t,
      css: {
        position: "fixed",
        top: 0,
        left: 0,
        transform: ut({
          position: r
        }),
        paddingLeft: 8,
        paddingRight: 8
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            background: "white",
            paddingTop: 8,
            paddingBottom: 8,
            borderRadius: 4,
            zIndex: 30,
            boxShadow: "0 0 0 1px rgba(64,87,109,.07),0 2px 12px rgba(53,71,90,.2)"
          },
          children: e
        }
      )
    }
  );
}, RI = (n, e) => {
  var we, Oe;
  const { selectedLayerIds: t, selectedLayers: r } = rn(), i = _c(e), [o, a] = Le({
    x: -9999,
    y: -9999
  }), { state: l, openMenu: u, actions: d, pageIndex: h, pageSize: p, rootLayer: g } = je((le, Ce) => ({
    openMenu: le.openMenu,
    pageIndex: le.activePage,
    pageSize: Ce.getPageSize(),
    rootLayer: le.pages[le.activePage] && le.pages[le.activePage].layers.ROOT
  })), v = r.find((le) => le.data.type === "Image"), m = r.find((le) => le.data.type === "Video"), w = async () => {
    await Lw(l, { pageIndex: h, layerIds: t }), d.hideContextMenu();
  }, b = Ie(async () => {
    await Pw({ actions: d }), d.hideContextMenu();
  }, [d]), C = () => {
    Oh(l, { pageIndex: h, layerIds: t, actions: d }), d.hideContextMenu();
  }, M = Ie(() => {
    t.includes("ROOT") || (d.deleteLayer(h, t), d.hideContextMenu());
  }, [d, h, t]), k = () => {
    d.lock(h, t), d.hideContextMenu();
  }, D = () => {
    if (v) {
      const le = p.width / p.height, Ce = v.data.props.image, Ne = Ce.boxSize.width / Ce.boxSize.height, me = { ...Te.cloneDeep(Ce), rotate: 0 };
      le > Ne ? (me.boxSize.width = p.width, me.boxSize.height = p.width / Ne, me.position.y = (me.boxSize.height - p.height) / -2, me.position.x = 0) : (me.boxSize.height = p.height, me.boxSize.width = p.height * Ne, me.position.x = (me.boxSize.width - p.width) / -2, me.position.y = 0), d.setProp(h, "ROOT", {
        image: me,
        video: null
      }), d.history.merge().deleteLayer(h, v.id);
    }
    d.hideContextMenu();
  }, T = () => {
    if (g) {
      const Ce = g.data.props.image;
      if (Ce) {
        const Ne = p.width / p.height, me = Ce.boxSize.width / Ce.boxSize.height, U = { boxSize: { width: 0, height: 0 } };
        Ne < me ? (U.boxSize.width = p.width * 0.8, U.boxSize.height = U.boxSize.width / me) : (U.boxSize.height = p.height * 0.8, U.boxSize.width = U.boxSize.height * me), d.addImageLayer(
          { url: Ce.url, thumb: Ce.thumb },
          U.boxSize
        ), d.history.merge().setProp(h, "ROOT", {
          image: null
        }), d.hideContextMenu();
      }
    }
  }, R = () => {
    if (m) {
      const le = p.width / p.height, Ce = m.data.props.video, Ne = Ce.boxSize.width / Ce.boxSize.height, me = { ...Te.cloneDeep(Ce), rotate: 0 };
      le > Ne ? (me.boxSize.width = p.width, me.boxSize.height = p.width / Ne, me.position.y = (me.boxSize.height - p.height) / -2, me.position.x = 0) : (me.boxSize.height = p.height, me.boxSize.width = p.height * Ne, me.position.x = (me.boxSize.width - p.width) / -2, me.position.y = 0), console.log(me, m), d.setProp(h, "ROOT", {
        video: me,
        image: null
      }), d.history.merge().deleteLayer(h, m.id);
    }
    d.hideContextMenu();
  }, _ = () => {
    if (g) {
      const Ce = g.data.props.video;
      if (Ce) {
        const Ne = p.width / p.height, me = Ce.boxSize.width / Ce.boxSize.height, U = { boxSize: { width: 0, height: 0 } };
        Ne < me ? (U.boxSize.width = p.width * 0.8, U.boxSize.height = U.boxSize.width / me) : (U.boxSize.height = p.height * 0.8, U.boxSize.width = U.boxSize.height * me), d.addVideoLayer({ url: Ce.url }, U.boxSize), d.history.merge().setProp(h, "ROOT", {
          video: null
        }), d.hideContextMenu();
      }
    }
  }, Z = () => {
    if (Vi(r[0])) {
      const Ce = r[0].data.props.image;
      if (Ce) {
        const Ne = p.width / p.height, me = Ce.boxSize.width / Ce.boxSize.height, U = { boxSize: { width: 0, height: 0 } };
        Ne < me ? (U.boxSize.width = p.width * 0.8, U.boxSize.height = U.boxSize.width / me) : (U.boxSize.height = p.height * 0.8, U.boxSize.width = U.boxSize.height * me), d.addImageLayer(
          { url: Ce.url, thumb: Ce.thumb },
          U.boxSize
        ), d.history.merge().setProp(h, r[0].id, {
          image: null
        }), d.hideContextMenu();
      }
    }
  }, K = (g == null ? void 0 : g.data.child.findIndex((le) => t.includes(le))) === 0, $ = (g == null ? void 0 : g.data.child.findLastIndex((le) => t.includes(le))) === ((g == null ? void 0 : g.data.child.length) || 0) - 1, F = () => {
    $ || (d.bringForward(h, t), d.hideContextMenu());
  }, Y = () => {
    $ || (d.bringToFront(h, t), d.hideContextMenu());
  }, Q = () => {
    K || (d.sendBackward(h, t), d.hideContextMenu());
  }, ee = () => {
    K || (d.sendToBack(h, t), d.hideContextMenu());
  }, ie = () => {
    d.setSidebar("LAYER_MANAGEMENT"), d.hideContextMenu();
  }, re = (le) => {
    d.setAlign(le), d.hideContextMenu();
  }, oe = () => {
    t.length === 1 && d.ungroup(t[0]), d.hideContextMenu();
  }, de = () => {
    d.group(t), d.hideContextMenu();
  };
  if (be(() => {
    (() => {
      var U;
      const Ne = (U = i.current) == null ? void 0 : U.getBoundingClientRect(), me = {
        x: -9999,
        y: -9999
      };
      u && (me.x = 0, me.y = 0, Ne.width + u.clientX > window.innerWidth && (me.x = -Ne.width), Ne.height + u.clientY > window.innerHeight && (me.y = window.innerHeight - Ne.height - u.clientY)), a(me);
    })();
    const Ce = () => {
      d.hideContextMenu();
    };
    return window.addEventListener("resize", Ce), () => {
      window.removeEventListener("resize", Ce);
    };
  }, [d, i, u]), !u)
    return null;
  const se = !!r.find((le) => fs(le));
  return /* @__PURE__ */ W(
    "div",
    {
      ref: i,
      css: {
        position: "fixed",
        top: 0,
        left: 0,
        background: "white",
        paddingTop: 8,
        paddingBottom: 8,
        borderRadius: 4,
        zIndex: 30,
        boxShadow: "0 0 0 1px rgba(64,87,109,.07),0 2px 12px rgba(53,71,90,.2)",
        transform: ut({
          position: {
            x: u.clientX + o.x,
            y: u.clientY + o.y
          }
        }),
        "@media (max-width: 900px)": {
          bottom: 0,
          top: "auto",
          transform: "none",
          display: "flex",
          right: 0,
          padding: 0
        }
      },
      children: [
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              display: "none",
              "@media (max-width: 900px)": {
                flexShrink: 0,
                fontSize: 24,
                width: 48,
                height: 48,
                borderRadius: "50%",
                background: "#EBECF0",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                cursor: "pointer",
                margin: 16
              }
            },
            onClick: () => d.hideContextMenu(),
            children: /* @__PURE__ */ x(Ro, {})
          }
        ),
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              "@media (max-width: 900px)": {
                overflowX: "auto",
                flexGrow: 1,
                padding: 16,
                display: "flex"
              }
            },
            children: [
              !t.includes("ROOT") && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(TI, {}),
                  name: "Copy",
                  shortcut: "Ctrl+C",
                  onClick: w
                }
              ),
              !t.includes("ROOT") && /* @__PURE__ */ W(Tt, { children: [
                /* @__PURE__ */ x(
                  kt,
                  {
                    icon: /* @__PURE__ */ x(OI, {}),
                    name: "Paste",
                    shortcut: "Ctrl+V",
                    onClick: b
                  }
                ),
                /* @__PURE__ */ x(
                  kt,
                  {
                    icon: /* @__PURE__ */ x(Th, {}),
                    name: "Duplicate",
                    shortcut: "Ctrl+D",
                    onClick: C
                  }
                ),
                /* @__PURE__ */ x(
                  kt,
                  {
                    icon: /* @__PURE__ */ x(Mh, {}),
                    name: "Delete",
                    shortcut: "Delete",
                    onClick: M
                  }
                )
              ] }),
              !t.includes("ROOT") && /* @__PURE__ */ W(Tt, { children: [
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginTop: 8,
                      marginBottom: 8,
                      height: 1,
                      borderBottom: "1px solid rgba(57,76,96,.15)",
                      width: "100%"
                    }
                  }
                ),
                /* @__PURE__ */ x(kt, { icon: /* @__PURE__ */ x(Vm, {}), name: "Layer", children: /* @__PURE__ */ W(
                  $m,
                  {
                    transform: {
                      x: u.clientX + o.x,
                      y: u.clientY + o.y
                    },
                    children: [
                      /* @__PURE__ */ x(
                        kt,
                        {
                          disabled: $,
                          icon: /* @__PURE__ */ x(kI, {}),
                          name: "Bring Forward",
                          shortcut: "Ctrl+]",
                          onClick: F
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          disabled: $,
                          icon: /* @__PURE__ */ x(CI, {}),
                          name: "Bring to Front",
                          shortcut: "Ctrl+Alt+]",
                          onClick: Y
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          disabled: K,
                          icon: /* @__PURE__ */ x(EI, {}),
                          name: "Send Backward",
                          shortcut: "Ctrl+[",
                          onClick: Q
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          disabled: K,
                          icon: /* @__PURE__ */ x(SI, {}),
                          name: "Send to Back",
                          shortcut: "Ctrl+Alt+[",
                          onClick: ee
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(Vm, {}),
                          name: "Show Layers",
                          onClick: ie
                        }
                      )
                    ]
                  }
                ) }),
                /* @__PURE__ */ x(kt, { icon: /* @__PURE__ */ x(Wm, {}), name: "Align", children: /* @__PURE__ */ W(
                  $m,
                  {
                    transform: {
                      x: u.clientX + o.x,
                      y: u.clientY + o.y
                    },
                    children: [
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(Wm, {}),
                          name: "Left",
                          onClick: () => re("left")
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(yI, {}),
                          name: "Center",
                          onClick: () => re("center")
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(bI, {}),
                          name: "Right",
                          onClick: () => re("right")
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(xI, {}),
                          name: "Top",
                          onClick: () => re("top")
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(wI, {}),
                          name: "Middle",
                          onClick: () => re("middle")
                        }
                      ),
                      /* @__PURE__ */ x(
                        kt,
                        {
                          icon: /* @__PURE__ */ x(vI, {}),
                          name: "Bottom",
                          onClick: () => re("bottom")
                        }
                      )
                    ]
                  }
                ) }),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginTop: 8,
                      marginBottom: 8,
                      height: 1,
                      borderBottom: "1px solid rgba(57,76,96,.15)",
                      width: "100%"
                    }
                  }
                )
              ] }),
              t.length > 1 && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(_w, {}),
                  name: "Group",
                  onClick: de
                }
              ),
              se && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(MI, {}),
                  name: "Ungroup",
                  onClick: oe
                }
              ),
              !t.includes("ROOT") && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(ma, {}),
                  name: "Lock",
                  onClick: k
                }
              ),
              t.length === 1 && Vi(r[0]) && r[0].data.props.image && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(Gl, {}),
                  name: "Detach Image",
                  onClick: Z
                }
              ),
              m && t.length === 1 && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(Hm, {}),
                  name: "Set as Background Video",
                  onClick: R
                }
              ),
              t.length === 1 && t.includes("ROOT") && ((we = g == null ? void 0 : g.data.props) == null ? void 0 : we.video) && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(Gl, {}),
                  name: "Set Background as Video Layer",
                  onClick: _
                }
              ),
              v && t.length === 1 && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(Hm, {}),
                  name: "Set as Background Image",
                  onClick: D
                }
              ),
              t.length === 1 && t.includes("ROOT") && ((Oe = g == null ? void 0 : g.data.props) == null ? void 0 : Oe.image) && /* @__PURE__ */ x(
                kt,
                {
                  icon: /* @__PURE__ */ x(Gl, {}),
                  name: "Set Background as Image Layer",
                  onClick: T
                }
              )
            ]
          }
        )
      ]
    }
  );
}, DI = Yt(RI), II = ({ selectedLayers: n }, e) => /* @__PURE__ */ W(Tt, { children: [
  /* @__PURE__ */ x(
    "div",
    {
      ref: e,
      css: {
        border: "1px solid #3d8eff",
        background: "rgba(61, 142, 255, 0.2)",
        position: "absolute"
      }
    }
  ),
  /* @__PURE__ */ x(
    "div",
    {
      css: {
        position: "absolute",
        inset: 0,
        pointerEvents: "none",
        zIndex: 2
      },
      children: Object.entries(n || {}).map(
        ([t, { boxSize: r, position: i, rotate: o }]) => /* @__PURE__ */ x(
          "div",
          {
            css: {
              position: "absolute",
              border: "1px solid #3d8eff",
              transform: ut({ position: i, rotate: o }),
              width: r.width,
              height: r.height
            }
          },
          t
        )
      )
    }
  )
] }), AI = Yt(II), Jc = () => {
  const { fontFamilyList: n } = je((e) => {
    const t = [];
    return e.pages.forEach((r) => {
      Object.entries(r.layers).forEach(([, i]) => {
        ui(i) && t.push(...i.data.props.fonts);
      });
    }), {
      fontFamilyList: Te.uniqBy(t, "name")
    };
  });
  return { usedFonts: n };
}, LI = ({ boxSize: n, rotate: e, position: t, transparency: r, children: i }, o) => /* @__PURE__ */ x(
  "div",
  {
    ref: o,
    css: {
      touchAction: "pan-x pan-y pinch-zoom",
      pointerEvents: "auto",
      position: "absolute"
    },
    style: {
      width: n.width,
      height: n.height,
      transform: ut({ position: t, rotate: e }),
      opacity: r
    },
    children: i
  }
), PI = Yt(LI), _I = () => {
  const { id: n, comp: e, props: t, layers: r, actions: i, parent: o } = gs((p) => ({
    id: p.id,
    comp: p.data.comp,
    props: { ...p.data.props, layerId: p.id },
    layers: p.data.child,
    parent: p.data.parent
  })), { isResize: a, isDragging: l, isRotate: u } = je((p) => ({
    isResize: p.resizeData.status,
    isDragging: p.dragData.status,
    isRotate: p.rotateData.status
  })), d = Ie(
    (p) => {
      a || !["ROOT", null].includes(o) || l || u || (p.stopPropagation(), i.hover());
    },
    [i, l, a, u, o]
  ), h = Ie(() => {
    i.hover(null);
  }, [i]);
  return pe(() => {
    if (!e)
      return null;
    let p = null;
    if (r && r.length > 0 && (p = /* @__PURE__ */ x(Tt, { children: r.map((v) => /* @__PURE__ */ x(Bw, { id: v }, v)) })), n === "ROOT") {
      const v = Xl(e, t, p);
      return /* @__PURE__ */ x(
        "div",
        {
          onMouseLeave: h,
          onMouseOut: h,
          onMouseOver: d,
          children: v
        }
      );
    }
    const g = Xl(e, t, p);
    return /* @__PURE__ */ x(
      PI,
      {
        boxSize: t.boxSize,
        position: t.position,
        rotate: t.rotate,
        transparency: t.transparency,
        children: /* @__PURE__ */ x(
          "div",
          {
            onMouseLeave: h,
            onMouseOut: h,
            onMouseOver: d,
            children: g
          }
        )
      }
    );
  }, [e, r, n, t, h, d]);
}, zw = yt.memo(_I), Bw = ({ id: n }) => /* @__PURE__ */ x(ev, { id: n, children: /* @__PURE__ */ x(zw, {}) }), Fw = () => /* @__PURE__ */ x(Bw, { id: "ROOT" }), NI = ({ pageIndex: n, width: e, height: t, scale: r, isActive: i }, o) => /* @__PURE__ */ x(tv, { pageIndex: n, children: /* @__PURE__ */ x(
  "div",
  {
    ref: o,
    css: {
      position: "absolute",
      left: 0,
      top: 0,
      width: e * r,
      height: t * r,
      zIndex: 0,
      margin: 0
    },
    style: {
      visibility: i ? "visible" : "hidden",
      opacity: i ? 1 : 0
    },
    children: /* @__PURE__ */ x(
      "div",
      {
        css: {
          width: e,
          height: t,
          transform: `scale(${r})`,
          transformOrigin: "0 0",
          userSelect: "none",
          background: "white",
          overflow: "hidden"
        },
        children: /* @__PURE__ */ x(
          "div",
          {
            css: {
              width: e * r,
              height: t * r,
              position: "relative",
              left: 0,
              top: 0
            },
            children: /* @__PURE__ */ x(Fw, {})
          }
        )
      }
    )
  }
) }), Vw = Yt(NI), zI = ({ onClose: n }) => {
  const { actions: e, pages: t, pageSize: r } = je((l, u) => ({
    pages: l.pages,
    pageSize: u.getPageSize()
  })), o = (window.innerWidth / 2 - 24 * 1.5 - 3 * 2) / r.width, a = (l) => {
    e.setActivePage(l), n();
  };
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        top: 0,
        left: 0,
        width: "100vw",
        height: "100vh",
        position: "fixed",
        background: "#fff",
        zIndex: 2050
      },
      children: [
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flexShrink: 0,
              height: 48,
              borderBottom: "1px solid rgba(57,76,96,.15)",
              padding: "0 20px"
            },
            children: [
              /* @__PURE__ */ x(
                "p",
                {
                  css: {
                    lineHeight: "48px",
                    fontWeight: 600,
                    color: "#181C32",
                    flexGrow: 1
                  },
                  children: "Pages"
                }
              ),
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    fontSize: 20,
                    flexShrink: 0,
                    width: 32,
                    height: 32,
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center"
                  },
                  onClick: () => n(),
                  children: /* @__PURE__ */ x(Ro, {})
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              display: "grid",
              gridTemplateColumns: "repeat(2,minmax(0,1fr))",
              gridGap: 24,
              padding: 24
            },
            children: t.map((l, u) => /* @__PURE__ */ W("div", { css: { position: "relative" }, children: [
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    position: "relative",
                    width: r.width * o + 6,
                    height: r.height * o + 6,
                    border: "3px solid #fff",
                    boxShadow: "0 0 0 1px rgba(64,87,109,.07),0 2px 8px rgba(57,76,96,.15)",
                    borderRadius: 8
                  },
                  children: /* @__PURE__ */ x(
                    Vw,
                    {
                      height: r.height,
                      isActive: !0,
                      pageIndex: u,
                      scale: o,
                      width: r.width
                    }
                  )
                }
              ),
              /* @__PURE__ */ x(
                "p",
                {
                  css: {
                    fontSize: 14,
                    fontWeight: 700,
                    textAlign: "center",
                    lineHeight: 2
                  },
                  children: u + 1
                }
              ),
              /* @__PURE__ */ x(
                "div",
                {
                  css: { position: "absolute", inset: 0 },
                  onClick: () => a(u)
                }
              )
            ] }, u))
          }
        )
      ]
    }
  );
};
var Ww = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "m213.66 101.66-80 80a8 8 0 0 1-11.32 0l-80-80a8 8 0 0 1 11.32-11.32L128 164.69l74.34-74.35a8 8 0 0 1 11.32 11.32Z"
    })
  }));
}, BI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M213.66 165.66a8 8 0 0 1-11.32 0L128 91.31l-74.34 74.35a8 8 0 0 1-11.32-11.32l80-80a8 8 0 0 1 11.32 0l80 80a8 8 0 0 1 0 11.32Z"
    })
  }));
}, FI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M240 136v64a16 16 0 0 1-16 16H32a16 16 0 0 1-16-16v-64a16 16 0 0 1 16-16h40a8 8 0 0 1 0 16H32v64h192v-64h-40a8 8 0 0 1 0-16h40a16 16 0 0 1 16 16Zm-117.66-2.34a8 8 0 0 0 11.32 0l48-48a8 8 0 0 0-11.32-11.32L136 108.69V24a8 8 0 0 0-16 0v84.69L85.66 74.34a8 8 0 0 0-11.32 11.32ZM200 168a12 12 0 1 0-12 12 12 12 0 0 0 12-12Z"
    })
  }));
}, VI = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "m213.66 82.34-56-56A8 8 0 0 0 152 24H56a16 16 0 0 0-16 16v176a16 16 0 0 0 16 16h144a16 16 0 0 0 16-16V88a8 8 0 0 0-2.34-5.66ZM160 51.31 188.69 80H160ZM200 216H56V40h88v48a8 8 0 0 0 8 8h48v120Zm-40-64a8 8 0 0 1-8 8h-16v16a8 8 0 0 1-16 0v-16h-16a8 8 0 0 1 0-16h16v-16a8 8 0 0 1 16 0v16h16a8 8 0 0 1 8 8Z"
    })
  }));
}, Ff = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M208 80H96V56a32 32 0 0 1 32-32c15.37 0 29.2 11 32.16 25.59a8 8 0 0 0 15.68-3.18C171.32 24.15 151.2 8 128 8a48.05 48.05 0 0 0-48 48v24H48a16 16 0 0 0-16 16v112a16 16 0 0 0 16 16h160a16 16 0 0 0 16-16V96a16 16 0 0 0-16-16Zm0 128H48V96h160v112Zm-80-96a28 28 0 0 0-8 54.83V184a8 8 0 0 0 16 0v-17.17a28 28 0 0 0-8-54.83Zm0 40a12 12 0 1 1 12-12 12 12 0 0 1-12 12Z"
    })
  }));
};
function WI(n, e) {
  if (n.match(/^[a-z]+:\/\//i))
    return n;
  if (n.match(/^\/\//))
    return window.location.protocol + n;
  if (n.match(/^[a-z]+:/i))
    return n;
  const t = document.implementation.createHTMLDocument(), r = t.createElement("base"), i = t.createElement("a");
  return t.head.appendChild(r), t.body.appendChild(i), e && (r.href = e), i.href = n, i.href;
}
const HI = (() => {
  let n = 0;
  const e = () => (
    // eslint-disable-next-line no-bitwise
    `0000${(Math.random() * 36 ** 4 << 0).toString(36)}`.slice(-4)
  );
  return () => (n += 1, `u${e()}${n}`);
})();
function li(n) {
  const e = [];
  for (let t = 0, r = n.length; t < r; t++)
    e.push(n[t]);
  return e;
}
function Sc(n, e) {
  const r = (n.ownerDocument.defaultView || window).getComputedStyle(n).getPropertyValue(e);
  return r ? parseFloat(r.replace("px", "")) : 0;
}
function $I(n) {
  const e = Sc(n, "border-left-width"), t = Sc(n, "border-right-width");
  return n.clientWidth + e + t;
}
function UI(n) {
  const e = Sc(n, "border-top-width"), t = Sc(n, "border-bottom-width");
  return n.clientHeight + e + t;
}
function Hw(n, e = {}) {
  const t = e.width || $I(n), r = e.height || UI(n);
  return { width: t, height: r };
}
function ZI() {
  let n, e;
  try {
    e = process;
  } catch {
  }
  const t = e && e.env ? e.env.devicePixelRatio : null;
  return t && (n = parseInt(t, 10), Number.isNaN(n) && (n = 1)), n || window.devicePixelRatio || 1;
}
const qn = 16384;
function jI(n) {
  (n.width > qn || n.height > qn) && (n.width > qn && n.height > qn ? n.width > n.height ? (n.height *= qn / n.width, n.width = qn) : (n.width *= qn / n.height, n.height = qn) : n.width > qn ? (n.height *= qn / n.width, n.width = qn) : (n.width *= qn / n.height, n.height = qn));
}
function Cc(n) {
  return new Promise((e, t) => {
    const r = new Image();
    r.decode = () => e(r), r.onload = () => e(r), r.onerror = t, r.crossOrigin = "anonymous", r.decoding = "async", r.src = n;
  });
}
async function YI(n) {
  return Promise.resolve().then(() => new XMLSerializer().serializeToString(n)).then(encodeURIComponent).then((e) => `data:image/svg+xml;charset=utf-8,${e}`);
}
async function qI(n, e, t) {
  const r = "http://www.w3.org/2000/svg", i = document.createElementNS(r, "svg"), o = document.createElementNS(r, "foreignObject");
  return i.setAttribute("width", `${e}`), i.setAttribute("height", `${t}`), i.setAttribute("viewBox", `0 0 ${e} ${t}`), o.setAttribute("width", "100%"), o.setAttribute("height", "100%"), o.setAttribute("x", "0"), o.setAttribute("y", "0"), o.setAttribute("externalResourcesRequired", "true"), i.appendChild(o), o.appendChild(n), YI(i);
}
const _n = (n, e) => {
  if (n instanceof e)
    return !0;
  const t = Object.getPrototypeOf(n);
  return t === null ? !1 : t.constructor.name === e.name || _n(t, e);
};
function GI(n) {
  const e = n.getPropertyValue("content");
  return `${n.cssText} content: '${e.replace(/'|"/g, "")}';`;
}
function KI(n) {
  return li(n).map((e) => {
    const t = n.getPropertyValue(e), r = n.getPropertyPriority(e);
    return `${e}: ${t}${r ? " !important" : ""};`;
  }).join(" ");
}
function XI(n, e, t) {
  const r = `.${n}:${e}`, i = t.cssText ? GI(t) : KI(t);
  return document.createTextNode(`${r}{${i}}`);
}
function Um(n, e, t) {
  const r = window.getComputedStyle(n, t), i = r.getPropertyValue("content");
  if (i === "" || i === "none")
    return;
  const o = HI();
  try {
    e.className = `${e.className} ${o}`;
  } catch {
    return;
  }
  const a = document.createElement("style");
  a.appendChild(XI(o, t, r)), e.appendChild(a);
}
function JI(n, e) {
  Um(n, e, ":before"), Um(n, e, ":after");
}
const Zm = "application/font-woff", jm = "image/jpeg", QI = {
  woff: Zm,
  woff2: Zm,
  ttf: "application/font-truetype",
  eot: "application/vnd.ms-fontobject",
  png: "image/png",
  jpg: jm,
  jpeg: jm,
  gif: "image/gif",
  tiff: "image/tiff",
  svg: "image/svg+xml",
  webp: "image/webp"
};
function eA(n) {
  const e = /\.([^./]*?)$/g.exec(n);
  return e ? e[1] : "";
}
function Rh(n) {
  const e = eA(n).toLowerCase();
  return QI[e] || "";
}
function tA(n) {
  return n.split(/,/)[1];
}
function Vf(n) {
  return n.search(/^(data:)/) !== -1;
}
function $w(n, e) {
  return `data:${e};base64,${n}`;
}
async function Uw(n, e, t) {
  const r = await fetch(n, e);
  if (r.status === 404)
    throw new Error(`Resource "${r.url}" not found`);
  const i = await r.blob();
  return new Promise((o, a) => {
    const l = new FileReader();
    l.onerror = a, l.onloadend = () => {
      try {
        o(t({ res: r, result: l.result }));
      } catch (u) {
        a(u);
      }
    }, l.readAsDataURL(i);
  });
}
const $d = {};
function nA(n, e, t) {
  let r = n.replace(/\?.*/, "");
  return t && (r = n), /ttf|otf|eot|woff2?/i.test(r) && (r = r.replace(/.*\//, "")), e ? `[${e}]${r}` : r;
}
async function Dh(n, e, t) {
  const r = nA(n, e, t.includeQueryParams);
  if ($d[r] != null)
    return $d[r];
  t.cacheBust && (n += (/\?/.test(n) ? "&" : "?") + (/* @__PURE__ */ new Date()).getTime());
  let i;
  try {
    const o = await Uw(n, t.fetchRequestInit, ({ res: a, result: l }) => (e || (e = a.headers.get("Content-Type") || ""), tA(l)));
    i = $w(o, e);
  } catch (o) {
    i = t.imagePlaceholder || "";
    let a = `Failed to fetch resource: ${n}`;
    o && (a = typeof o == "string" ? o : o.message), a && console.warn(a);
  }
  return $d[r] = i, i;
}
async function rA(n) {
  const e = n.toDataURL();
  return e === "data:," ? n.cloneNode(!1) : Cc(e);
}
async function iA(n, e) {
  if (n.currentSrc) {
    const o = document.createElement("canvas"), a = o.getContext("2d");
    o.width = n.clientWidth, o.height = n.clientHeight, a == null || a.drawImage(n, 0, 0, o.width, o.height);
    const l = o.toDataURL();
    return Cc(l);
  }
  const t = n.poster, r = Rh(t), i = await Dh(t, r, e);
  return Cc(i);
}
async function oA(n) {
  var e;
  try {
    if (!((e = n == null ? void 0 : n.contentDocument) === null || e === void 0) && e.body)
      return await Qc(n.contentDocument.body, {}, !0);
  } catch {
  }
  return n.cloneNode(!1);
}
async function sA(n, e) {
  return _n(n, HTMLCanvasElement) ? rA(n) : _n(n, HTMLVideoElement) ? iA(n, e) : _n(n, HTMLIFrameElement) ? oA(n) : n.cloneNode(!1);
}
const aA = (n) => n.tagName != null && n.tagName.toUpperCase() === "SLOT";
async function lA(n, e, t) {
  var r, i;
  let o = [];
  return aA(n) && n.assignedNodes ? o = li(n.assignedNodes()) : _n(n, HTMLIFrameElement) && (!((r = n.contentDocument) === null || r === void 0) && r.body) ? o = li(n.contentDocument.body.childNodes) : o = li(((i = n.shadowRoot) !== null && i !== void 0 ? i : n).childNodes), o.length === 0 || _n(n, HTMLVideoElement) || await o.reduce((a, l) => a.then(() => Qc(l, t)).then((u) => {
    u && e.appendChild(u);
  }), Promise.resolve()), e;
}
function cA(n, e) {
  const t = e.style;
  if (!t)
    return;
  const r = window.getComputedStyle(n);
  r.cssText ? (t.cssText = r.cssText, t.transformOrigin = r.transformOrigin) : li(r).forEach((i) => {
    let o = r.getPropertyValue(i);
    i === "font-size" && o.endsWith("px") && (o = `${Math.floor(parseFloat(o.substring(0, o.length - 2))) - 0.1}px`), _n(n, HTMLIFrameElement) && i === "display" && o === "inline" && (o = "block"), i === "d" && e.getAttribute("d") && (o = `path(${e.getAttribute("d")})`), t.setProperty(i, o, r.getPropertyPriority(i));
  });
}
function uA(n, e) {
  _n(n, HTMLTextAreaElement) && (e.innerHTML = n.value), _n(n, HTMLInputElement) && e.setAttribute("value", n.value);
}
function dA(n, e) {
  if (_n(n, HTMLSelectElement)) {
    const t = e, r = Array.from(t.children).find((i) => n.value === i.getAttribute("value"));
    r && r.setAttribute("selected", "");
  }
}
function fA(n, e) {
  return _n(e, Element) && (cA(n, e), JI(n, e), uA(n, e), dA(n, e)), e;
}
async function hA(n, e) {
  const t = n.querySelectorAll ? n.querySelectorAll("use") : [];
  if (t.length === 0)
    return n;
  const r = {};
  for (let o = 0; o < t.length; o++) {
    const l = t[o].getAttribute("xlink:href");
    if (l) {
      const u = n.querySelector(l), d = document.querySelector(l);
      !u && d && !r[l] && (r[l] = await Qc(d, e, !0));
    }
  }
  const i = Object.values(r);
  if (i.length) {
    const o = "http://www.w3.org/1999/xhtml", a = document.createElementNS(o, "svg");
    a.setAttribute("xmlns", o), a.style.position = "absolute", a.style.width = "0", a.style.height = "0", a.style.overflow = "hidden", a.style.display = "none";
    const l = document.createElementNS(o, "defs");
    a.appendChild(l);
    for (let u = 0; u < i.length; u++)
      l.appendChild(i[u]);
    n.appendChild(a);
  }
  return n;
}
async function Qc(n, e, t) {
  return !t && e.filter && !e.filter(n) ? null : Promise.resolve(n).then((r) => sA(r, e)).then((r) => lA(n, r, e)).then((r) => fA(n, r)).then((r) => hA(r, e));
}
const Zw = /url\((['"]?)([^'"]+?)\1\)/g, pA = /url\([^)]+\)\s*format\((["']?)([^"']+)\1\)/g, gA = /src:\s*(?:url\([^)]+\)\s*format\([^)]+\)[,;]\s*)+/g;
function mA(n) {
  const e = n.replace(/([.*+?^${}()|\[\]\/\\])/g, "\\$1");
  return new RegExp(`(url\\(['"]?)(${e})(['"]?\\))`, "g");
}
function vA(n) {
  const e = [];
  return n.replace(Zw, (t, r, i) => (e.push(i), t)), e.filter((t) => !Vf(t));
}
async function yA(n, e, t, r, i) {
  try {
    const o = t ? WI(e, t) : e, a = Rh(e);
    let l;
    if (i) {
      const u = await i(o);
      l = $w(u, a);
    } else
      l = await Dh(o, a, r);
    return n.replace(mA(e), `$1${l}$3`);
  } catch {
  }
  return n;
}
function wA(n, { preferredFontFormat: e }) {
  return e ? n.replace(gA, (t) => {
    for (; ; ) {
      const [r, , i] = pA.exec(t) || [];
      if (!i)
        return "";
      if (i === e)
        return `src: ${r};`;
    }
  }) : n;
}
function jw(n) {
  return n.search(Zw) !== -1;
}
async function Yw(n, e, t) {
  if (!jw(n))
    return n;
  const r = wA(n, t);
  return vA(r).reduce((o, a) => o.then((l) => yA(l, a, e, t)), Promise.resolve(r));
}
async function _l(n, e, t) {
  var r;
  const i = (r = e.style) === null || r === void 0 ? void 0 : r.getPropertyValue(n);
  if (i) {
    const o = await Yw(i, null, t);
    return e.style.setProperty(n, o, e.style.getPropertyPriority(n)), !0;
  }
  return !1;
}
async function bA(n, e) {
  await _l("background", n, e) || await _l("background-image", n, e), await _l("mask", n, e) || await _l("mask-image", n, e);
}
async function xA(n, e) {
  const t = _n(n, HTMLImageElement);
  if (!(t && !Vf(n.src)) && !(_n(n, SVGImageElement) && !Vf(n.href.baseVal)))
    return;
  const r = t ? n.src : n.href.baseVal, i = await Dh(r, Rh(r), e);
  await new Promise((o, a) => {
    n.onload = o, n.onerror = a;
    const l = n;
    l.decode && (l.decode = o), l.loading === "lazy" && (l.loading = "eager"), t ? (n.srcset = "", n.src = i) : n.href.baseVal = i;
  });
}
async function SA(n, e) {
  const r = li(n.childNodes).map((i) => qw(i, e));
  await Promise.all(r).then(() => n);
}
async function qw(n, e) {
  _n(n, Element) && (await bA(n, e), await xA(n, e), await SA(n, e));
}
function CA(n, e) {
  const { style: t } = n;
  e.backgroundColor && (t.backgroundColor = e.backgroundColor), e.width && (t.width = `${e.width}px`), e.height && (t.height = `${e.height}px`);
  const r = e.style;
  return r != null && Object.keys(r).forEach((i) => {
    t[i] = r[i];
  }), n;
}
const Ym = {};
async function qm(n) {
  let e = Ym[n];
  if (e != null)
    return e;
  const r = await (await fetch(n)).text();
  return e = { url: n, cssText: r }, Ym[n] = e, e;
}
async function Gm(n, e) {
  let t = n.cssText;
  const r = /url\(["']?([^"')]+)["']?\)/g, o = (t.match(/url\([^)]+\)/g) || []).map(async (a) => {
    let l = a.replace(r, "$1");
    return l.startsWith("https://") || (l = new URL(l, n.url).href), Uw(l, e.fetchRequestInit, ({ result: u }) => (t = t.replace(a, `url(${u})`), [a, u]));
  });
  return Promise.all(o).then(() => t);
}
function Km(n) {
  if (n == null)
    return [];
  const e = [], t = /(\/\*[\s\S]*?\*\/)/gi;
  let r = n.replace(t, "");
  const i = new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})", "gi");
  for (; ; ) {
    const u = i.exec(r);
    if (u === null)
      break;
    e.push(u[0]);
  }
  r = r.replace(i, "");
  const o = /@import[\s\S]*?url\([^)]*\)[\s\S]*?;/gi, a = "((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})", l = new RegExp(a, "gi");
  for (; ; ) {
    let u = o.exec(r);
    if (u === null) {
      if (u = l.exec(r), u === null)
        break;
      o.lastIndex = l.lastIndex;
    } else
      l.lastIndex = o.lastIndex;
    e.push(u[0]);
  }
  return e;
}
async function EA(n, e) {
  const t = [], r = [];
  return n.forEach((i) => {
    if ("cssRules" in i)
      try {
        li(i.cssRules || []).forEach((o, a) => {
          if (o.type === CSSRule.IMPORT_RULE) {
            let l = a + 1;
            const u = o.href, d = qm(u).then((h) => Gm(h, e)).then((h) => Km(h).forEach((p) => {
              try {
                i.insertRule(p, p.startsWith("@import") ? l += 1 : i.cssRules.length);
              } catch (g) {
                console.error("Error inserting rule from remote css", {
                  rule: p,
                  error: g
                });
              }
            })).catch((h) => {
              console.error("Error loading remote css", h.toString());
            });
            r.push(d);
          }
        });
      } catch (o) {
        const a = n.find((l) => l.href == null) || document.styleSheets[0];
        i.href != null && r.push(qm(i.href).then((l) => Gm(l, e)).then((l) => Km(l).forEach((u) => {
          a.insertRule(u, i.cssRules.length);
        })).catch((l) => {
          console.error("Error loading remote stylesheet", l);
        })), console.error("Error inlining remote css file", o);
      }
  }), Promise.all(r).then(() => (n.forEach((i) => {
    if ("cssRules" in i)
      try {
        li(i.cssRules || []).forEach((o) => {
          t.push(o);
        });
      } catch (o) {
        console.error(`Error while reading CSS rules from ${i.href}`, o);
      }
  }), t));
}
function kA(n) {
  return n.filter((e) => e.type === CSSRule.FONT_FACE_RULE).filter((e) => jw(e.style.getPropertyValue("src")));
}
async function OA(n, e) {
  if (n.ownerDocument == null)
    throw new Error("Provided element is not within a Document");
  const t = li(n.ownerDocument.styleSheets), r = await EA(t, e);
  return kA(r);
}
async function TA(n, e) {
  const t = await OA(n, e);
  return (await Promise.all(t.map((i) => {
    const o = i.parentStyleSheet ? i.parentStyleSheet.href : null;
    return Yw(i.cssText, o, e);
  }))).join(`
`);
}
async function MA(n, e) {
  const t = e.fontEmbedCSS != null ? e.fontEmbedCSS : e.skipFonts ? null : await TA(n, e);
  if (t) {
    const r = document.createElement("style"), i = document.createTextNode(t);
    r.appendChild(i), n.firstChild ? n.insertBefore(r, n.firstChild) : n.appendChild(r);
  }
}
async function RA(n, e = {}) {
  const { width: t, height: r } = Hw(n, e), i = await Qc(n, e, !0);
  return await MA(i, e), await qw(i, e), CA(i, e), await qI(i, t, r);
}
async function DA(n, e = {}) {
  const { width: t, height: r } = Hw(n, e), i = await RA(n, e), o = await Cc(i), a = document.createElement("canvas"), l = a.getContext("2d"), u = e.pixelRatio || ZI(), d = e.canvasWidth || t, h = e.canvasHeight || r;
  return a.width = d * u, a.height = h * u, e.skipAutoScale || jI(a), a.style.width = `${d}`, a.style.height = `${h}`, e.backgroundColor && (l.fillStyle = e.backgroundColor, l.fillRect(0, 0, a.width, a.height)), l.drawImage(o, 0, 0, a.width, a.height), a;
}
async function IA(n, e = {}) {
  return (await DA(n, e)).toDataURL();
}
const Nl = ({
  direction: n,
  onResizeStart: e
}) => {
  const t = pe(() => {
    const i = {};
    return n.toLowerCase().includes("top") && (i.top = -16), n.toLowerCase().includes("left") && (i.left = -16), n.toLowerCase().includes("bottom") && (i.bottom = -16), n.toLowerCase().includes("right") && (i.right = -16), i;
  }, [n]), r = Ie(
    (i) => {
      i.stopPropagation(), e(i.nativeEvent, n);
    },
    [e, n]
  );
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        height: 32,
        width: 32,
        position: "absolute",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        pointerEvents: "auto",
        zIndex: 50,
        ...t
      },
      onMouseDown: r,
      onTouchStart: r,
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            borderRadius: "50%",
            cursor: "auto",
            width: 12,
            height: 12,
            background: "white",
            boxShadow: "0 0 4px 1px rgba(57,76,96,.15), 0 0 0 1px rgba(43,59,74,.3)"
          }
        }
      )
    }
  );
}, AA = ({
  getData: n,
  onDragStart: e
}) => {
  const { imageEditor: t, actions: r, scale: i } = je((v) => ({
    imageEditor: v.imageEditor,
    scale: v.scale
  })), o = ge(), a = (t == null ? void 0 : t.image) ?? (t == null ? void 0 : t.video), l = () => {
    window.addEventListener("mousemove", h), window.addEventListener("touchmove", h), window.addEventListener("mouseup", p, { once: !0 }), window.addEventListener("mouseleave", p, { once: !0 }), window.addEventListener("touchend", p, { once: !0 });
  }, u = () => {
    window.removeEventListener("mousemove", h), window.removeEventListener("touchmove", h), window.removeEventListener("mouseup", p), window.removeEventListener("mouseleave", p), window.removeEventListener("touchend", p);
  }, d = ({ clientX: v, clientY: m }) => {
    const w = Hs(
      o.current,
      { clientX: v, clientY: m },
      i
    ), b = f8(
      n(),
      h8(o.current, { clientX: v, clientY: m }),
      w
    );
    return { x: b.width, y: b.height };
  }, h = Te.throttle((v) => {
    if (!t || !a || !o.current)
      return;
    v.stopPropagation();
    const { clientX: m, clientY: w } = Wt(v);
    o.current.moveX = m, o.current.moveY = w;
    const b = d({ clientX: m, clientY: w }), C = hr(
      t.boxSize,
      {
        x: a.position.x + b.x,
        y: a.position.y + b.y
      },
      0
    ), M = Math.min(Math.max(C.x, C.width - a.boxSize.width), 0), k = Math.min(
      Math.max(C.y, C.height - a.boxSize.height),
      0
    );
    t && r.updateImageEditor({
      image: t.image ? {
        position: {
          x: M,
          y: k
        }
      } : void 0,
      video: t.video ? {
        position: {
          x: M,
          y: k
        }
      } : void 0
    });
  }, 16), p = () => {
    if (!t || !a || !o.current)
      return;
    const { moveX: v, moveY: m } = o.current, w = d({ clientX: v, clientY: m }), b = hr(
      t.boxSize,
      {
        x: a.position.x + w.x,
        y: a.position.y + w.y
      },
      0
    ), C = Math.min(Math.max(b.x, b.width - a.boxSize.width), 0), M = Math.min(
      Math.max(b.y, b.height - a.boxSize.height),
      0
    );
    t && r.updateImageEditor({
      image: t.image ? {
        position: {
          x: C,
          y: M
        }
      } : void 0,
      video: t.video ? {
        position: {
          x: C,
          y: M
        }
      } : void 0
    }), u();
  };
  return {
    startDrag: (v) => {
      v.stopPropagation();
      const { clientX: m, clientY: w } = Wt(v.nativeEvent);
      o.current = {
        clientX: m,
        clientY: w,
        moveX: m,
        moveY: w
      }, e && e(), l();
    }
  };
}, LA = ({
  getData: n,
  onResizeStart: e,
  onResize: t,
  onResizeEnd: r,
  lockAspect: i = !1
}) => {
  const { frameScale: o } = je((m) => ({
    frameScale: m.scale
  })), a = ge({
    clientX: 0,
    clientY: 0,
    last: {
      clientX: 0,
      clientY: 0
    },
    direction: "topRight",
    isResizing: !1,
    lockAspect: i
  }), { getResized: l } = p8(n, o), u = (m, w) => l(
    a.current.direction,
    a.current,
    { clientX: m, clientY: w },
    a.current.lockAspect
  ), d = Te.throttle((m) => {
    m.stopPropagation(), a.current.e = m;
    const { clientX: w, clientY: b } = Wt(m);
    a.current.last = {
      clientX: w,
      clientY: b
    };
    const C = u(w, b);
    t(C, a.current.direction, a.current, {
      clientX: w,
      clientY: b
    });
  }, 16), h = (m) => {
    m.stopPropagation();
    const { clientX: w, clientY: b } = a.current.last, C = u(w, b);
    r && r(C), g();
  }, p = () => {
    window.addEventListener("mousemove", d), window.addEventListener("touchmove", d), window.addEventListener("mouseup", h, { once: !0 }), window.addEventListener("mouseleave", h, { once: !0 }), window.addEventListener("touchend", h, { once: !0 });
  }, g = () => {
    window.removeEventListener("mousemove", d), window.removeEventListener("touchmove", d), window.removeEventListener("mouseup", h), window.removeEventListener("mouseleave", h), window.removeEventListener("touchend", h);
  };
  return be(() => {
    const m = (w) => {
      a.current.lockAspect = i || w.shiftKey, a.current.e && a.current.isResizing && d(a.current.e);
    };
    return window.addEventListener("keydown", m), window.addEventListener("keyup", m), () => {
      window.removeEventListener("keydown", m), window.removeEventListener("keyup", m);
    };
  }, [d, i]), {
    startResize: (m, w) => {
      const { clientX: b, clientY: C } = Wt(m);
      a.current = {
        clientX: b,
        clientY: C,
        last: {
          clientX: b,
          clientY: C
        },
        direction: w,
        e: m,
        isResizing: !0,
        lockAspect: i
      }, e(m, w), p();
    }
  };
}, PA = () => {
  const n = ge(null), e = ge(null), [t, r, i] = Pi(), [, o, a] = Pi(), { imageEditor: l, actions: u, scale: d } = je((v) => {
    const m = v.imageEditor;
    return {
      imageEditor: m,
      scale: v.scale,
      originalLayer: v.pages[m.pageIndex].layers[m.layerId]
    };
  }), h = l.image ?? l.video, { startDrag: p } = AA({
    getData: o,
    onDragStart: () => {
      l && a(l.rotate);
    }
  });
  be(() => {
    const v = (m) => {
      const w = e == null ? void 0 : e.current, b = n == null ? void 0 : n.current;
      !w || w.contains(m.target) || l.layerId !== "ROOT" && (b != null && b.contains(m.target)) || u.closeImageEditor();
    };
    return window.addEventListener("mousedown", v, { capture: !0 }), () => {
      window.removeEventListener("mousedown", v, { capture: !0 });
    };
  }, [u, l.layerId]);
  const { startResize: g } = LA({
    lockAspect: !0,
    getData: r,
    onResizeStart: () => {
      h && i({
        boxSize: h.boxSize,
        position: h.position,
        rotate: h.rotate
      });
    },
    onResize: ({ boxSize: v, position: m, rotate: w }, b) => {
      var C, M;
      if (l && t.current && h) {
        let k = Math.min(m.x, 0), D = Math.min(m.y, 0), T = v.width, R = v.height;
        const _ = t.current.boxSize.width / t.current.boxSize.height, Z = t.current.position.x * -1 - t.current.position.y * -1 * _, K = t.current.position.y * -1 - t.current.position.x * -1 / _, $ = t.current.position.x / t.current.position.y;
        if (["topLeft"].includes(b)) {
          const F = l.boxSize.width / l.boxSize.height, Y = m.y - D, Q = m.x - k;
          (Y > 0 || Q > 0) && ($ > F ? (k = -Z, T += m.x - k, R += +m.y) : (D = -K, T += m.x, R += +m.y - D));
        } else if (b === "bottomRight" && (v.width < l.boxSize.width - h.position.x || v.height < l.boxSize.height - h.position.y)) {
          const F = Math.max(
            v.width,
            l.boxSize.width - h.position.x
          ), Y = Math.max(
            v.height,
            l.boxSize.height - h.position.y
          );
          F / Y > _ ? (T = l.boxSize.width - h.position.x, R = T / _) : F / Y < _ && (R = l.boxSize.height - h.position.y, T = R * _);
        } else if (b === "topRight" && (m.y > 0 || v.width < l.boxSize.width - t.current.position.x)) {
          const F = l.boxSize.width - t.current.position.x, Y = ((C = t.current) == null ? void 0 : C.boxSize.width) - F;
          Y / t.current.position.y * -1 > _ ? (R = Math.max(
            t.current.boxSize.height + t.current.position.y,
            v.height
          ), T = R * _) : (T = Math.max(
            l.boxSize.width - t.current.position.x,
            v.width
          ), R = T / _, D = t.current.position.y + Y / _);
        } else if (b === "bottomLeft" && (m.x > 0 || v.height < l.boxSize.height - t.current.position.y)) {
          const F = l.boxSize.height - t.current.position.y, Y = ((M = t.current) == null ? void 0 : M.boxSize.height) - F;
          (Y / t.current.position.x * -1 || 0) > _ ? (T = Math.max(
            t.current.boxSize.width + t.current.position.x,
            v.width
          ), R = T / _) : (R = Math.max(
            l.boxSize.height - t.current.position.y,
            v.height
          ), T = R * _, k = t.current.position.x + Y * _);
        }
        u.updateImageEditor({
          image: l.image ? {
            boxSize: {
              width: T,
              height: R
            },
            position: {
              x: k,
              y: D
            },
            rotate: w
          } : void 0,
          video: l.video ? {
            boxSize: {
              width: T,
              height: R
            },
            position: {
              x: k,
              y: D
            },
            rotate: w
          } : void 0
        });
      }
    }
  });
  return h ? /* @__PURE__ */ x(
    "div",
    {
      css: { position: "absolute", inset: 0, pointerEvents: "none", zIndex: 4 },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            width: l.boxSize.width * d,
            height: l.boxSize.height * d,
            left: 0,
            top: 0,
            position: "absolute",
            transform: ut({
              position: {
                x: l.position.x * d,
                y: l.position.y * d
              },
              rotate: l.rotate
            })
          },
          children: /* @__PURE__ */ W(
            "div",
            {
              ref: e,
              css: {
                width: h.boxSize.width * d,
                height: h.boxSize.height * d,
                left: 0,
                top: 0,
                position: "absolute",
                outline: "2px solid rgba(61, 142, 255,.5)",
                boxShadow: "0 0 0 1px hsla(0,0%,100%,.07), inset 0 0 0 1px hsla(0,0%,100%,.07)",
                transform: ut({
                  position: {
                    x: h.position.x * d,
                    y: h.position.y * d
                  },
                  rotate: h.rotate
                })
              },
              onMouseDown: p,
              onTouchStart: p,
              children: [
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      position: "absolute",
                      inset: -12,
                      pointerEvents: "auto",
                      cursor: "move"
                    }
                  }
                ),
                /* @__PURE__ */ x(
                  Nl,
                  {
                    direction: "topLeft",
                    onResizeStart: g
                  }
                ),
                /* @__PURE__ */ x(
                  Nl,
                  {
                    direction: "topRight",
                    onResizeStart: g
                  }
                ),
                /* @__PURE__ */ x(
                  Nl,
                  {
                    direction: "bottomRight",
                    onResizeStart: g
                  }
                ),
                /* @__PURE__ */ x(
                  Nl,
                  {
                    direction: "bottomLeft",
                    onResizeStart: g
                  }
                )
              ]
            }
          )
        }
      )
    }
  ) : null;
}, _A = () => {
  const n = ge(null), { imageEditor: e, originalLayer: t, scale: r } = je((a) => {
    const l = a.imageEditor;
    return {
      imageEditor: l,
      scale: a.scale,
      originalLayer: l ? a.pages[l.pageIndex].layers[l.layerId] : null
    };
  }), i = (e == null ? void 0 : e.image) ?? (e == null ? void 0 : e.video);
  if (!e || !t || !i)
    return null;
  const o = R1(e, i);
  return /* @__PURE__ */ W("div", { css: { position: "absolute", inset: 0, pointerEvents: "none" }, children: [
    /* @__PURE__ */ x(
      "div",
      {
        css: {
          width: i.boxSize.width * r,
          height: i.boxSize.height * r,
          left: 0,
          top: 0,
          position: "absolute",
          transform: ut({
            position: {
              x: o.x * r,
              y: o.y * r
            },
            rotate: o.rotate
          }),
          opacity: 0.5
        },
        children: /* @__PURE__ */ W("div", { css: { width: "100%", height: "100%" }, children: [
          e.image && /* @__PURE__ */ x(
            "img",
            {
              alt: i.url,
              crossOrigin: "anonymous",
              css: {
                display: "block",
                height: "100%",
                width: "100%",
                position: "absolute",
                pointerEvents: "none",
                objectFit: "fill"
              },
              src: i.url
            }
          ),
          e.video && /* @__PURE__ */ x(
            "video",
            {
              crossOrigin: "anonymous",
              css: { objectFit: "fill", width: "100%", height: "100%" },
              src: i.url
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ x(
      "div",
      {
        ref: n,
        css: {
          position: "absolute",
          top: 0,
          left: 0,
          width: e.boxSize.width * r,
          height: e.boxSize.height * r,
          transform: ut({
            position: {
              x: e.position.x * r,
              y: e.position.y * r
            },
            rotate: e.rotate
          }),
          overflow: "hidden",
          clipPath: Vi(t) ? `path("${g8(
            t.data.props.clipPath,
            t.data.props.scale * r
          )}")` : void 0
        },
        children: /* @__PURE__ */ x(
          "div",
          {
            css: {
              width: i.boxSize.width * r,
              height: i.boxSize.height * r,
              transform: ut({
                position: {
                  x: i.position.x * r,
                  y: i.position.y * r
                },
                rotate: i.rotate
              }),
              opacity: 1,
              position: "absolute",
              left: 0,
              top: 0
            },
            children: /* @__PURE__ */ W("div", { css: { width: "100%", height: "100%" }, children: [
              e.image && /* @__PURE__ */ x(
                "img",
                {
                  alt: i.url,
                  crossOrigin: "anonymous",
                  css: {
                    display: "block",
                    height: "100%",
                    width: "100%",
                    position: "absolute",
                    pointerEvents: "none",
                    objectFit: "fill"
                  },
                  src: i.url
                }
              ),
              e.video && /* @__PURE__ */ x(
                "video",
                {
                  crossOrigin: "anonymous",
                  css: { objectFit: "fill", width: "100%", height: "100%" },
                  src: i.url
                }
              )
            ] })
          }
        )
      }
    ),
    /* @__PURE__ */ x(PA, {})
  ] });
}, NA = ({ editor: n }) => {
  const e = ge(null), { actions: t } = je(), r = m8(() => {
    t.history.new();
    const i = Mw({
      content: n.dom.innerHTML,
      ele: e.current,
      handleDOMEvents: {
        blur: () => {
          Hc && t.closeTextEditor();
        }
      }
    });
    un({
      from: i.state.doc.content.size,
      to: i.state.doc.content.size
    })(i.state, i.dispatch), i.focus(), t.setOpeningEditor(i);
  });
  return be(() => {
    r();
  }, [r]), /* @__PURE__ */ x("div", { ref: e });
}, zA = yt.memo(NA), BA = () => {
  const { editorScale: n, layer: e } = je((p) => {
    const g = p.textEditor, v = p.pages[g.pageIndex].layers[g.layerId];
    return {
      editorScale: p.scale,
      textEditor: g,
      layer: v
    };
  });
  if (!e)
    return null;
  const t = e.data.editor, {
    boxSize: r,
    position: i,
    scale: o,
    rotate: a,
    transparency: l,
    effect: u,
    colors: d,
    fontSizes: h
  } = e.data.props;
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        touchAction: "pan-x pan-y pinch-zoom",
        pointerEvents: "auto",
        position: "absolute",
        width: r.width * n,
        height: r.height * n,
        transform: ut({
          position: {
            x: i.x * n,
            y: i.y * n
          },
          rotate: a
        }),
        opacity: l,
        top: 0,
        left: 0
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            width: r.width / o,
            height: r.height / o,
            transform: `scale(${o * n})`,
            transformOrigin: "0 0",
            p: {
              "&:before": {
                ...m0(
                  (u == null ? void 0 : u.name) || "none",
                  u == null ? void 0 : u.settings,
                  d[0],
                  h[0]
                )
              }
            },
            ...m0(
              (u == null ? void 0 : u.name) || "none",
              u == null ? void 0 : u.settings,
              d[0],
              h[0]
            )
          },
          onMouseDown: (p) => p.stopPropagation(),
          children: t && /* @__PURE__ */ x(zA, { editor: t })
        }
      )
    }
  );
}, Pr = 16, zl = ({
  isActive: n,
  top: e,
  left: t,
  bottom: r,
  right: i,
  direction: o,
  rotate: a,
  onResizeStart: l
}) => {
  const {
    config: { assetPath: u }
  } = It(di), h = Math.round((a + {
    bottomLeft: 45,
    topLeft: 135,
    topRight: 225,
    bottomRight: 315
  }[o] + 90) % 180 / 10), p = (g) => {
    l(g.nativeEvent, o);
  };
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        top: e,
        left: t,
        bottom: r,
        right: i,
        position: "absolute",
        width: 32,
        height: 32,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            width: Pr,
            height: Pr,
            pointerEvents: "auto",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            ":hover": {
              cursor: `url('${u}/cursors/resize/${h}.png') 12 12, auto`
            }
          },
          onMouseDown: (g) => {
            g.stopPropagation(), p(g);
          },
          onTouchStart: (g) => {
            g.stopPropagation(), p(g);
          },
          children: /* @__PURE__ */ x(
            "div",
            {
              css: {
                background: n ? "#3d8eff" : "white",
                width: 12,
                height: 12,
                position: "absolute",
                borderRadius: "50%",
                boxShadow: "0 0 4px 1px rgba(57,76,96,.15), 0 0 0 1px rgba(43,59,74,.3)",
                pointerEvents: "none",
                ":hover": {
                  background: "#3d8eff"
                }
              }
            }
          )
        }
      )
    }
  );
}, _r = 16, Bl = ({
  isActive: n,
  boxSize: e,
  width: t,
  height: r,
  top: i,
  left: o,
  right: a,
  bottom: l,
  direction: u,
  rotate: d,
  onResizeStart: h
}) => {
  const {
    config: { assetPath: p }
  } = It(di), v = Math.round((d + {
    left: 90,
    top: 180,
    right: 270,
    bottom: 0
  }[u] + 90) % 180 / 10), m = (w) => {
    h(w.nativeEvent, u);
  };
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        width: t,
        height: r,
        top: i,
        left: o,
        right: a,
        bottom: l,
        position: "absolute",
        display: "flex",
        alignItems: "center",
        justifyContent: "center",
        pointerEvents: "auto",
        clipPath: ["top", "bottom"].includes(u) ? `inset(0 ${_r / 2}px)` : `inset(${_r / 2}px 0)`,
        ":hover": {
          cursor: `url('${p}/cursors/resize/${v}.png') 12 12, auto`
        }
      },
      onMouseDown: (w) => {
        w.stopPropagation(), m(w);
      },
      onTouchStart: (w) => {
        w.stopPropagation(), m(w);
      },
      children: (e.width > 50 && ["top", "bottom"].includes(u) || e.height > 50 && ["left", "right"].includes(u)) && /* @__PURE__ */ x(
        "div",
        {
          css: {
            background: n ? "#3d8eff" : "white",
            width: ["top", "bottom"].includes(u) ? 18 : 6,
            height: ["top", "bottom"].includes(u) ? 6 : 18,
            borderRadius: 3,
            position: "absolute",
            boxShadow: "0 0 4px 1px rgba(57,76,96,.15), 0 0 0 1px rgba(43,59,74,.3)",
            ":hover": {
              background: "#3d8eff",
              boxShadow: "0 0 0 1px rgba(57,76,96,.15)"
            }
          }
        }
      )
    }
  );
};
var FA = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M197.67 186.37a8 8 0 0 1 0 11.29C196.58 198.73 170.82 224 128 224c-37.39 0-64.53-22.4-80-39.85V208a8 8 0 0 1-16 0v-48a8 8 0 0 1 8-8h48a8 8 0 0 1 0 16H55.44C67.76 183.35 93 208 128 208c36 0 58.14-21.46 58.36-21.68a8 8 0 0 1 11.31.05ZM216 40a8 8 0 0 0-8 8v23.85C192.53 54.4 165.39 32 128 32c-42.82 0-68.58 25.27-69.66 26.34a8 8 0 0 0 11.3 11.34C69.86 69.46 92 48 128 48c35 0 60.24 24.65 72.56 40H168a8 8 0 0 0 0 16h48a8 8 0 0 0 8-8V48a8 8 0 0 0-8-8Z"
    })
  }));
};
const Gw = ({ rotate: n, onRotateStart: e }) => {
  const { isRotating: t } = je((a) => ({
    isRotating: a.rotateData.status
  })), {
    config: { assetPath: r }
  } = It(di), i = Ie(
    (a) => {
      a.stopPropagation(), e(a.nativeEvent);
    },
    [e]
  ), o = Math.round(n / 10);
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        bottom: n < 230 && n > 130 ? "50%" : -48,
        position: "absolute",
        left: n < 230 && n > 130 ? "calc(100% + 48px)" : "50%",
        transform: n < 230 && n > 130 ? "translateY(50%)" : "translateX(-50%)",
        pointerEvents: "auto",
        display: t ? "none" : "block"
      },
      children: [
        /* @__PURE__ */ x("div", { children: /* @__PURE__ */ x(
          "div",
          {
            css: {
              background: "white",
              boxShadow: "0 0 4px 1px rgba(57,76,96,.15), 0 0 0 1px rgba(43,59,74,.3)",
              width: 24,
              height: 24,
              borderRadius: "50%",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              padding: 4,
              color: "#0d1216",
              ":hover": {
                cursor: `url('${r}/cursors/rotate/${o === 36 ? 0 : o}.png') 12 12, auto;`
              }
            },
            onMouseDown: i,
            onTouchStart: i,
            children: /* @__PURE__ */ x(FA, {})
          }
        ) }),
        t && /* @__PURE__ */ W(
          "div",
          {
            css: {
              position: "absolute",
              left: 60,
              top: 36,
              whiteSpace: "nowrap",
              background: "#1E1E2D",
              padding: "3px 8px",
              borderRadius: 4,
              textAlign: "center",
              color: "white",
              fontSize: 12,
              fontWeight: 700
            },
            children: [
              Math.round(n),
              "°"
            ]
          }
        )
      ]
    }
  );
}, VA = ({ boxSize: n, position: e, rotate: t, disabled: r, locked: i, onResizeStart: o, onRouteStart: a }, l) => {
  const u = _c(l), { pageIndex: d } = It(Mo), {
    imageEditor: h,
    isRotating: p,
    isDragging: g,
    frameScale: v,
    selectState: m,
    isGroup: w,
    resizeDirection: b,
    isPageLocked: C
  } = je((k) => ({
    isGroup: k.selectedLayers[d].length > 1,
    imageEditor: k.imageEditor,
    isDragging: k.dragData.status,
    isRotating: k.rotateData.status,
    resizeDirection: k.resizeData.direction,
    frameScale: k.scale,
    selectState: k.selectData.status,
    isPageLocked: k.pages[d].layers.ROOT.data.locked
  })), M = (k, D) => {
    o && o(k, D);
  };
  return h ? null : /* @__PURE__ */ x(
    "div",
    {
      ref: u,
      css: {
        position: "absolute"
      },
      style: {
        transform: ut({
          position: { x: e.x * v, y: e.y * v },
          rotate: t
        }),
        width: n.width * v,
        height: n.height * v
      },
      children: !g && !i && !m && !C && /* @__PURE__ */ W(Tt, { children: [
        !r.corners && !p && /* @__PURE__ */ W(Tt, { children: [
          (!b || b === "topLeft") && /* @__PURE__ */ x(
            zl,
            {
              direction: "topLeft",
              isActive: b === "topLeft",
              left: -Pr,
              rotate: t,
              top: -Pr,
              onResizeStart: M
            }
          ),
          (!b || b === "topRight") && /* @__PURE__ */ x(
            zl,
            {
              direction: "topRight",
              isActive: b === "topRight",
              right: -Pr,
              rotate: t,
              top: -Pr,
              onResizeStart: M
            }
          ),
          (!b || b === "bottomLeft") && /* @__PURE__ */ x(
            zl,
            {
              bottom: -Pr,
              direction: "bottomLeft",
              isActive: b === "bottomLeft",
              left: -Pr,
              rotate: t,
              onResizeStart: M
            }
          ),
          (!b || b === "bottomRight") && /* @__PURE__ */ x(
            zl,
            {
              bottom: -Pr,
              direction: "bottomRight",
              isActive: b === "bottomRight",
              right: -Pr,
              rotate: t,
              onResizeStart: M
            }
          )
        ] }),
        !w && !p && /* @__PURE__ */ W(Tt, { children: [
          !r.vertical && /* @__PURE__ */ W(Tt, { children: [
            (!b || b === "top") && /* @__PURE__ */ x(
              Bl,
              {
                boxSize: n,
                direction: "top",
                height: _r,
                isActive: b === "top",
                rotate: t,
                top: -(_r / 2),
                width: "100%",
                onResizeStart: M
              }
            ),
            (!b || b === "bottom") && /* @__PURE__ */ x(
              Bl,
              {
                bottom: -(_r / 2),
                boxSize: n,
                direction: "bottom",
                height: _r,
                isActive: b === "bottom",
                rotate: t,
                width: "100%",
                onResizeStart: M
              }
            )
          ] }),
          !r.horizontal && !p && /* @__PURE__ */ W(Tt, { children: [
            (!b || b === "left") && /* @__PURE__ */ x(
              Bl,
              {
                boxSize: n,
                direction: "left",
                height: "100%",
                isActive: b === "left",
                left: -(_r / 2),
                rotate: t,
                width: _r,
                onResizeStart: M
              }
            ),
            (!b || b === "right") && /* @__PURE__ */ x(
              Bl,
              {
                boxSize: n,
                direction: "right",
                height: "100%",
                isActive: b === "right",
                right: -(_r / 2),
                rotate: t,
                width: _r,
                onResizeStart: M
              }
            )
          ] })
        ] }),
        !i && !r.rotate && !b && /* @__PURE__ */ x(Gw, { rotate: t, onRotateStart: a })
      ] })
    }
  );
}, WA = Yt(
  VA
), HA = () => {
  const { guideline: n, frameScale: e } = je((t) => ({
    guideline: t.guideline,
    frameScale: t.scale
  }));
  return !n.vertical.length && !n.horizontal.length ? null : /* @__PURE__ */ W("div", { children: [
    n.horizontal.map((t, r) => /* @__PURE__ */ x(
      "div",
      {
        css: {
          position: "absolute",
          top: t.y * e,
          left: t.x1 * e,
          width: (t.x2 - t.x1) * e,
          borderTopWidth: 1,
          borderStyle: "dashed",
          borderColor: "#3d8eff"
        }
      },
      r
    )),
    n.vertical.map((t, r) => /* @__PURE__ */ x(
      "div",
      {
        css: {
          position: "absolute",
          top: t.y1 * e,
          left: t.x * e,
          height: (t.y2 - t.y1) * e,
          borderLeftWidth: 1,
          borderStyle: "dashed",
          borderColor: "#3d8eff"
        }
      },
      r
    ))
  ] });
}, Xm = 16, Jm = ({
  isActive: n = !1,
  position: e,
  onChange: t
}) => {
  const r = (i) => {
    t(i.nativeEvent, e);
  };
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        position: "absolute",
        width: 32,
        height: 32,
        display: "flex",
        justifyContent: "center",
        alignItems: "center"
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            width: Xm,
            height: Xm,
            pointerEvents: "auto",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          },
          onMouseDown: (i) => {
            console.log("start"), i.stopPropagation(), r(i);
          },
          onTouchStart: (i) => {
            i.stopPropagation(), r(i);
          },
          children: /* @__PURE__ */ x(
            "div",
            {
              css: {
                background: n ? "#3d8eff" : "white",
                width: 12,
                height: 12,
                position: "absolute",
                borderRadius: "50%",
                boxShadow: "0 0 4px 1px rgba(57,76,96,.15), 0 0 0 1px rgba(43,59,74,.3)",
                pointerEvents: "none",
                ":hover": {
                  background: "#3d8eff"
                }
              }
            }
          )
        }
      )
    }
  );
}, $A = ({ boxSize: n, disabled: e, position: t, rotate: r, locked: i, onChangeStart: o, onRouteStart: a }, l) => {
  const u = _c(l), { pageIndex: d } = It(Mo), {
    imageEditor: h,
    isRotating: p,
    isDragging: g,
    frameScale: v,
    selectState: m,
    resizeDirection: w,
    isPageLocked: b,
    updateLineData: C
  } = je((k) => ({
    isGroup: k.selectedLayers[d].length > 1,
    imageEditor: k.imageEditor,
    isDragging: k.dragData.status,
    isRotating: k.rotateData.status,
    resizeDirection: k.resizeData.direction,
    frameScale: k.scale,
    selectState: k.selectData.status,
    isPageLocked: k.pages[d].layers.ROOT.data.locked,
    updateLineData: k.updateLineData
  })), M = (k, D) => {
    o && o(k, D);
  };
  return h ? null : /* @__PURE__ */ x(
    "div",
    {
      ref: u,
      css: {
        position: "absolute"
      },
      style: {
        transform: ut({
          position: { x: t.x * v, y: t.y * v },
          rotate: r
        }),
        width: n.width * v,
        height: n.height * v
      },
      children: !g && !i && !m && !b && !p && /* @__PURE__ */ W(Tt, { children: [
        !i && /* @__PURE__ */ W(Tt, { children: [
          (!C.status || C.linePosition === "start") && /* @__PURE__ */ x(
            "div",
            {
              css: {
                left: 0,
                top: "50%",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                position: "absolute"
              },
              children: /* @__PURE__ */ x(
                Jm,
                {
                  isActive: C.linePosition === "start",
                  position: "start",
                  onChange: M
                }
              )
            }
          ),
          (!C.status || C.linePosition === "end") && /* @__PURE__ */ x(
            "div",
            {
              css: {
                left: "100%",
                top: "50%",
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                position: "absolute"
              },
              children: /* @__PURE__ */ x(
                Jm,
                {
                  isActive: C.linePosition === "end",
                  position: "end",
                  onChange: M
                }
              )
            }
          )
        ] }),
        !i && !e.rotate && !w && !C.status && /* @__PURE__ */ x(Gw, { rotate: r, onRotateStart: a })
      ] })
    }
  );
}, UA = Yt(
  $A
);
var Kw = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M144 128a16 16 0 1 1-16-16 16 16 0 0 1 16 16Zm-84-16a16 16 0 1 0 16 16 16 16 0 0 0-16-16Zm136 0a16 16 0 1 0 16 16 16 16 0 0 0-16-16Z"
    })
  }));
};
const ZA = () => {
  const { pageIndex: n } = It(Mo), e = ge(null), { selectedLayerIds: t, selectedLayers: r } = rn(), {
    actions: i,
    state: o,
    isDragging: a,
    isResizing: l,
    isRotating: u,
    controlBox: d,
    pageSize: h,
    isOpenMenu: p,
    scale: g,
    isPageLocked: v,
    isUpdatingLine: m
  } = je((R, _) => ({
    isGroup: R.selectedLayers[R.activePage].length > 1,
    isDragging: R.dragData.status,
    isResizing: R.resizeData.status,
    isRotating: R.rotateData.status,
    isUpdatingLine: R.updateLineData.status,
    controlBox: R.controlBox,
    pageSize: _.getPageSize(),
    isPageLocked: R.pages[R.activePage].layers.ROOT.data.locked,
    isOpenMenu: !!R.openMenu,
    scale: R.scale
  })), w = r.find((R) => R.data.locked), b = pe(() => d ? hr(
    d.boxSize,
    d.position,
    d.rotate
  ) : {
    x: 0,
    y: 80,
    width: h.width,
    height: h.height
  }, [d, h.height, h.width]), C = () => {
    Oh(o, { pageIndex: n, layerIds: t, actions: i });
  }, M = () => {
    var R;
    if (p)
      i.hideContextMenu();
    else {
      const _ = (R = e.current) == null ? void 0 : R.getBoundingClientRect();
      i.showContextMenu({
        clientX: _.right - 42,
        clientY: _.bottom + 4
      });
    }
  }, k = () => {
    t.length === 1 && i.ungroup(t[0]);
  }, D = () => {
    i.group(t);
  };
  if (a || l || u || m || t.includes("ROOT") && !w && !v || !d)
    return null;
  const T = !!r.find((R) => fs(R));
  return /* @__PURE__ */ x(
    "div",
    {
      ref: e,
      css: {
        position: "absolute",
        left: (b.x + b.width / 2) * g,
        top: b.y * g - 60,
        transform: "translateX(-50%)"
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            height: 40,
            borderRadius: 4,
            padding: "0 4px",
            display: "inline-flex",
            alignItems: "center",
            background: "#fff",
            boxShadow: "0 0 0 1px rgba(64,87,109,.07),0 2px 12px rgba(53,71,90,.2)",
            overflow: "hidden",
            pointerEvents: "auto",
            color: "#0d1216"
          },
          onMouseDown: (R) => {
            R.stopPropagation();
          },
          children: /* @__PURE__ */ W(
            "div",
            {
              css: {
                alignItems: "center",
                display: "flex",
                whiteSpace: "nowrap"
              },
              children: [
                !v && !w && !t.includes("ROOT") && /* @__PURE__ */ W(Tt, { children: [
                  t.length > 1 && /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        lineHeight: "32px",
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        cursor: "pointer",
                        fontSize: 14,
                        padding: "0 8px",
                        fontWeight: 700,
                        ":hover": {
                          backgroundColor: "rgba(64,87,109,.07)"
                        }
                      },
                      onClick: D,
                      children: "Group"
                    }
                  ),
                  T && /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        lineHeight: "32px",
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        cursor: "pointer",
                        fontSize: 14,
                        padding: "0 8px",
                        fontWeight: 700,
                        ":hover": {
                          backgroundColor: "rgba(64,87,109,.07)"
                        }
                      },
                      onClick: k,
                      children: "Ungroup"
                    }
                  ),
                  /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        width: 32,
                        height: 32,
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        cursor: "pointer",
                        fontSize: 24,
                        ":hover": {
                          backgroundColor: "rgba(64,87,109,.07)"
                        }
                      },
                      onClick: C,
                      children: /* @__PURE__ */ x(Th, {})
                    }
                  ),
                  /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        width: 32,
                        height: 32,
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        cursor: "pointer",
                        fontSize: 24,
                        ":hover": {
                          backgroundColor: "rgba(64,87,109,.07)"
                        }
                      },
                      onClick: () => i.deleteLayer(n, t),
                      children: /* @__PURE__ */ x(Mh, {})
                    }
                  ),
                  /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        width: 32,
                        height: 32,
                        display: "flex",
                        justifyContent: "center",
                        alignItems: "center",
                        cursor: "pointer",
                        fontSize: 24,
                        ":hover": {
                          backgroundColor: "rgba(64,87,109,.07)"
                        }
                      },
                      onClick: M,
                      children: /* @__PURE__ */ x(Kw, {})
                    }
                  )
                ] }),
                (w || v) && /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      width: 32,
                      height: 32,
                      display: "flex",
                      justifyContent: "center",
                      alignItems: "center",
                      cursor: "pointer",
                      fontSize: 24,
                      color: v ? "rgba(36,49,61,.4)" : void 0,
                      ":hover": {
                        backgroundColor: v ? void 0 : "rgba(64,87,109,.07)"
                      }
                    },
                    onClick: () => {
                      i.unlock(n, t);
                    },
                    children: /* @__PURE__ */ x(ma, {})
                  }
                )
              ]
            }
          )
        }
      )
    }
  );
}, jA = yt.memo(ZA);
var YA = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    viewBox: "0 0 64 56",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "m32 0 32 56H0L32 0"
    })
  }));
};
const qA = ({ boxSize: n, position: e, rotate: t, type: r = "solid", layerType: i }, o) => {
  const { scale: a } = je((l) => ({ scale: l.scale }));
  return /* @__PURE__ */ W(
    "div",
    {
      ref: o,
      css: {
        width: n.width * a,
        height: n.height * a,
        position: "absolute",
        transform: e ? ut({
          position: { x: e.x * a, y: e.y * a },
          rotate: t
        }) : void 0
      },
      children: [
        r === "solid" && i !== "Line" && /* @__PURE__ */ x(
          "div",
          {
            css: {
              border: "2px solid #3d8eff",
              boxShadow: "0 0 0 1px hsla(0,0%,100%,.07), inset 0 0 0 1px hsla(0,0%,100%,.07)",
              position: "absolute",
              inset: -1
            }
          }
        ),
        r === "dashed" && i !== "Line" && /* @__PURE__ */ x(
          "div",
          {
            css: {
              inset: -1,
              position: "absolute",
              backgroundImage: "linear-gradient(90deg,#fff 60%,rgba(53,71,90,.2) 0),linear-gradient(180deg,#fff 60%,rgba(53,71,90,.2) 0),linear-gradient(90deg,#fff 60%,rgba(53,71,90,.2) 0),linear-gradient(180deg,#fff 60%,rgba(53,71,90,.2) 0),linear-gradient(90deg,rgba(57,76,96,.15),rgba(57,76,96,.15)),linear-gradient(180deg,rgba(57,76,96,.15),rgba(57,76,96,.15)),linear-gradient(90deg,rgba(57,76,96,.15),rgba(57,76,96,.15)),linear-gradient(180deg,rgba(57,76,96,.15),rgba(57,76,96,.15))",
              backgroundPosition: "top,100%,bottom,0,center 2px,calc(100% - 2px),center calc(100% - 2px),2px",
              backgroundRepeat: "repeat-x,repeat-y,repeat-x,repeat-y,no-repeat,no-repeat,no-repeat,no-repeat",
              backgroundSize: "6px 2px,2px 6px,6px 2px,2px 6px,calc(100% - 6px) 1px,1px calc(100% - 4px),calc(100% - 6px) 1px,1px calc(100% - 4px)"
            }
          }
        ),
        i === "Video" && /* @__PURE__ */ x(
          "div",
          {
            css: {
              position: "absolute",
              inset: 0,
              transform: ut({
                rotate: -t
              }),
              display: n.width > 80 && n.height > 80 ? "flex" : "none",
              alignItems: "center",
              justifyContent: "center"
            },
            children: /* @__PURE__ */ x(
              "div",
              {
                css: {
                  width: n.height <= 180 || n.width <= 180 ? 24 : 48,
                  height: n.height <= 180 || n.width <= 180 ? 24 : 48,
                  background: "rgba(17,23,29,.6)",
                  borderRadius: "50%",
                  color: "#fff",
                  fontSize: n.height <= 180 || n.width <= 180 ? 8 : 16,
                  transform: ut({
                    rotate: 90
                  }),
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center"
                },
                children: /* @__PURE__ */ x(YA, {})
              }
            )
          }
        )
      ]
    }
  );
}, Ud = Yt(qA), GA = () => {
  const { selectedLayers: n } = rn(), e = pe(
    () => !!n.find(
      (t) => ui(t) || fs(t) || Vi(t) || xc(t)
    ),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(n.map((t) => t.id))]
  );
  return pe(() => {
    const t = {
      vertical: n.length > 1,
      horizontal: n.length > 1,
      corners: !1,
      locked: !1,
      rotate: !1,
      scalable: !e
    };
    return n.forEach((r) => {
      r.data.locked && (t.locked = !0, t.vertical = !0, t.horizontal = !0, t.corners = !0, t.rotate = !0), ui(r) && (t.vertical = !0), (Vi(r) || kh(r)) && (t.horizontal = !0, t.vertical = !0, t.scalable = !1), fs(r) && (t.horizontal = !0, t.vertical = !0);
    }), t;
  }, [e, n]);
}, KA = ({ pageIndex: n, width: e, height: t, transform: r }, i) => {
  var le, Ce, Ne, me;
  const o = ge(null), a = ge(null), [l] = Pi(null), u = ge({}), [d, h, p] = Pi(), [g, v, m] = Pi(
    {}
  ), { selectedLayerIds: w, selectedLayers: b } = rn(), C = GA(), {
    actions: M,
    hoveredLayer: k,
    scale: D,
    activePage: T,
    controlBox: R,
    imageEditor: _,
    textEditor: Z,
    totalPages: K,
    isLocked: $
  } = je((U) => {
    const ae = U.hoveredLayer[n];
    return {
      activePage: U.activePage,
      controlBox: U.controlBox,
      scale: U.scale,
      isLocked: U.pages[n] && U.pages[n].layers.ROOT.data.locked,
      hoveredLayer: ae ? U.pages[n].layers[ae] : null,
      selectStatus: U.selectData.status,
      imageEditor: U.imageEditor,
      textEditor: U.textEditor,
      totalPages: U.pages.length
    };
  }), F = (U) => {
    if (U.preventDefault(), !(k && k.data.locked)) {
      if (R && o.current && k) {
        const ae = new WebKitCSSMatrix(
          ut({
            rotate: R.rotate
          })
        ), G = o.current.getBoundingClientRect(), xe = oi(
          {
            width: R.boxSize.width * D,
            height: R.boxSize.height * D
          },
          ae,
          {
            x: G.x + R.position.x * D,
            y: G.y + R.position.y * D
          }
        );
        Jl({ x: U.clientX, y: U.clientY }, xe) || M.selectLayers(n, k.id);
      } else
        k && M.selectLayers(n, k.id);
      M.showContextMenu(Wt(U.nativeEvent));
    }
  };
  be(() => {
    d.current && p({
      boxSize: {
        width: d.current.boxSize.width * D,
        height: d.current.boxSize.height * D
      },
      position: {
        x: d.current.position.x * D,
        y: d.current.position.y * D
      },
      rotate: d.current.rotate,
      scale: d.current.scale
    }), g.current && Object.entries(g.current).forEach(([U, ae]) => {
      ae.centerX && (g.current[U].centerX = ae.centerX * D), ae.centerY && (g.current[U].centerY = ae.centerY * D), g.current[U].position.x = ae.position.x * D, g.current[U].position.y = ae.position.y * D, g.current[U].boxSize.width = ae.boxSize.width * D, g.current[U].boxSize.height = ae.boxSize.height * D;
    });
  }, [d, g, D, p]);
  const Y = (U, ae) => {
    var G;
    if (C.scalable || !["top", "left", "right", "bottom"].includes(U) || w.length > 1 || !ui(b[0]))
      return ae;
    {
      const { clientHeight: xe } = D1(
        (G = b[0].data.editor) == null ? void 0 : G.dom,
        ae.boxSize.width,
        ae.scale || 1
      );
      return cr(ae, {
        boxSize: { height: xe }
      });
    }
  }, Q = (U) => {
    const ae = v(), G = h(), xe = U.boxSize.width / G.boxSize.width, ye = {};
    return b.forEach(({ id: Je }) => {
      const te = ae[Je], $e = {
        width: te.boxSize.width * xe,
        height: te.boxSize.height * xe
      };
      ye[Je] = {
        position: {
          x: G.position.x - (G.position.x - te.position.x) * xe + (U.position.x - G.position.x),
          y: G.position.y - (G.position.y - te.position.y) * xe + (U.position.y - G.position.y)
        },
        boxSize: $e,
        scale: typeof te.scale < "u" ? te.scale * xe : void 0,
        rotate: te.rotate
      };
    }), ye;
  }, ee = (U, ae, G) => w.length === 1 ? {
    layers: {
      [w[0]]: G
    },
    lockAspect: !ae && !["top", "left", "right", "bottom"].includes(U) && (Jo(b[0]) || Pl(b[0])) || ae && (!Jo(b[0]) || !Pl(b[0]))
  } : {
    layers: Q(G),
    lockAspect: !0
  }, ie = (U, ae, G) => {
    const xe = Y(U, G), ye = ee(
      U,
      ae,
      xe
    );
    M.setControlBox(xe), Object.entries(ye.layers).forEach(([Je, te]) => {
      const $e = b.find((Be) => Be.id === Je);
      if ($e)
        if (Jo($e)) {
          const Be = te.boxSize.width - $e.data.props.boxSize.width, vt = te.boxSize.height - $e.data.props.boxSize.height, P = $e.data.props;
          if (ye.lockAspect) {
            const A = te.boxSize.width / $e.data.props.boxSize.width;
            M.history.merge().setProp(n, Je, {
              ...te,
              image: {
                boxSize: {
                  width: $e.data.props.image.boxSize.width * A,
                  height: $e.data.props.image.boxSize.height * A
                },
                position: {
                  x: $e.data.props.image.position.x * A,
                  y: $e.data.props.image.position.y * A
                },
                rotate: 0
              }
            });
          } else {
            const A = x8(P, P.image, U, {
              width: Be,
              height: vt
            });
            M.history.merge().setProp(n, Je, {
              ...A,
              position: {
                x: te.position.x,
                y: te.position.y
              }
            });
          }
        } else if (Pl($e)) {
          const Be = te.boxSize.width - $e.data.props.boxSize.width, vt = te.boxSize.height - $e.data.props.boxSize.height, P = $e.data.props;
          if (ye.lockAspect) {
            const A = te.boxSize.width / $e.data.props.boxSize.width;
            M.history.merge().setProp(n, Je, {
              ...te,
              video: {
                boxSize: {
                  width: $e.data.props.video.boxSize.width * A,
                  height: $e.data.props.video.boxSize.height * A
                },
                position: {
                  x: $e.data.props.video.position.x * A,
                  y: $e.data.props.video.position.y * A
                },
                rotate: 0
              }
            });
          } else {
            const A = S8(P, P.video, U, {
              width: Be,
              height: vt
            });
            M.history.merge().setProp(n, Je, {
              ...A,
              position: {
                x: te.position.x,
                y: te.position.y
              }
            });
          }
        } else
          M.history.merge().setProp(n, Je, te);
    });
  }, { startResizing: re } = v8({
    options: {
      scalable: !C.scalable
    },
    frameScale: D,
    getLayerData: v,
    controlBox: R,
    getControlBoxData: h,
    lockAspect: (U) => {
      const ae = b.length === 1 && Jo(b[0]), G = b.length === 1 && Pl(b[0]);
      return U.shiftKey && !ae && !G || w.length > 1 || (ae || G) && !U.shiftKey && !["top", "left", "right", "bottom"].includes(U.direction);
    },
    onResizeStart: (U, { direction: ae }) => {
      const { clientX: G, clientY: xe } = Wt(U);
      M.setResizeData(
        !0,
        w,
        ae,
        R.rotate,
        R.boxSize,
        {
          clientX: G,
          clientY: xe
        }
      ), p(R);
      const ye = {};
      b.forEach(
        ({
          id: Je,
          data: {
            props: { boxSize: te, position: $e, rotate: Be, scale: vt },
            type: P
          }
        }) => {
          ye[Je] = Te.cloneDeep({
            boxSize: te,
            position: $e,
            rotate: Be,
            scale: vt,
            type: P
          });
        }
      ), m(ye), M.history.new();
    },
    onResize: (U, { direction: ae, useShift: G }, xe) => {
      const { clientX: ye, clientY: Je } = Wt(U);
      M.setResizeData(
        !0,
        w,
        ae,
        xe.rotate,
        xe.boxSize,
        {
          clientX: ye,
          clientY: Je
        }
      ), ie(ae, G, xe);
    },
    onResizeStop: (U, { direction: ae, useShift: G }, xe) => {
      M.setResizeData(!1), ie(ae, G, xe);
    }
  }), { startUpdating: oe } = y8({
    getLayerData: v,
    frameScale: D,
    pageOffset: {
      x: ((le = o.current) == null ? void 0 : le.getBoundingClientRect().x) || 0,
      y: ((Ce = o.current) == null ? void 0 : Ce.getBoundingClientRect().y) || 0
    },
    onDragStart: (U, ae) => {
      const G = {};
      b.forEach(
        ({
          id: xe,
          data: {
            props: { boxSize: ye, position: Je, rotate: te, scale: $e },
            type: Be
          }
        }) => {
          G[xe] = Te.cloneDeep({
            boxSize: ye,
            position: Je,
            rotate: te,
            scale: $e,
            type: Be
          }), M.setUpdateLineData(!0, xe, ae), M.setControlBox({
            boxSize: ye,
            position: Je,
            rotate: te,
            scale: $e
          });
        }
      ), m(G), M.history.new();
    },
    onDrag: (U, ae, G) => {
      M.setProp(T, b[0].id, G), M.setControlBox(G);
    },
    onDragStop: (U, ae, G) => {
      M.setProp(T, b[0].id, G), M.setControlBox(G), M.setUpdateLineData(!1);
    }
  });
  be(() => {
    const U = b.filter((ae) => ae.id !== "ROOT").reduce((ae, G) => (ae[G.id] = G.data.props, ae), {});
    M.setControlBox(oa(U));
  }, [JSON.stringify(w), D]);
  const de = (U, { controlBox: ae, layers: G }) => {
    M.setRotateData(!0, U), M.setControlBox(ae), Object.entries(G).forEach(([xe, ye]) => {
      M.history.merge().setProp(n, xe, ye);
    });
  }, se = (U, { controlBox: ae, layers: G }) => {
    M.setRotateData(!1), M.setControlBox(ae), Object.entries(G).forEach(([xe, ye]) => {
      M.history.merge().setProp(n, xe, ye);
    });
  }, { startRotate: we } = w8({
    getLayerData: v,
    frameScale: D,
    pageOffset: {
      x: ((Ne = o.current) == null ? void 0 : Ne.getBoundingClientRect().x) || 0,
      y: ((me = o.current) == null ? void 0 : me.getBoundingClientRect().y) || 0
    },
    getControlBoxData: h,
    setControlBoxData: p,
    onRotateStart: () => {
      const U = {};
      b.forEach((ae) => {
        const { centerX: G, centerY: xe } = hr(
          ae.data.props.boxSize,
          ae.data.props.position,
          ae.data.props.rotate
        );
        U[ae.id] = Te.cloneDeep({
          position: ae.data.props.position,
          boxSize: ae.data.props.boxSize,
          rotate: ae.data.props.rotate,
          scale: ae.data.props.scale,
          centerX: G,
          centerY: xe,
          type: ae.data.type
        });
      }), p(R), m(U), M.setRotateData(!0, b8(R.rotate)), M.history.new();
    },
    onRotate: de,
    onRotateEnd: se
  }), Oe = async (U) => {
    if (a.current)
      try {
        const ae = await IA(a.current), G = document.createElement("a");
        G.download = `design-id-page-${U + 1}.png`, G.href = ae, G.click();
      } catch (ae) {
        window.alert("Cannot download: " + ae.message);
      }
  };
  return /* @__PURE__ */ W(tv, { pageIndex: n, children: [
    /* @__PURE__ */ W(
      "div",
      {
        css: {
          fontWeight: "bold",
          marginTop: 24,
          height: 28,
          display: "flex",
          alignItems: "center",
          marginBottom: 4,
          width: e * D,
          whiteSpace: "nowrap",
          "@media (max-width: 900px)": {
            display: "none"
          }
        },
        children: [
          /* @__PURE__ */ W("div", { css: { flexGrow: 1 }, children: [
            "Page ",
            n + 1
          ] }),
          /* @__PURE__ */ W(
            "div",
            {
              css: {
                display: "flex",
                alignItems: "center",
                fontSize: 20,
                color: "#0d1216",
                height: 28,
                opacity: 0.7
              },
              children: [
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: n === 0 ? "not-allowed" : "pointer",
                      color: n === 0 ? "rgba(36,49,61,.4)" : "#0d1216",
                      ":hover": {
                        background: n === 0 ? void 0 : "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => M.movePageUp(n),
                    children: /* @__PURE__ */ x(BI, {})
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: n === K - 1 ? "not-allowed" : "pointer",
                      color: n === K - 1 ? "rgba(36,49,61,.4)" : "#0d1216",
                      ":hover": {
                        background: n === K - 1 ? void 0 : "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => M.movePageDown(n),
                    children: /* @__PURE__ */ x(Ww, {})
                  }
                ),
                /* @__PURE__ */ W(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: "pointer",
                      ":hover": {
                        background: "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => {
                      $ ? M.unlockPage(n) : M.lockPage(n);
                    },
                    children: [
                      !$ && /* @__PURE__ */ x(Ff, {}),
                      $ && /* @__PURE__ */ x(ma, {})
                    ]
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: "pointer",
                      ":hover": {
                        background: "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => M.duplicatePage(n),
                    children: /* @__PURE__ */ x(Th, {})
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: "pointer",
                      ":hover": {
                        background: "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => Oe(n),
                    children: /* @__PURE__ */ x(FI, {})
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: $ || K <= 1 ? "not-allowed" : "pointer",
                      color: $ || K <= 1 ? "rgba(36,49,61,.4)" : "#0d1216",
                      ":hover": {
                        background: $ || K <= 1 ? void 0 : "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => !$ && K > 1 && M.deletePage(n),
                    children: /* @__PURE__ */ x(Mh, {})
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      marginLeft: 8,
                      width: 28,
                      height: 28,
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center",
                      borderRadius: 4,
                      cursor: "pointer",
                      ":hover": {
                        background: "rgba(64, 87, 109, 0.07)"
                      }
                    },
                    onClick: () => M.addPage(n),
                    children: /* @__PURE__ */ x(VI, {})
                  }
                )
              ]
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ W(
      "div",
      {
        ref: i,
        css: {
          position: "relative",
          margin: 0,
          boxShadow: "0 2px 8px rgba(14,19,24,.07)",
          "@media (max-width: 900px)": {
            boxShadow: "none"
          }
        },
        style: {
          width: e * D * r.scale,
          height: t * D * r.scale,
          transform: ut({
            position: r,
            scale: r.scale
          })
        },
        children: [
          /* @__PURE__ */ x(
            "div",
            {
              ref: o,
              css: {
                userSelect: "none",
                background: "white",
                overflow: "hidden",
                transformOrigin: "0 0"
              },
              style: {
                width: e,
                height: t,
                transform: `scale(${D * r.scale})`
              },
              onContextMenu: F,
              children: /* @__PURE__ */ x(
                "div",
                {
                  ref: a,
                  css: {
                    width: e,
                    height: t,
                    position: "relative",
                    left: 0,
                    top: 0,
                    zIndex: 1,
                    "@media (max-width: 900px)": {
                      width: e * D,
                      height: t * D
                    }
                  },
                  children: /* @__PURE__ */ x(Fw, {})
                }
              )
            }
          ),
          /* @__PURE__ */ W(
            "div",
            {
              css: {
                position: "absolute",
                inset: 0,
                pointerEvents: "none",
                zIndex: 2
              },
              children: [
                !_ && n === T && R && b.length > 1 && /* @__PURE__ */ x(
                  Ud,
                  {
                    boxSize: R.boxSize,
                    position: R.position,
                    rotate: R.rotate,
                    type: "dashed"
                  }
                ),
                !_ && n === T && b.map((U) => /* @__PURE__ */ x(
                  Ud,
                  {
                    ref: (ae) => ae && (u.current[U.id] = ae),
                    boxSize: U.data.props.boxSize,
                    layerType: U.data.type,
                    position: U.data.props.position,
                    rotate: U.data.props.rotate
                  },
                  U.id
                )),
                !_ && k && !w.includes(k.id) && /* @__PURE__ */ x(
                  Ud,
                  {
                    ref: (U) => U && (u.current[k.id] = U),
                    boxSize: k.data.props.boxSize,
                    position: k.data.props.position,
                    rotate: k.data.props.rotate
                  }
                ),
                !_ && n === T && w.length > 0 && /* @__PURE__ */ W(Tt, { children: [
                  R && !(w.length === 1 && b[0].data.type === "Line") && /* @__PURE__ */ x(
                    WA,
                    {
                      ref: l,
                      boxSize: R.boxSize,
                      disabled: C,
                      locked: C.locked,
                      position: R.position,
                      rotate: R.rotate,
                      scale: R.scale,
                      onResizeStart: re,
                      onRouteStart: we
                    }
                  ),
                  R && w.length === 1 && b[0].data.type === "Line" && /* @__PURE__ */ x(
                    UA,
                    {
                      boxSize: b[0].data.props.boxSize,
                      disabled: C,
                      locked: C.locked,
                      position: b[0].data.props.position,
                      rotate: b[0].data.props.rotate,
                      onChangeStart: oe,
                      onRouteStart: we
                    }
                  ),
                  /* @__PURE__ */ x(jA, {})
                ] }),
                n === T && /* @__PURE__ */ x(HA, {})
              ]
            }
          ),
          _ && _.pageIndex === n && /* @__PURE__ */ x(_A, {}),
          Z && Z.pageIndex === n && /* @__PURE__ */ x(BA, {})
        ]
      }
    )
  ] });
}, XA = Yt(KA), TP = ({ data: n }) => {
  var Ne, me, U, ae;
  const e = Aw(), t = ge(null), r = ge(null), i = ge([]), o = ge(null), { usedFonts: a } = Jc(), {
    config: { assetPath: l }
  } = It(di), [u, d] = Le(!1);
  gI(t.current);
  const {
    actions: h,
    scale: p,
    pages: g,
    hoveredPage: v,
    hoveredLayer: m,
    selectStatus: w,
    rotateData: b,
    resizeData: C,
    controlBox: M,
    activePage: k,
    dragData: D,
    imageEditor: T,
    pageSize: R
  } = je((G, xe) => {
    const ye = parseInt(Object.keys(G.hoveredLayer)[0]), Je = G.hoveredLayer[ye];
    return {
      scale: G.scale,
      pages: G.pages,
      hoveredPage: ye,
      hoveredLayer: Je ? G.pages[ye].layers[Je] : null,
      selectStatus: G.selectData.status,
      rotateData: G.rotateData,
      resizeData: G.resizeData,
      controlBox: G.controlBox,
      activePage: G.activePage,
      dragData: G.dragData,
      imageEditor: G.imageEditor,
      pageSize: xe.getPageSize()
    };
  }), {
    pageTransform: _,
    onZoomStart: Z,
    onZoomMove: K,
    onZoomEnd: $,
    onMoveStart: F,
    onMove: Y,
    onMoveEnd: Q,
    onMovePage: ee,
    onMovePageEnd: ie
  } = mI(t, i, r);
  be(() => {
    h.setData(n);
  }, [n, h]), YT(
    o,
    () => {
      h.hideContextMenu();
    },
    "mousedown",
    { capture: !0 }
  );
  const re = ge(null), { selectedLayerIds: oe } = rn(), de = () => {
    if (!D.status && !w) {
      const G = t.current;
      i.current[k] && !v0(G, i.current[k]) && i.current.some((xe, ye) => v0(G, xe) ? (h.selectLayers(ye, "ROOT"), !0) : !1);
    }
  }, { tmpSelected: se, onSelectStart: we } = pI({
    frameRef: t,
    pageListRef: i,
    selectionBoxRef: re
  }), { onDragStart: Oe } = fI({
    frameRef: t,
    pageListRef: i
  }), le = Ie(
    (G) => {
      if (w0(G) && G.button === 2 || T || b0(G) && G.touches.length > 1)
        return;
      const xe = i.current.find(
        (Be) => Be.contains(G.target)
      ), ye = i.current.find(
        (Be) => G.target.contains(Be)
      ), { clientX: Je, clientY: te } = Wt(G);
      if (!xe && !ye)
        return;
      let $e = !1;
      if (M) {
        const Be = new WebKitCSSMatrix(
          ut({
            rotate: M.rotate
          })
        ), vt = i.current[k].getBoundingClientRect(), P = oi(
          {
            width: M.boxSize.width * p,
            height: M.boxSize.height * p
          },
          Be,
          {
            x: vt.x + M.position.x * p,
            y: vt.y + M.position.y * p
          }
        );
        $e = Jl(
          { x: Je, y: te },
          P
        );
      }
      m && m.id !== "ROOT" && !oe.includes(m.id) && (!$e || M && M1(m.data.props, M)) && h.selectLayers(
        v,
        m.id,
        e.current ? "add" : "replace"
      ), m && m.id !== "ROOT" && !m.data.locked || $e ? (Oe(G), G.stopPropagation()) : w0(G) ? (we(G), G.stopPropagation()) : b0(G) && F(G);
    },
    [m, M, oe, D]
  );
  return /* @__PURE__ */ W(Tt, { children: [
    /* @__PURE__ */ W(
      "div",
      {
        ref: t,
        css: {
          display: "flex",
          position: "relative",
          height: "100%",
          overflow: "scroll",
          ...(() => {
            if (b.status) {
              const G = Math.round((b.rotate || 0) / 10);
              return {
                cursor: `url('${l}/cursors/rotate/${G === 36 ? 0 : G}.png') 12 12, auto;`
              };
            } else if (C.status) {
              const G = {
                bottomLeft: 45,
                left: 90,
                topLeft: 135,
                top: 180,
                topRight: 225,
                right: 270,
                bottomRight: 315,
                bottom: 0
              }, xe = (C.rotate || 0) + G[C.direction || "bottom"] + 90, ye = Math.round(xe % 180 / 10);
              return {
                cursor: `url('${l}/cursors/resize/${ye}.png') 12 12, auto`
              };
            } else if (D.status)
              return {
                cursor: "move"
              };
            return {};
          })(),
          "@media (max-width: 900px)": {
            overflow: "hidden",
            height: "calc(100% - 72px)"
          }
        },
        tabIndex: 0,
        onScroll: () => {
          de();
        },
        onTouchEnd: $,
        onTouchMove: K,
        onTouchStart: Z,
        children: [
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                position: "absolute",
                display: "flex",
                minWidth: "100%",
                minHeight: "100%"
              },
              onMouseDown: (G) => le(G.nativeEvent),
              onTouchStart: (G) => le(G.nativeEvent),
              children: /* @__PURE__ */ W(
                "div",
                {
                  css: {
                    position: "relative",
                    display: "flex",
                    flexGrow: 1,
                    touchAction: "pinch-zoom"
                  },
                  children: [
                    /* @__PURE__ */ W(
                      "div",
                      {
                        ref: r,
                        css: {
                          display: "flex",
                          position: "relative",
                          flexDirection: "row",
                          justifyContent: "center",
                          margin: "auto",
                          "@media (max-width: 900px)": {
                            transition: "transform 250ms linear 0s",
                            margin: "initial"
                          }
                        },
                        style: {
                          transform: `translateX(-${Hc ? window.innerWidth * k : 0}px)`
                        },
                        children: [
                          /* @__PURE__ */ W(
                            "div",
                            {
                              css: {
                                marginLeft: 56,
                                "@media (max-width: 900px)": {
                                  display: "flex",
                                  marginLeft: 0
                                }
                              },
                              onTouchEnd: () => {
                                Q(), ie();
                              },
                              onTouchMove: (G) => {
                                Y(G), ee(G);
                              },
                              children: [
                                /* @__PURE__ */ x(I1, { fonts: a, mode: "editor" }),
                                g.map((G, xe) => /* @__PURE__ */ x(
                                  "div",
                                  {
                                    css: {
                                      "@media (max-width: 900px)": {
                                        padding: "0 16px",
                                        width: window.innerWidth,
                                        height: window.innerHeight,
                                        overflow: "hidden"
                                      }
                                    },
                                    children: /* @__PURE__ */ x(
                                      XA,
                                      {
                                        ref: (ye) => ye && (i.current[xe] = ye),
                                        height: R.height,
                                        pageIndex: xe,
                                        transform: _,
                                        width: R.width
                                      }
                                    )
                                  },
                                  xe
                                )),
                                /* @__PURE__ */ x(
                                  "div",
                                  {
                                    css: {
                                      marginTop: 20,
                                      marginBottom: 20,
                                      background: "rgba(64,87,109,.07)",
                                      color: "#0d1216",
                                      width: R.width * p,
                                      textAlign: "center",
                                      paddingTop: 8,
                                      paddingBottom: 8,
                                      borderRadius: 8,
                                      "@media (max-width: 900px)": {
                                        display: "none"
                                      }
                                    },
                                    onClick: () => {
                                      h.addPage();
                                    },
                                    children: "Add Page"
                                  }
                                )
                              ]
                            }
                          ),
                          /* @__PURE__ */ x(
                            "div",
                            {
                              css: {
                                width: 56,
                                pointerEvents: "none",
                                "@media (max-width: 900px)": {
                                  width: 0
                                }
                              }
                            }
                          )
                        ]
                      }
                    ),
                    /* @__PURE__ */ x(DI, { ref: o }),
                    w && /* @__PURE__ */ x(
                      AI,
                      {
                        ref: re,
                        selectedLayers: se == null ? void 0 : se.selectedLayers
                      }
                    )
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                display: "none",
                "@media (max-width: 900px)": {
                  pointerEvents: "auto",
                  display: "flex",
                  position: "absolute",
                  bottom: 24,
                  left: 24,
                  background: "#3d8eff",
                  width: 48,
                  height: 48,
                  alignItems: "center",
                  justifyContent: "center",
                  borderRadius: "50%",
                  color: "#fff",
                  fontSize: 24
                }
              },
              onClick: () => {
                h.addPage();
              },
              children: /* @__PURE__ */ x(ua, {})
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                display: "none",
                "@media (max-width: 900px)": {
                  pointerEvents: "auto",
                  display: "flex",
                  position: "absolute",
                  bottom: 24,
                  right: 24,
                  background: "#fff",
                  width: 48,
                  height: 48,
                  alignItems: "center",
                  justifyContent: "center",
                  borderRadius: "50%",
                  fontSize: 24,
                  boxShadow: "0 0 0 1px rgba(64,87,109,.07),0 2px 12px rgba(53,71,90,.2)"
                }
              },
              onClick: () => {
                d(!0);
              },
              children: /* @__PURE__ */ x(TO, {})
            }
          )
        ]
      }
    ),
    C.status && /* @__PURE__ */ W(
      "div",
      {
        css: {
          position: "fixed",
          top: `${(((Ne = C.cursor) == null ? void 0 : Ne.clientY) || 0) + 36}px`,
          left: `${(((me = C.cursor) == null ? void 0 : me.clientX) || 0) + 60}px`,
          whiteSpace: "nowrap",
          background: "#3a3a4c",
          padding: "3px 8px",
          borderRadius: 4,
          textAlign: "center",
          color: "white",
          fontSize: 12,
          fontWeight: 700
        },
        children: [
          "w: ",
          Math.round(((U = C.boxSize) == null ? void 0 : U.width) || 0),
          " h:",
          " ",
          Math.round(((ae = C.boxSize) == null ? void 0 : ae.height) || 0)
        ]
      }
    ),
    u && /* @__PURE__ */ x(zI, { onClose: () => d(!1) })
  ] });
};
var Ih = Symbol.for("immer-nothing"), ea = Symbol.for("immer-draftable"), Jn = Symbol.for("immer-state"), Xw = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(n) {
    return `The plugin for '${n}' has not been loaded into Immer. To enable the plugin, import and call \`enable${n}()\` when initializing your application.`;
  },
  function(n) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${n}'`;
  },
  "This object has been frozen and should not be mutated",
  function(n) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + n;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(n) {
    return `'current' expects a draft, got: ${n}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(n) {
    return `'original' expects a draft, got: ${n}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function jt(n, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const t = Xw[n], r = typeof t == "function" ? t.apply(null, e) : t;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${n}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Eo = Object.getPrototypeOf;
function ko(n) {
  return !!n && !!n[Jn];
}
function Wi(n) {
  var e;
  return n ? Jw(n) || Array.isArray(n) || !!n[ea] || !!((e = n.constructor) != null && e[ea]) || La(n) || Pa(n) : !1;
}
var JA = Object.prototype.constructor.toString();
function Jw(n) {
  if (!n || typeof n != "object")
    return !1;
  const e = Eo(n);
  if (e === null)
    return !0;
  const t = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return t === Object ? !0 : typeof t == "function" && Function.toString.call(t) === JA;
}
function hs(n, e) {
  Oo(n) === 0 ? Object.entries(n).forEach(([t, r]) => {
    e(t, r, n);
  }) : n.forEach((t, r) => e(r, t, n));
}
function Oo(n) {
  const e = n[Jn];
  return e ? e.type_ : Array.isArray(n) ? 1 : La(n) ? 2 : Pa(n) ? 3 : 0;
}
function va(n, e) {
  return Oo(n) === 2 ? n.has(e) : Object.prototype.hasOwnProperty.call(n, e);
}
function Zd(n, e) {
  return Oo(n) === 2 ? n.get(e) : n[e];
}
function Qw(n, e, t) {
  const r = Oo(n);
  r === 2 ? n.set(e, t) : r === 3 ? n.add(t) : n[e] = t;
}
function QA(n, e) {
  return n === e ? n !== 0 || 1 / n === 1 / e : n !== n && e !== e;
}
function La(n) {
  return n instanceof Map;
}
function Pa(n) {
  return n instanceof Set;
}
function uo(n) {
  return n.copy_ || n.base_;
}
function Wf(n, e) {
  if (La(n))
    return new Map(n);
  if (Pa(n))
    return new Set(n);
  if (Array.isArray(n))
    return Array.prototype.slice.call(n);
  if (!e && Jw(n))
    return Eo(n) ? { ...n } : Object.assign(/* @__PURE__ */ Object.create(null), n);
  const t = Object.getOwnPropertyDescriptors(n);
  delete t[Jn];
  let r = Reflect.ownKeys(t);
  for (let i = 0; i < r.length; i++) {
    const o = r[i], a = t[o];
    a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (t[o] = {
      configurable: !0,
      writable: !0,
      // could live with !!desc.set as well here...
      enumerable: a.enumerable,
      value: n[o]
    });
  }
  return Object.create(Eo(n), t);
}
function Ah(n, e = !1) {
  return eu(n) || ko(n) || !Wi(n) || (Oo(n) > 1 && (n.set = n.add = n.clear = n.delete = e5), Object.freeze(n), e && hs(n, (t, r) => Ah(r, !0))), n;
}
function e5() {
  jt(2);
}
function eu(n) {
  return Object.isFrozen(n);
}
var Hf = {};
function To(n) {
  const e = Hf[n];
  return e || jt(0, n), e;
}
function t5(n, e) {
  Hf[n] || (Hf[n] = e);
}
var ya;
function eb() {
  return ya;
}
function n5(n, e) {
  return {
    drafts_: [],
    parent_: n,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Qm(n, e) {
  e && (To("Patches"), n.patches_ = [], n.inversePatches_ = [], n.patchListener_ = e);
}
function $f(n) {
  Uf(n), n.drafts_.forEach(r5), n.drafts_ = null;
}
function Uf(n) {
  n === ya && (ya = n.parent_);
}
function e1(n) {
  return ya = n5(ya, n);
}
function r5(n) {
  const e = n[Jn];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function t1(n, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const t = e.drafts_[0];
  return n !== void 0 && n !== t ? (t[Jn].modified_ && ($f(e), jt(4)), Wi(n) && (n = Ec(e, n), e.parent_ || kc(e, n)), e.patches_ && To("Patches").generateReplacementPatches_(
    t[Jn].base_,
    n,
    e.patches_,
    e.inversePatches_
  )) : n = Ec(e, t, []), $f(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), n !== Ih ? n : void 0;
}
function Ec(n, e, t) {
  if (eu(e))
    return e;
  const r = e[Jn];
  if (!r)
    return hs(
      e,
      (i, o) => n1(n, r, e, i, o, t)
    ), e;
  if (r.scope_ !== n)
    return e;
  if (!r.modified_)
    return kc(n, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const i = r.copy_;
    let o = i, a = !1;
    r.type_ === 3 && (o = new Set(i), i.clear(), a = !0), hs(
      o,
      (l, u) => n1(n, r, i, l, u, t, a)
    ), kc(n, i, !1), t && n.patches_ && To("Patches").generatePatches_(
      r,
      t,
      n.patches_,
      n.inversePatches_
    );
  }
  return r.copy_;
}
function n1(n, e, t, r, i, o, a) {
  if (process.env.NODE_ENV !== "production" && i === t && jt(5), ko(i)) {
    const l = o && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !va(e.assigned_, r) ? o.concat(r) : void 0, u = Ec(n, i, l);
    if (Qw(t, r, u), ko(u))
      n.canAutoFreeze_ = !1;
    else
      return;
  } else
    a && t.add(i);
  if (Wi(i) && !eu(i)) {
    if (!n.immer_.autoFreeze_ && n.unfinalizedDrafts_ < 1)
      return;
    Ec(n, i), (!e || !e.scope_.parent_) && kc(n, i);
  }
}
function kc(n, e, t = !1) {
  !n.parent_ && n.immer_.autoFreeze_ && n.canAutoFreeze_ && Ah(e, t);
}
function i5(n, e) {
  const t = Array.isArray(n), r = {
    type_: t ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : eb(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: n,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let i = r, o = Lh;
  t && (i = [r], o = wa);
  const { revoke: a, proxy: l } = Proxy.revocable(i, o);
  return r.draft_ = l, r.revoke_ = a, l;
}
var Lh = {
  get(n, e) {
    if (e === Jn)
      return n;
    const t = uo(n);
    if (!va(t, e))
      return o5(n, t, e);
    const r = t[e];
    return n.finalized_ || !Wi(r) ? r : r === jd(n.base_, e) ? (Yd(n), n.copy_[e] = jf(r, n)) : r;
  },
  has(n, e) {
    return e in uo(n);
  },
  ownKeys(n) {
    return Reflect.ownKeys(uo(n));
  },
  set(n, e, t) {
    const r = tb(uo(n), e);
    if (r != null && r.set)
      return r.set.call(n.draft_, t), !0;
    if (!n.modified_) {
      const i = jd(uo(n), e), o = i == null ? void 0 : i[Jn];
      if (o && o.base_ === t)
        return n.copy_[e] = t, n.assigned_[e] = !1, !0;
      if (QA(t, i) && (t !== void 0 || va(n.base_, e)))
        return !0;
      Yd(n), Zf(n);
    }
    return n.copy_[e] === t && // special case: handle new props with value 'undefined'
    (t !== void 0 || e in n.copy_) || // special case: NaN
    Number.isNaN(t) && Number.isNaN(n.copy_[e]) || (n.copy_[e] = t, n.assigned_[e] = !0), !0;
  },
  deleteProperty(n, e) {
    return jd(n.base_, e) !== void 0 || e in n.base_ ? (n.assigned_[e] = !1, Yd(n), Zf(n)) : delete n.assigned_[e], n.copy_ && delete n.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(n, e) {
    const t = uo(n), r = Reflect.getOwnPropertyDescriptor(t, e);
    return r && {
      writable: !0,
      configurable: n.type_ !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: t[e]
    };
  },
  defineProperty() {
    jt(11);
  },
  getPrototypeOf(n) {
    return Eo(n.base_);
  },
  setPrototypeOf() {
    jt(12);
  }
}, wa = {};
hs(Lh, (n, e) => {
  wa[n] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
wa.deleteProperty = function(n, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && jt(13), wa.set.call(this, n, e, void 0);
};
wa.set = function(n, e, t) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && jt(14), Lh.set.call(this, n[0], e, t, n[0]);
};
function jd(n, e) {
  const t = n[Jn];
  return (t ? uo(t) : n)[e];
}
function o5(n, e, t) {
  var i;
  const r = tb(e, t);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (i = r.get) == null ? void 0 : i.call(n.draft_)
  ) : void 0;
}
function tb(n, e) {
  if (!(e in n))
    return;
  let t = Eo(n);
  for (; t; ) {
    const r = Object.getOwnPropertyDescriptor(t, e);
    if (r)
      return r;
    t = Eo(t);
  }
}
function Zf(n) {
  n.modified_ || (n.modified_ = !0, n.parent_ && Zf(n.parent_));
}
function Yd(n) {
  n.copy_ || (n.copy_ = Wf(
    n.base_,
    n.scope_.immer_.useStrictShallowCopy_
  ));
}
var s5 = class {
  constructor(n) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, t, r) => {
      if (typeof e == "function" && typeof t != "function") {
        const o = t;
        t = e;
        const a = this;
        return function(u = o, ...d) {
          return a.produce(u, (h) => t.call(this, h, ...d));
        };
      }
      typeof t != "function" && jt(6), r !== void 0 && typeof r != "function" && jt(7);
      let i;
      if (Wi(e)) {
        const o = e1(this), a = jf(e, void 0);
        let l = !0;
        try {
          i = t(a), l = !1;
        } finally {
          l ? $f(o) : Uf(o);
        }
        return Qm(o, r), t1(i, o);
      } else if (!e || typeof e != "object") {
        if (i = t(e), i === void 0 && (i = e), i === Ih && (i = void 0), this.autoFreeze_ && Ah(i, !0), r) {
          const o = [], a = [];
          To("Patches").generateReplacementPatches_(e, i, o, a), r(o, a);
        }
        return i;
      } else
        jt(1, e);
    }, this.produceWithPatches = (e, t) => {
      if (typeof e == "function")
        return (a, ...l) => this.produceWithPatches(a, (u) => e(u, ...l));
      let r, i;
      return [this.produce(e, t, (a, l) => {
        r = a, i = l;
      }), r, i];
    }, typeof (n == null ? void 0 : n.autoFreeze) == "boolean" && this.setAutoFreeze(n.autoFreeze), typeof (n == null ? void 0 : n.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(n.useStrictShallowCopy);
  }
  createDraft(n) {
    Wi(n) || jt(8), ko(n) && (n = a5(n));
    const e = e1(this), t = jf(n, void 0);
    return t[Jn].isManual_ = !0, Uf(e), t;
  }
  finishDraft(n, e) {
    const t = n && n[Jn];
    (!t || !t.isManual_) && jt(9);
    const { scope_: r } = t;
    return Qm(r, e), t1(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(n) {
    this.autoFreeze_ = n;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(n) {
    this.useStrictShallowCopy_ = n;
  }
  applyPatches(n, e) {
    let t;
    for (t = e.length - 1; t >= 0; t--) {
      const i = e[t];
      if (i.path.length === 0 && i.op === "replace") {
        n = i.value;
        break;
      }
    }
    t > -1 && (e = e.slice(t + 1));
    const r = To("Patches").applyPatches_;
    return ko(n) ? r(n, e) : this.produce(
      n,
      (i) => r(i, e)
    );
  }
};
function jf(n, e) {
  const t = La(n) ? To("MapSet").proxyMap_(n, e) : Pa(n) ? To("MapSet").proxySet_(n, e) : i5(n, e);
  return (e ? e.scope_ : eb()).drafts_.push(t), t;
}
function a5(n) {
  return ko(n) || jt(10, n), nb(n);
}
function nb(n) {
  if (!Wi(n) || eu(n))
    return n;
  const e = n[Jn];
  let t;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, t = Wf(n, e.scope_.immer_.useStrictShallowCopy_);
  } else
    t = Wf(n, !0);
  return hs(t, (r, i) => {
    Qw(t, r, nb(i));
  }), e && (e.finalized_ = !1), t;
}
function l5() {
  process.env.NODE_ENV !== "production" && Xw.push(
    'Sets cannot have "replace" patches.',
    function(g) {
      return "Unsupported patch operation: " + g;
    },
    function(g) {
      return "Cannot apply patch, path doesn't resolve: " + g;
    },
    "Patching reserved attributes like __proto__, prototype and constructor is not allowed"
  );
  const e = "replace", t = "add", r = "remove";
  function i(g, v, m, w) {
    switch (g.type_) {
      case 0:
      case 2:
        return a(
          g,
          v,
          m,
          w
        );
      case 1:
        return o(g, v, m, w);
      case 3:
        return l(
          g,
          v,
          m,
          w
        );
    }
  }
  function o(g, v, m, w) {
    let { base_: b, assigned_: C } = g, M = g.copy_;
    M.length < b.length && ([b, M] = [M, b], [m, w] = [w, m]);
    for (let k = 0; k < b.length; k++)
      if (C[k] && M[k] !== b[k]) {
        const D = v.concat([k]);
        m.push({
          op: e,
          path: D,
          // Need to maybe clone it, as it can in fact be the original value
          // due to the base/copy inversion at the start of this function
          value: p(M[k])
        }), w.push({
          op: e,
          path: D,
          value: p(b[k])
        });
      }
    for (let k = b.length; k < M.length; k++) {
      const D = v.concat([k]);
      m.push({
        op: t,
        path: D,
        // Need to maybe clone it, as it can in fact be the original value
        // due to the base/copy inversion at the start of this function
        value: p(M[k])
      });
    }
    for (let k = M.length - 1; b.length <= k; --k) {
      const D = v.concat([k]);
      w.push({
        op: r,
        path: D
      });
    }
  }
  function a(g, v, m, w) {
    const { base_: b, copy_: C } = g;
    hs(g.assigned_, (M, k) => {
      const D = Zd(b, M), T = Zd(C, M), R = k ? va(b, M) ? e : t : r;
      if (D === T && R === e)
        return;
      const _ = v.concat(M);
      m.push(R === r ? { op: R, path: _ } : { op: R, path: _, value: T }), w.push(
        R === t ? { op: r, path: _ } : R === r ? { op: t, path: _, value: p(D) } : { op: e, path: _, value: p(D) }
      );
    });
  }
  function l(g, v, m, w) {
    let { base_: b, copy_: C } = g, M = 0;
    b.forEach((k) => {
      if (!C.has(k)) {
        const D = v.concat([M]);
        m.push({
          op: r,
          path: D,
          value: k
        }), w.unshift({
          op: t,
          path: D,
          value: k
        });
      }
      M++;
    }), M = 0, C.forEach((k) => {
      if (!b.has(k)) {
        const D = v.concat([M]);
        m.push({
          op: t,
          path: D,
          value: k
        }), w.unshift({
          op: r,
          path: D,
          value: k
        });
      }
      M++;
    });
  }
  function u(g, v, m, w) {
    m.push({
      op: e,
      path: [],
      value: v === Ih ? void 0 : v
    }), w.push({
      op: e,
      path: [],
      value: g
    });
  }
  function d(g, v) {
    return v.forEach((m) => {
      const { path: w, op: b } = m;
      let C = g;
      for (let T = 0; T < w.length - 1; T++) {
        const R = Oo(C);
        let _ = w[T];
        typeof _ != "string" && typeof _ != "number" && (_ = "" + _), (R === 0 || R === 1) && (_ === "__proto__" || _ === "constructor") && jt(16 + 3), typeof C == "function" && _ === "prototype" && jt(16 + 3), C = Zd(C, _), typeof C != "object" && jt(16 + 2, w.join("/"));
      }
      const M = Oo(C), k = h(m.value), D = w[w.length - 1];
      switch (b) {
        case e:
          switch (M) {
            case 2:
              return C.set(D, k);
            case 3:
              jt(16);
            default:
              return C[D] = k;
          }
        case t:
          switch (M) {
            case 1:
              return D === "-" ? C.push(k) : C.splice(D, 0, k);
            case 2:
              return C.set(D, k);
            case 3:
              return C.add(k);
            default:
              return C[D] = k;
          }
        case r:
          switch (M) {
            case 1:
              return C.splice(D, 1);
            case 2:
              return C.delete(D);
            case 3:
              return C.delete(m.value);
            default:
              return delete C[D];
          }
        default:
          jt(16 + 1, b);
      }
    }), g;
  }
  function h(g) {
    if (!Wi(g))
      return g;
    if (Array.isArray(g))
      return g.map(h);
    if (La(g))
      return new Map(
        Array.from(g.entries()).map(([m, w]) => [m, h(w)])
      );
    if (Pa(g))
      return new Set(Array.from(g).map(h));
    const v = Object.create(Eo(g));
    for (const m in g)
      v[m] = h(g[m]);
    return va(g, ea) && (v[ea] = g[ea]), v;
  }
  function p(g) {
    return ko(g) ? h(g) : g;
  }
  t5("Patches", {
    applyPatches_: d,
    generatePatches_: i,
    generateReplacementPatches_: u
  });
}
var Qn = new s5(), c5 = Qn.produce, u5 = Qn.produceWithPatches.bind(
  Qn
);
Qn.setAutoFreeze.bind(Qn);
Qn.setUseStrictShallowCopy.bind(Qn);
var r1 = Qn.applyPatches.bind(Qn);
Qn.createDraft.bind(Qn);
Qn.finishDraft.bind(Qn);
function d5(n) {
  const e = `<body>${n}</body>`;
  return new window.DOMParser().parseFromString(e, "text/html").body;
}
function f5(n, e) {
  return xo.fromSchema(e).parse(d5(n));
}
function h5(n, e) {
  return f5(n, e);
}
const p5 = (n) => (e, t) => {
  const r = e.tr, { doc: i } = r, o = h5(n, e.schema);
  return t ? (r.replaceWith(0, i.content.size, o), t(r), !0) : !1;
}, g5 = (n, e) => {
  const t = (r, { rootId: i, layers: o }, a = "ROOT") => {
    const l = (g, v) => ({
      id: Sr(),
      data: Yn({
        ...g,
        parent: v,
        child: []
      })
    }), u = l(o[i], a), h = ((g, v) => {
      const m = [];
      return o[g].child.forEach((w) => {
        const b = l(o[w], v);
        m.push([b.id, b]), u.data.child.push(b.id);
      }), m;
    })(i, u.id), p = Object.fromEntries([[u.id, u], ...h]);
    return Object.entries(p).forEach(([g, v]) => {
      n.pages[n.activePage].layers[g] = v;
    }), n.pages[r].layers[a].data.child.push(u.id), u;
  };
  return {
    setProp(r, i, o, a) {
      const l = [];
      Te.isArray(i) ? l.push(...i) : l.push(i), l.forEach((u) => {
        n.pages[r].layers[u].data.props = cr(
          n.pages[r].layers[u].data.props,
          o,
          a
        );
      });
    },
    moveSelectedLayers: (r, i) => {
      n.controlBox = void 0, n.selectedLayers[n.activePage].forEach((o) => {
        r === "right" ? n.pages[n.activePage].layers[o].data.props.position.x += i : r === "left" ? n.pages[n.activePage].layers[o].data.props.position.x -= i : r === "top" ? n.pages[n.activePage].layers[o].data.props.position.y -= i : r === "bottom" && (n.pages[n.activePage].layers[o].data.props.position.y += i);
      });
    },
    changePageSize: (r) => {
      const i = r.width - e.getPageSize().width, o = r.height - e.getPageSize().height, a = r.width / r.height;
      n.pages.forEach((l) => {
        Object.entries(l.layers).forEach(([, u]) => {
          if (!Fi(u) && dI(u) && (u.data.props.position.x += i / 2, u.data.props.position.y += o / 2), Fi(u) && (u.data.props.boxSize = r, u.data.props.image)) {
            const d = u.data.props.image.boxSize.width / u.data.props.image.boxSize.height;
            d > a ? (u.data.props.image.boxSize.height = r.height, u.data.props.image.boxSize.width = r.height * d) : (u.data.props.image.boxSize.width = r.width, u.data.props.image.boxSize.height = r.width / d), u.data.props.image.position.y = (r.height - u.data.props.image.boxSize.height) / 2, u.data.props.image.position.x = (r.width - u.data.props.image.boxSize.width) / 2;
          }
        });
      });
    },
    setScale: (r) => {
      n.scale = r;
    },
    setGuideline: ({
      vertical: r,
      horizontal: i
    }) => {
      n.guideline.vertical = r, n.guideline.horizontal = i;
    },
    selectLayers(r, i, o = "replace") {
      const a = typeof i == "object" ? i : [i];
      if (n.textEditor = void 0, n.imageEditor = void 0, r !== n.activePage && (n.selectedLayers = {}), o === "replace" || n.selectedLayers[r] && n.selectedLayers[r].includes("ROOT") || a.includes("ROOT")) {
        n.selectedLayers = {
          [r]: a
        };
        const l = n.hoveredLayer[r];
        l && a.includes(l) && (n.hoveredLayer = {
          [r]: null
        });
      } else
        n.selectedLayers[r] = Te.uniq([
          ...n.selectedLayers[r] || [],
          ...a
        ]);
      n.activePage = r;
    },
    selectAllLayers: () => {
      n.imageEditor = void 0, n.textEditor = void 0, n.selectedLayers = {
        [n.activePage]: Object.entries(
          n.pages[n.activePage].layers
        ).reduce((r, [i, o]) => (o.data.parent === "ROOT" && r.push(i), r), [])
      };
    },
    resetSelectLayer: () => {
      n.selectedLayers = {}, n.hoveredLayer = {}, n.textEditor = void 0, n.imageEditor = void 0;
    },
    hoverLayer: (r, i) => {
      n.hoveredLayer = {
        [r]: i
      };
    },
    setAlign(r) {
      const i = (l, u) => {
        const d = hr(
          u.data.props.boxSize,
          u.data.props.position,
          u.data.props.rotate
        );
        return r === "left" ? l.position.x - (u.data.props.boxSize.width - d.width) / 2 : r === "right" ? l.position.x + l.boxSize.width - d.width - (u.data.props.boxSize.width - d.width) / 2 : l.position.x + (l.boxSize.width - u.data.props.boxSize.width) / 2;
      }, o = (l, u) => {
        const d = hr(
          u.data.props.boxSize,
          u.data.props.position,
          u.data.props.rotate
        );
        return r === "top" ? l.position.y - (u.data.props.boxSize.height - d.height) / 2 : r === "bottom" ? l.position.y + l.boxSize.height - d.height - (u.data.props.boxSize.height - d.height) / 2 : l.position.y + (l.boxSize.height - u.data.props.boxSize.height) / 2;
      }, a = n.selectedLayers[n.activePage].map((l) => n.pages[n.activePage].layers[l]);
      if (a.length === 1)
        if (["left", "right", "center"].includes(r)) {
          const l = i(
            n.pages[n.activePage].layers.ROOT.data.props,
            a[0]
          );
          n.pages[n.activePage].layers[a[0].id].data.props.position.x = l, n.controlBox && (n.controlBox.position.x = l);
        } else {
          const l = o(
            n.pages[n.activePage].layers.ROOT.data.props,
            a[0]
          );
          n.pages[n.activePage].layers[a[0].id].data.props.position.y = l, n.controlBox && (n.controlBox.position.y = l);
        }
      else if (a.length > 1) {
        const l = a.reduce((h, p) => (h[p.id] = p.data.props, h), {}), u = oa(l), d = {};
        a.forEach((h) => {
          ["left", "right", "center"].includes(r) ? n.pages[n.activePage].layers[h.id].data.props.position.x = i(u, h) : n.pages[n.activePage].layers[h.id].data.props.position.y = o(u, h), d[h.id] = n.pages[n.activePage].layers[h.id].data.props;
        }), n.controlBox = oa(d);
      }
    },
    setTextEditor: (r, i, o) => {
      n.pages[r].layers[i].data.editor = o;
    },
    setData: (r) => {
      n.activePage = 0, n.selectedLayers = {}, n.hoveredLayer = {};
      const i = [], o = (a, l) => ({
        id: a.parent === null ? "ROOT" : Sr(),
        data: Yn({
          ...a,
          parent: l,
          child: []
        })
      });
      r.forEach((a) => {
        const l = {
          layers: {}
        };
        l.layers.ROOT = o(a.layers.ROOT, null);
        const u = (p, g) => {
          const v = [];
          return a.layers[p].child.forEach((m) => {
            const w = o(
              a.layers[m],
              g
            );
            v.push([w.id, w]), l.layers[w.id] = w, l.layers[g].data.child.push(w.id), a.layers[m].child.length > 0 && v.push(...u(m, w.id));
          }), v;
        }, d = u("ROOT", "ROOT"), h = Object.fromEntries(d);
        Object.entries(h).forEach(([p, g]) => {
          l.layers[p] = g;
        }), i.push(l);
      }), n.pages = i;
    },
    setPage: (r, i) => {
      const o = {
        layers: {}
      }, a = (h, p) => ({
        id: h.parent === null ? "ROOT" : Sr(),
        data: Yn({
          ...h,
          parent: p,
          child: []
        })
      });
      o.layers.ROOT = a(i.layers.ROOT, null);
      const l = (h, p) => {
        const g = [];
        return i.layers[h].child.forEach((v) => {
          const m = a(
            i.layers[v],
            p
          );
          g.push([m.id, m]), o.layers[m.id] = m, o.layers[p].data.child.push(m.id), i.layers[v].child.length > 0 && g.push(...l(v, m.id));
        }), g;
      }, u = l("ROOT", "ROOT"), d = Object.fromEntries(u);
      Object.entries(d).forEach(([h, p]) => {
        o.layers[h] = p;
      }), n.selectedLayers = {}, n.pages[r] = o;
    },
    setActivePage(r) {
      n.selectedLayers = {}, n.hoveredLayer = {}, n.textEditor = void 0, n.activePage = r;
    },
    deleteLayer: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i), n.selectedLayers[r] = n.selectedLayers[r].filter(
        (a) => !o.includes(a)
      ), o.forEach((a) => {
        const l = n.pages[r].layers[a].data.parent;
        delete n.pages[r].layers[a], l && n.pages[r].layers[l] && (n.pages[r].layers[l].data.child = n.pages[r].layers[l].data.child.filter((u) => u !== a));
      });
    },
    openTextEditor(r, i) {
      n.textEditor = {
        pageIndex: r,
        layerId: i,
        editor: null
      };
    },
    setOpeningEditor(r) {
      n.textEditor && (n.textEditor.editor = r);
    },
    closeTextEditor() {
      n.textEditor = void 0;
    },
    lockPage: (r) => {
      n.pages[r].layers.ROOT.data.locked = !0;
    },
    unlockPage: (r) => {
      n.pages[r].layers.ROOT.data.locked = !1;
    },
    deletePage: (r) => {
      n.selectedLayers = {}, n.hoveredLayer = {}, n.pages.splice(r, 1);
    },
    duplicatePage(r) {
      n.textEditor = void 0, n.imageEditor = void 0;
      const i = {
        layers: {}
      };
      Object.entries(
        Te.cloneDeep(Aa(n.pages[r].layers, "ROOT"))
      ).forEach(([o, a]) => {
        i.layers[o] = {
          id: o,
          data: Yn(a)
        };
      }), n.pages.splice(r, 0, i), n.activePage = r + 1, n.selectedLayers = {
        [r + 1]: ["ROOT"]
      };
    },
    addPage: (r) => {
      const i = {
        layers: {}
      };
      i.layers.ROOT = {
        id: "ROOT",
        data: Yn({
          type: {
            resolvedName: "RootLayer"
          },
          props: {
            boxSize: e.getPageSize(),
            position: {
              x: 0,
              y: 0
            },
            rotate: 0,
            color: "#fff",
            image: null
          },
          locked: !1,
          parent: null,
          child: []
        })
      }, typeof r < "u" ? (n.pages.splice(r + 1, 0, i), n.activePage = r + 1) : (n.pages.push(i), n.activePage = n.activePage + 1);
    },
    movePageUp: (r) => {
      const i = Te.cloneDeep(n.pages[r]);
      n.pages.splice(r, 1), n.pages.splice(r - 1, 0, i), n.activePage = r - 1;
    },
    movePageDown: (r) => {
      const i = Te.cloneDeep(n.pages[r]);
      n.pages.splice(r, 1), n.pages.splice(r + 1, 0, i), n.activePage = r + 1;
    },
    lock: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i), o.forEach((a) => {
        n.pages[r].layers[a].data.locked = !0;
      });
    },
    unlock: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i), o.forEach((a) => {
        n.pages[r].layers[a].data.locked = !1;
      });
    },
    ungroup(r) {
      const i = n.activePage, o = n.pages[n.activePage].layers, a = o[r], l = o[r].data.child, u = o[r].data.parent, d = o[u], h = l.reduce((g, v) => (g[v] = R1(
        a.data.props,
        o[v].data.props
      ), g), {}), p = d.data.child.indexOf(r);
      return l.forEach((g) => {
        const v = n.pages[i].layers[g];
        v.data.parent = "ROOT", v.data.props.position.x = h[g].x, v.data.props.position.y = h[g].y, v.data.props.rotate = h[g].rotate, v.data.props.boxSize.width = v.data.props.boxSize.width * a.data.props.scale, v.data.props.boxSize.height = v.data.props.boxSize.height * a.data.props.scale, ui(v) || Vi(v) ? v.data.props.scale = v.data.props.scale * a.data.props.scale : Jo(v) && (v.data.props.image.boxSize.width = v.data.props.image.boxSize.width * a.data.props.scale, v.data.props.image.boxSize.height = v.data.props.image.boxSize.height * a.data.props.scale, v.data.props.image.position.x = v.data.props.image.position.x * a.data.props.scale, v.data.props.image.position.y = v.data.props.image.position.y * a.data.props.scale);
      }), n.pages[i].layers[u].data.child.splice(p, 1), n.pages[i].layers[u].data.child.splice(
        p,
        0,
        ...l
      ), delete n.pages[i].layers[r], n.selectedLayers = {
        [i]: l
      }, l;
    },
    group(r) {
      const i = [], o = n.activePage, a = n.pages[n.activePage].layers;
      r.forEach((b) => {
        fs(a[b]) ? i.push(...this.ungroup(b)) : i.push(b);
      });
      const { left: l, right: u, top: d, bottom: h } = i.reduce(
        (b, C) => {
          const M = a[C].data.props, k = hr(
            M.boxSize,
            M.position,
            M.rotate
          );
          return (b.left === null || b.left > k.x) && (b.left = k.x), (b.right === null || b.right < k.x + k.width) && (b.right = k.x + k.width), (b.top === null || b.top > k.y) && (b.top = k.y), (b.bottom === null || b.bottom < k.y + k.height) && (b.bottom = k.y + k.height), b;
        },
        {
          left: null,
          right: null,
          top: null,
          bottom: null
        }
      ), p = {
        type: {
          resolvedName: "GroupLayer"
        },
        props: {
          position: {
            x: l,
            y: d
          },
          boxSize: {
            width: u - l,
            height: h - d
          },
          scale: 1,
          rotate: 0
        },
        locked: !1,
        hidden: !1,
        parent: "ROOT",
        child: i
      }, g = Sr(), v = Yn(p), m = a.ROOT.data.child;
      n.pages[o].layers[g] = { id: g, data: v }, i.sort((b, C) => m.indexOf(b) - m.indexOf(C));
      const w = n.pages[o].layers.ROOT.data.child.findLastIndex((b) => i.includes(b));
      return i.forEach((b) => {
        const C = n.pages[o].layers.ROOT.data.child.findIndex(
          (k) => k === b
        );
        n.pages[o].layers.ROOT.data.child.splice(C, 1), n.pages[o].layers[b].data.parent = g;
        const M = n.pages[o].layers[b].data.props;
        n.pages[o].layers[b].data.props.position.x = M.position.x - l, n.pages[o].layers[b].data.props.position.y = M.position.y - d;
      }), n.pages[o].layers.ROOT.data.child.splice(
        w - r.length + 1,
        0,
        g
      ), n.selectedLayers = {
        [o]: [g]
      }, g;
    },
    bringToFront: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i);
      const a = n.pages[r].layers.ROOT.data.child;
      o.sort((l, u) => a.indexOf(l) - a.indexOf(u)), o.forEach((l) => {
        const u = a.findIndex((d) => d === l);
        a.splice(u, 1), a.splice(a.length, 0, l);
      });
    },
    bringForward: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i);
      const a = n.pages[r].layers.ROOT.data.child, l = a.findLastIndex((u) => o.includes(u));
      o.sort((u, d) => a.indexOf(u) - a.indexOf(d)), o.forEach((u) => {
        const d = a.findIndex((h) => h === u);
        a.splice(d, 1), a.splice(l + 1, 0, u);
      });
    },
    sendToBack: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i);
      const a = n.pages[r].layers.ROOT.data.child;
      o.sort((l, u) => a.indexOf(u) - a.indexOf(l)), o.forEach((l) => {
        const u = a.findIndex((d) => d === l);
        a.splice(u, 1), a.splice(0, 0, l);
      });
    },
    sendBackward: (r, i) => {
      const o = [];
      typeof i == "object" ? o.push(...i) : o.push(i);
      const a = n.pages[r].layers.ROOT.data.child, l = a.findIndex((u) => o.includes(u));
      o.sort((u, d) => a.indexOf(d) - a.indexOf(u)), o.forEach((u) => {
        const d = a.findIndex((h) => h === u);
        a.splice(d, 1), a.splice(l - 1, 0, u);
      });
    },
    moveLayerPosition: (r, i, o) => {
      const a = n.pages[r].layers.ROOT.data.child, l = a.findIndex((u) => u === i);
      l !== -1 && (a.splice(l, 1), a.splice(o, 0, i));
    },
    setFontList(r) {
      n.fontList = r;
    },
    appendFontList(r) {
      n.fontList.push(...r);
    },
    addLayer(r, i = "ROOT") {
      const o = Sr(), a = Yn({
        ...r,
        locked: !1,
        parent: i,
        child: []
      });
      n.pages[n.activePage].layers[o] = {
        id: o,
        data: cr(a, {
          props: {
            position: ao(
              e.getPageSize(),
              a.props.boxSize
            )
          }
        })
      }, n.pages[n.activePage].layers[i].data.child.push(o), this.selectLayers(n.activePage, o);
    },
    addShapeLayer(r, i = "ROOT") {
      const o = Sr(), a = Yn({
        ...r,
        locked: !1,
        parent: i,
        child: []
      }), l = e.getPageSize().width / e.getPageSize().height, u = a.props.boxSize.width / a.props.boxSize.height;
      let d = 1, h = a.props.boxSize.width, p = a.props.boxSize.height;
      const g = 0.3;
      u > l ? (h = e.getPageSize().width * g, p = h / u, d = h / a.props.boxSize.width) : (p = e.getPageSize().height * g, h = p * u, d = p / a.props.boxSize.height), n.pages[n.activePage].layers[o] = {
        id: o,
        data: cr(Te.cloneDeep(a), {
          props: {
            boxSize: { width: h, height: p },
            position: ao(
              e.getPageSize(),
              a.props.boxSize
            ),
            scale: d
          }
        })
      }, n.pages[n.activePage].layers[i].data.child.push(o), this.selectLayers(n.activePage, o);
    },
    addLineLayer(r, i = "ROOT") {
      const o = Sr(), a = e.getPageSize().width / 2, l = Yn(
        cr(
          {
            props: {
              boxSize: {
                width: a,
                height: 4
              },
              position: {
                x: 0,
                y: 0
              },
              style: "solid",
              color: "rgb(0, 0, 0)",
              scale: 1,
              rotate: 0
            },
            type: {
              resolvedName: "LineLayer"
            },
            locked: !1,
            parent: i,
            child: []
          },
          r
        )
      );
      n.pages[n.activePage].layers[o] = {
        id: o,
        data: cr(Te.cloneDeep(l), {
          props: {
            position: ao(
              e.getPageSize(),
              l.props.boxSize
            )
          }
        })
      }, n.pages[n.activePage].layers[i].data.child.push(o), this.selectLayers(n.activePage, o);
    },
    addImageLayer({ thumb: r, url: i }, o, a = "ROOT") {
      const l = Sr(), u = e.getPageSize(), d = u.width / u.height, h = o.width / o.height, p = d < h ? u.width * 0.8 : u.height * h * 0.8, g = p / h, v = Yn({
        type: {
          resolvedName: "ImageLayer"
        },
        props: {
          image: {
            url: i,
            thumb: r,
            boxSize: {
              width: p,
              height: g
            },
            position: {
              x: 0,
              y: 0
            },
            rotate: 0
          },
          position: {
            x: 0,
            y: 0
          },
          boxSize: {
            width: p,
            height: g
          },
          rotate: 0
        },
        locked: !1,
        parent: a,
        child: []
      });
      n.pages[n.activePage].layers[l] = {
        id: l,
        data: cr(v, {
          props: {
            position: ao(
              e.getPageSize(),
              v.props.boxSize
            )
          }
        })
      }, n.pages[n.activePage].layers[a].data.child.push(l), this.selectLayers(n.activePage, l);
    },
    addSvgLayer(r, i, o, a = "ROOT") {
      const l = Sr(), u = e.getPageSize(), d = u.width / u.height, h = i.width / i.height, p = d < h ? u.width * 0.5 : u.height * h * 0.5, g = p / h, v = [], m = o.querySelectorAll(
        "path, circle, ellipse,line, rect, polygon,polyline, text"
      );
      for (let b = 0; b < m.length; b++) {
        const C = m[b].getAttribute("style");
        let M = m[b].getAttribute("stroke") || "none", k = m[b].getAttribute("fill") || "#000000";
        const D = {};
        C && C.split(";").filter((R) => !!R).forEach((R) => {
          const [_, Z] = R.split(":");
          D[_.trim()] = Z.trim();
        }), D.stroke && (M = D.stroke), D.fill && (k = D.fill), M && !["none", "currentcolor"].includes(M.toLowerCase()) && !/url\((.*?)\)/.test(M) && !v.includes(new Nt(M).toRgbString()) ? v.push(new Nt(M).toRgbString()) : k && !["none", "currentcolor"].includes(k.toLowerCase()) && !/url\((.*?)\)/.test(k) && !v.includes(new Nt(k).toRgbString()) && v.push(new Nt(k).toRgbString());
      }
      const w = Yn({
        type: {
          resolvedName: "SvgLayer"
        },
        props: {
          image: r,
          position: {
            x: 0,
            y: 0
          },
          boxSize: {
            width: p,
            height: g
          },
          colors: v,
          rotate: 0
        },
        locked: !1,
        parent: a,
        child: []
      });
      n.pages[n.activePage].layers[l] = {
        id: l,
        data: cr(w, {
          props: {
            position: ao(
              e.getPageSize(),
              w.props.boxSize
            )
          }
        })
      }, n.pages[n.activePage].layers[a].data.child.push(l), this.selectLayers(n.activePage, l);
    },
    addFrameLayer(r, i, o = "ROOT") {
      const a = Sr(), l = e.getPageSize(), u = l.width / l.height, d = r.width / r.height, h = u > d ? l.height * 0.5 / r.height : l.width * 0.5 / r.width, p = Yn({
        type: {
          resolvedName: "FrameLayer"
        },
        props: {
          clipPath: i,
          position: {
            x: 0,
            y: 0
          },
          boxSize: {
            width: r.width * h,
            height: r.height * h
          },
          rotate: 0,
          scale: h
        },
        locked: !1,
        parent: o,
        child: []
      });
      n.pages[n.activePage].layers[a] = {
        id: a,
        data: cr(p, {
          props: {
            position: ao(
              e.getPageSize(),
              p.props.boxSize
            )
          }
        })
      }, n.pages[n.activePage].layers[o].data.child.push(a), this.selectLayers(n.activePage, a);
    },
    addVideoLayer({ url: r }, i, o = "ROOT") {
      const a = Sr(), l = e.getPageSize(), u = l.width / l.height, d = i.width / i.height, h = u < d ? l.width * 0.8 : l.height * d * 0.8, p = h / d, g = Yn({
        type: {
          resolvedName: "VideoLayer"
        },
        props: {
          video: {
            url: r,
            boxSize: {
              width: h,
              height: p
            },
            position: {
              x: 0,
              y: 0
            },
            rotate: 0
          },
          position: {
            x: 0,
            y: 0
          },
          boxSize: {
            width: h,
            height: p
          },
          rotate: 0
        },
        locked: !1,
        parent: o,
        child: []
      });
      n.pages[n.activePage].layers[a] = {
        id: a,
        data: cr(g, {
          props: {
            position: ao(
              e.getPageSize(),
              g.props.boxSize
            )
          }
        })
      }, n.pages[n.activePage].layers[o].data.child.push(a), this.selectLayers(n.activePage, a);
    },
    addLayerTree({ layers: r, rootId: i }) {
      const o = t(n.activePage, { layers: r, rootId: i });
      this.selectLayers(n.activePage, o.id);
    },
    addLayerTrees(r) {
      const i = [], o = r.map((a) => {
        const l = t(n.activePage, a);
        return i.push(l.id), l;
      });
      return this.selectLayers(n.activePage, i), o;
    },
    showContextMenu: ({ clientX: r, clientY: i }) => {
      n.openMenu = {
        clientX: r,
        clientY: i
      };
    },
    hideContextMenu: () => {
      n.openMenu = null;
    },
    setSelectData: (r) => {
      n.selectData.status = r;
    },
    setResizeData: (r, i, o, a, l, u) => {
      n.resizeData = {
        status: r,
        layerIds: i,
        direction: o,
        rotate: a,
        boxSize: l,
        cursor: u
      };
    },
    setRotateData: (r, i) => {
      n.rotateData = {
        status: r,
        rotate: i
      };
    },
    setDragData: (r, i) => {
      n.dragData = {
        status: r,
        layerIds: i
      };
    },
    setUpdateLineData: (r, i, o) => {
      n.updateLineData = {
        status: r,
        layerId: i,
        linePosition: o
      };
    },
    setControlBox: (r) => {
      n.controlBox = r;
    },
    setSidebar: (r) => {
      n.sidebar = r || null;
    },
    openImageEditor(r, i, {
      boxSize: o,
      position: a,
      rotate: l,
      image: u,
      video: d
    }) {
      n.imageEditor = Te.cloneDeep({
        pageIndex: r,
        layerId: i,
        boxSize: o,
        position: a,
        rotate: l,
        image: u,
        video: d
      });
    },
    updateImageEditor(r) {
      n.imageEditor && (n.imageEditor = cr(n.imageEditor, r));
    },
    closeImageEditor() {
      const r = n.imageEditor;
      if (r) {
        const i = n.pages[r.pageIndex].layers[r.layerId];
        n.pages[r.pageIndex].layers[r.layerId].data.props = cr(
          n.pages[r.pageIndex].layers[r.layerId].data.props,
          {
            boxSize: r.boxSize,
            position: r.position,
            rotate: r.rotate,
            image: r.image ? {
              boxSize: {
                width: r.image.boxSize.width / (i.data.props.scale || 1),
                height: r.image.boxSize.height / (i.data.props.scale || 1)
              },
              position: {
                x: r.image.position.x / (i.data.props.scale || 1),
                y: r.image.position.y / (i.data.props.scale || 1)
              },
              rotate: r.image.rotate
            } : void 0,
            video: r.video ? {
              boxSize: {
                width: r.video.boxSize.width / (i.data.props.scale || 1),
                height: r.video.boxSize.height / (i.data.props.scale || 1)
              },
              position: {
                x: r.video.position.x / (i.data.props.scale || 1),
                y: r.video.position.y / (i.data.props.scale || 1)
              },
              rotate: r.video.rotate
            } : void 0
          }
        );
      }
      n.imageEditor = void 0;
    }
  };
}, m5 = (n) => n.map((e) => ({
  layers: Aa(e.layers, "ROOT")
})), v5 = (n) => ({
  getPageSize() {
    return n.pages[0] && n.pages[0].layers.ROOT.data.props.boxSize || {
      width: 0,
      height: 0
    };
  },
  serialize() {
    return m5(n.pages);
  },
  getLayers(e) {
    return n.pages[e] && n.pages[e].layers;
  },
  getLayer(e, t) {
    const r = n.pages[e] && n.pages[e].layers;
    if (r)
      return r[t];
  }
}), bt = {
  UNDO: "HISTORY_UNDO",
  REDO: "HISTORY_REDO",
  THROTTLE: "HISTORY_THROTTLE",
  IGNORE: "HISTORY_IGNORE",
  MERGE: "HISTORY_MERGE",
  CLEAR: "HISTORY_CLEAR",
  NEW: "HISTORY_NEW",
  BACK: "HISTORY_BACK"
};
class y5 {
  constructor() {
    this.timeline = [], this.pointer = -1;
  }
  add(e, t) {
    this.pointer = this.pointer + 1, this.timeline.length = this.pointer, this.timeline[this.pointer] = {
      patches: e,
      inversePatches: t,
      timestamp: Date.now()
    };
  }
  throttleAdd(e, t, r = 500) {
    if (this.timeline.length && this.pointer >= 0) {
      const {
        patches: i,
        inversePatches: o,
        timestamp: a
      } = this.timeline[this.pointer];
      if ((/* @__PURE__ */ new Date()).getTime() - a < r) {
        this.timeline[this.pointer] = {
          timestamp: a,
          patches: [...i, ...e],
          inversePatches: [...t, ...o]
        };
        return;
      }
    }
    this.add(e, t);
  }
  back() {
    this.canUndo() && (this.timeline.splice(this.pointer, 1), this.pointer = this.pointer - 1);
  }
  merge(e, t) {
    if (!(e.length === 0 && t.length === 0)) {
      if (this.timeline.length && this.pointer >= 0) {
        const {
          patches: r,
          inversePatches: i,
          timestamp: o
        } = this.timeline[this.pointer];
        this.timeline[this.pointer] = {
          timestamp: o,
          patches: [...r, ...e],
          inversePatches: [...t, ...i]
        };
        return;
      }
      this.add(e, t);
    }
  }
  clear() {
    this.timeline = [], this.pointer = -1;
  }
  canUndo() {
    return this.pointer >= 0;
  }
  canRedo() {
    return this.pointer < this.timeline.length - 1;
  }
  undo(e) {
    if (!this.canUndo())
      return;
    const { inversePatches: t } = this.timeline[this.pointer];
    this.pointer = this.pointer - 1;
    const r = t.filter((i) => i.path[0] !== "textEditor");
    return r1(e, r);
  }
  redo(e) {
    if (!this.canRedo())
      return;
    this.pointer = this.pointer + 1;
    const { patches: t } = this.timeline[this.pointer], r = t.filter((i) => i.path[0] !== "textEditor");
    return r1(e, r);
  }
}
l5();
const Fl = [
  "hoverLayer",
  "selectLayers",
  "setControlBox",
  "setScale",
  "setEditing",
  "selectAllLayers",
  "resetSelectLayer",
  "hoverLayer",
  "setTextEditor",
  "setData",
  "showContextMenu",
  "hideContextMenu",
  "setResizeData",
  "setRotateData",
  "setDragData",
  "setSelectData",
  "setSidebar",
  "imageEditor"
], w5 = [
  "setProp",
  "ungroup",
  "group",
  "setHidden",
  "lock",
  "unlock",
  "lockPage",
  "unlockPage",
  "deletePage",
  "duplicatePage",
  "addPage",
  "movePageUp",
  "movePageDown",
  "bringForward",
  "sendBackward",
  "bringToFront",
  "sendToBack",
  "addLayer",
  "addImageLayer",
  "addFrameLayer",
  "addLayerTree",
  "deleteLayer"
], b5 = () => {
  const n = pe(() => new y5(), []), e = ge(), t = Ie(() => e.current, []), r = g5, i = pe(() => {
    const h = v5;
    return Object.keys(h()).reduce((p, g) => ({
      ...p,
      [g]: (...v) => {
        const m = h(t())[g];
        return m(...v);
      }
    }), {});
  }, [t]), o = pe(() => ({
    ...i,
    history: {
      canUndo() {
        return n.canUndo();
      },
      canRedo() {
        return n.canRedo();
      }
    }
  }), [i, n]), [a] = pe(() => [
    (h, p) => {
      let g;
      const [v, m, w] = u5(h, (b) => {
        switch (p.type) {
          case bt.NEW:
            break;
          case bt.BACK:
            n.back();
            break;
          case bt.UNDO:
            return n.undo(b);
          case bt.REDO:
            return n.redo(b);
          case bt.CLEAR:
            return n.clear(), {
              ...b
            };
          case bt.IGNORE:
          case bt.MERGE:
          case bt.THROTTLE:
            const [C, ...M] = p.payload;
            r(b, o)[C](...M);
            break;
          default:
            r(b, o)[p.type](...p.payload);
        }
      });
      return g = v, [bt.UNDO, bt.REDO].includes(
        p.type
      ) && (g = c5(g, (b) => {
        b.pages.forEach((C) => {
          Object.entries(C.layers).forEach(([, M]) => {
            const k = M;
            if (ui(k)) {
              const D = k.data.editor;
              D && p5(k.data.props.text)(
                D.state,
                D.dispatch
              );
            }
          });
        }), b.textEditor = void 0, b.selectedLayers = {}, b.hoveredLayer = {}, b.controlBox = void 0;
      })), [
        ...Fl,
        bt.UNDO,
        bt.REDO,
        bt.CLEAR,
        bt.IGNORE,
        bt.NEW
      ].includes(p.type) || (p.type === bt.THROTTLE ? n.throttleAdd(
        m,
        w,
        p.config && p.config.rate
      ) : w5.includes(p.type) ? n.add(m, w) : n.merge(m, w)), bt.NEW === p.type && n.add(m, w), bt.MERGE === p.type && n.merge(m, w), bt.THROTTLE === p.type && n.throttleAdd(m, w), g;
    }
  ], [n, r, o]), [l, u] = Lc(a, {
    selectedLayers: {},
    hoveredLayer: {},
    openMenu: null,
    scale: 1,
    activePage: 0,
    pages: [],
    fontList: [],
    guideline: {
      vertical: [],
      horizontal: []
    },
    sidebar: null,
    resizeData: {
      status: !1
    },
    dragData: {
      status: !1
    },
    rotateData: {
      status: !1
    },
    updateLineData: {
      status: !1
    },
    selectData: {
      status: !1
    }
  }), d = pe(() => {
    const h = Object.keys(r(null));
    return { ...h.reduce((v, m) => (v[m] = (...w) => u({ type: m, payload: w }), v), {}), history: {
      new() {
        u({
          type: bt.NEW
        });
      },
      undo() {
        return u({
          type: bt.UNDO
        });
      },
      redo() {
        return u({
          type: bt.REDO
        });
      },
      clear: () => u({
        type: bt.CLEAR
      }),
      back: () => u({
        type: bt.BACK
      }),
      ignore: () => h.filter((v) => !Fl.includes(v)).reduce((v, m) => (v[m] = (...w) => u({
        type: bt.IGNORE,
        payload: [m, ...w]
      }), v), {}),
      throttle: (v) => h.filter((m) => !Fl.includes(m)).reduce((m, w) => (m[w] = (...b) => u({
        type: bt.THROTTLE,
        payload: [w, ...b],
        config: {
          rate: v
        }
      }), m), {}),
      merge: () => h.filter((v) => !Fl.includes(v)).reduce((v, m) => (v[m] = (...w) => u({
        type: bt.MERGE,
        payload: [m, ...w]
      }), v), {})
    } };
  }, [r]);
  return e.current = l, pe(
    () => ({
      getState: t,
      actions: d,
      query: o
    }),
    [d, t, o]
  );
}, MP = ({
  getFonts: n,
  config: e,
  children: t
}) => {
  const { getState: r, actions: i, query: o } = b5();
  return /* @__PURE__ */ x(
    di.Provider,
    {
      value: { config: e, getState: r, actions: i, query: o, getFonts: n },
      children: t
    }
  );
};
var x5 = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M165.66 202.34a8 8 0 0 1-11.32 11.32l-80-80a8 8 0 0 1 0-11.32l80-80a8 8 0 0 1 11.32 11.32L91.31 128Z"
    })
  }));
};
let i1;
const RP = () => {
  const { pages: n, pageSize: e } = je((u, d) => ({
    pages: u.pages,
    pageSize: d.getPageSize()
  })), [t, r] = Le(0), [i, o] = Le({ width: 0, height: 0, scale: 1 }), { usedFonts: a } = Jc(), l = Ie(
    (u) => {
      r((d) => {
        const h = (d + u) % n.length;
        return h >= 0 ? h : n.length + h;
      });
    },
    [r, n.length]
  );
  return be(() => (i1 = setTimeout(() => {
    l(1);
  }, 5e3), () => {
    clearTimeout(i1);
  }), [l, t]), be(() => {
    const u = () => {
      const { clientWidth: d, clientHeight: h } = window.document.body, p = d / h, g = e.width / e.height;
      if (p > g) {
        const v = h * g;
        o({
          width: v,
          height: h,
          scale: v / e.width
        });
      } else {
        const v = d, m = v / g;
        o({
          width: v,
          height: m,
          scale: v / e.width
        });
      }
    };
    return u(), window.addEventListener("resize", u), () => {
      window.removeEventListener("resize", u);
    };
  }, [e]), i.width === 0 ? null : /* @__PURE__ */ W(
    "div",
    {
      css: {
        position: "relative",
        width: "100%",
        height: "100%",
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: [
        /* @__PURE__ */ x(I1, { fonts: a }),
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              position: "absolute",
              top: "50%",
              transform: "translate(0, -50%)",
              left: "16px",
              zIndex: 1050
            },
            children: /* @__PURE__ */ x(
              "div",
              {
                css: {
                  border: "1px solid #fff",
                  background: "rgba(255,255,255,0.3)",
                  width: 60,
                  height: 60,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: 32,
                  color: "#fff",
                  borderRadius: "50%",
                  cursor: "pointer"
                },
                onClick: () => l(-1),
                children: /* @__PURE__ */ x(x5, {})
              }
            )
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              position: "absolute",
              top: "50%",
              transform: "translate(0, -50%)",
              right: "16px",
              zIndex: 1050
            },
            children: /* @__PURE__ */ x(
              "div",
              {
                css: {
                  border: "1px solid #fff",
                  background: "rgba(255,255,255,0.3)",
                  width: 60,
                  height: 60,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "center",
                  fontSize: 32,
                  color: "#fff",
                  borderRadius: "50%",
                  cursor: "pointer"
                },
                onClick: () => l(1),
                children: /* @__PURE__ */ x(Nw, {})
              }
            )
          }
        ),
        /* @__PURE__ */ x("div", { css: { width: i.width, height: i.height }, children: /* @__PURE__ */ x("div", { css: { position: "relative" }, children: n.map((u, d) => /* @__PURE__ */ x("div", { children: /* @__PURE__ */ x(
          Vw,
          {
            height: e.height,
            isActive: t === d,
            pageIndex: d,
            scale: i.scale,
            width: e.width
          }
        ) }, d)) }) })
      ]
    }
  );
};
var S5 = function(e) {
  return /* @__PURE__ */ Pc("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 15 15",
    width: "1em",
    height: "1em"
  }, e, {
    children: [/* @__PURE__ */ q("path", {
      d: "M0 0h3v3H0zM0 6h3v3H0zM0 12h3v3H0z"
    }), /* @__PURE__ */ q("path", {
      opacity: 0.75,
      d: "M3 9h3v3H3zM3 3h3v3H3z"
    }), /* @__PURE__ */ q("path", {
      opacity: 0.5,
      d: "M6 0h3v3H6zM6 6h3v3H6zM6 12h3v3H6z"
    }), /* @__PURE__ */ q("path", {
      opacity: 0.35,
      d: "M9 3h3v3H9zM9 9h3v3H9z"
    }), /* @__PURE__ */ q("path", {
      opacity: 0.15,
      d: "M12 12h3v3h-3zM12 6h3v3h-3zM12 0h3v3h-3z"
    })]
  }));
};
const C5 = ({ open: n, children: e, anchorEl: t, placement: r = "bottom-end", onClose: i, offsets: o }, a) => {
  const l = _c(a), u = ge(null), [d, h] = Le({ x: -9999, y: -9999 }), [p, g] = Le({ x: -9999, y: -9999 });
  be(() => {
    const m = Te.throttle(() => {
      if (t) {
        const w = t.getBoundingClientRect(), [b] = r.split("-"), C = {
          x: w.x,
          y: w.y
        };
        b === "right" && (C.x += w.width), b === "bottom" && (C.y += w.height), b === "top" && (C.y -= w.height), b === "left" && (C.x -= w.width), h(C);
      }
    }, 16);
    return m(), window.addEventListener("resize", m), () => {
      window.removeEventListener("resize", m);
    };
  }, [t, n, r]), be(() => {
    const m = (w) => {
      const b = l.current;
      let C = !0;
      if (b)
        for (let M = 0; M < b.children.length; M++)
          b.children[M].contains(w.target) && (C = !1);
      C && i();
    };
    return window.addEventListener("mousedown", m, { capture: !0 }), () => {
      window.removeEventListener("mousedown", m, { capture: !0 });
    };
  }, [l, i]), be(() => {
    const m = () => {
      var M;
      const [b, C] = r.split("-");
      if (t) {
        const k = (M = u.current) == null ? void 0 : M.getBoundingClientRect(), D = t.getBoundingClientRect(), T = {
          x: 0,
          y: 0
        };
        b === "top" ? (T.y = -k.height + D.height, C === "end" && (T.x = -k.width + D.width)) : b === "bottom" && C === "end" && (T.x = -k.width + D.width), g(T);
      } else
        g({ x: 0, y: 0 });
    }, w = new MutationObserver(m);
    return u.current && w.observe(u.current, {
      subtree: !0,
      childList: !0,
      attributes: !0
    }), () => {
      w.disconnect();
    };
  }, [r, t]);
  const v = pe(() => {
    if (o && o[r]) {
      const m = o[r];
      return {
        x: d.x + m.x,
        y: d.y + m.y
      };
    } else
      return d;
  }, [o, r, d]);
  return /* @__PURE__ */ x(
    "div",
    {
      ref: l,
      css: {
        position: "fixed",
        top: 0,
        left: 0,
        zIndex: 1040
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          ref: u,
          css: {
            position: "absolute",
            top: v.y,
            left: v.x,
            transform: `translate(${p.x}px, ${p.y}px)`,
            boxShadow: "0 0 0 1px rgba(64,87,109,.07),0 2px 12px rgba(53,71,90,.2)",
            borderRadius: 4
          },
          children: /* @__PURE__ */ x("div", { css: { background: "#fff" }, children: e })
        }
      )
    }
  );
}, E5 = Yt(
  C5
), k5 = ({ open: n, children: e, element: t, ...r }, i) => {
  const [o] = Le(window.document.createElement("div"));
  be(() => (!t && window.document.body.appendChild(o), () => {
    !t && window.document.body.removeChild(o);
  }), [t, o, n]);
  const a = /* @__PURE__ */ x(E5, { ref: i, open: n, ...r, children: e });
  return n ? A1.createPortal(a, t || o) : null;
}, gr = Yt(k5), Hi = ({
  label: n,
  min: e = 0,
  max: t = 100,
  step: r = 1,
  defaultValue: i,
  value: o,
  hideLabel: a,
  hideInput: l,
  onChange: u
}) => {
  const d = ge(null), h = ge(null), p = ge(null), g = ge({
    startPoint: 0,
    startValue: 0
  }), [v, m] = Le(0), [w, b] = Le(i || o || 0), [C, M] = Le(!1);
  be(() => {
    o !== void 0 && (b(o), h.current && (h.current.value = `${o}`));
  }, [o]), be(() => {
    if (e < 0) {
      const Q = t - e, ie = -e / Q * 100;
      m(ie);
    }
  }, [e, t]);
  const k = (Q) => {
    var ie;
    const ee = (ie = d.current) == null ? void 0 : ie.getBoundingClientRect();
    return Q - ee.x;
  }, D = (Q) => {
    var re;
    b(Q);
    const ee = (r + "").split("."), ie = parseFloat(
      (Math.round(Q / r) * r).toFixed(((re = ee[1]) == null ? void 0 : re.length) || 0)
    );
    h.current && (h.current.value = ie + ""), u && u(ie);
  }, T = (Q) => {
    var re;
    const ie = ((re = d.current) == null ? void 0 : re.getBoundingClientRect()).width / (t - e);
    return Q / ie;
  }, R = Te.throttle((Q) => {
    const { clientX: ee } = Wt(Q), ie = ee - g.current.startPoint, re = Math.max(
      e,
      Math.min(t, g.current.startValue + T(ie))
    );
    D(re);
  }, 16), _ = (Q) => {
    const { clientX: ee } = Wt(Q), ie = ee - g.current.startPoint;
    if (ie) {
      const re = Math.max(
        e,
        Math.min(t, g.current.startValue + T(ie))
      );
      D(re);
    }
    K();
  }, Z = () => {
    M(!0), window.addEventListener("touchmove", R), window.addEventListener("mousemove", R), window.addEventListener("mouseup", _, { once: !0 }), window.addEventListener("mouseleave", _, { once: !0 }), window.addEventListener("touchend", _, { once: !0 });
  }, K = () => {
    M(!1), window.removeEventListener("touchmove", R), window.removeEventListener("mousemove", R), window.removeEventListener("mouseup", _), window.removeEventListener("mouseleave", _), window.removeEventListener("touchend", _);
  }, $ = (Q) => {
    const { clientX: ee } = Wt(Q.nativeEvent), ie = k(ee), re = T(ie);
    g.current.startPoint = ee, g.current.startValue = e + re, D(e + re), Z();
  }, F = () => {
    if (h.current) {
      const Q = Math.max(
        e,
        Math.min(t, parseInt(h.current.value, 10))
      );
      h.current.blur(), D(Q);
    }
  };
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        display: "grid",
        gridColumnGap: 16,
        gridRowGap: 8,
        gridTemplateColumns: "1fr auto",
        alignItems: "center"
      },
      children: [
        !a && /* @__PURE__ */ x(
          "div",
          {
            css: {
              fontSize: 14,
              textTransform: "capitalize",
              whiteSpace: "nowrap"
            },
            children: n
          }
        ),
        !l && /* @__PURE__ */ x(
          "div",
          {
            css: {
              background: "#fff",
              border: "1px solid rgba(43,59,74,.3)",
              width: 40,
              height: 24,
              borderRadius: 4,
              overflow: "hidden"
            },
            children: /* @__PURE__ */ x(
              "input",
              {
                ref: h,
                css: {
                  width: "100%",
                  height: "100%",
                  padding: 2,
                  textAlign: "center"
                },
                defaultValue: w,
                onBlur: F,
                onKeyDown: (Q) => {
                  Q.key.toLowerCase() === "enter" && F();
                }
              }
            )
          }
        ),
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              height: 16,
              position: "relative",
              width: "100%",
              gridRow: l && a ? 1 : "2/auto",
              gridColumn: "1/-1"
            },
            onMouseDown: $,
            onTouchStart: $,
            children: [
              /* @__PURE__ */ x(
                "div",
                {
                  ref: d,
                  css: {
                    width: "100%",
                    position: "absolute",
                    left: 0,
                    top: "50%",
                    transform: "translateY(-50%)",
                    height: 2,
                    borderRadius: 2,
                    cursor: "pointer",
                    backgroundColor: "#bbbbbb"
                  }
                }
              ),
              v > 0 && /* @__PURE__ */ W(
                "div",
                {
                  css: {
                    position: "absolute",
                    top: "50%",
                    width: "100%",
                    transform: "translateY(-50%)",
                    display: "inline-flex"
                  },
                  children: [
                    /* @__PURE__ */ x(
                      "div",
                      {
                        css: {
                          width: `calc(${v}% - 2px)`,
                          maxWidth: "calc(100% - 4px)"
                        }
                      }
                    ),
                    /* @__PURE__ */ x(
                      "div",
                      {
                        css: {
                          width: 4,
                          height: 4,
                          transform: "translateY(-6px)",
                          borderRadius: "50%",
                          background: "#bbbbbb"
                        }
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ x(
                "div",
                {
                  ref: p,
                  css: { position: "absolute", top: "50%" },
                  style: {
                    width: `${(Math.abs(w) - (e > 0 ? e : 0)) / (t - e) * 100}%`,
                    marginLeft: `${Math.min(
                      v,
                      v + w / (t - e) * 100
                    )}%`,
                    transform: `scaleX(${w >= 0 ? 1 : -1})`
                  },
                  children: /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        backgroundColor: "#3d8eff",
                        width: "100%",
                        height: 2,
                        transform: "translateY(-50%)",
                        position: "absolute",
                        borderRadius: 2
                      },
                      children: /* @__PURE__ */ W(
                        "div",
                        {
                          css: {
                            width: 16,
                            height: 16,
                            transform: "translate(-50%, -50%)",
                            background: "#fff",
                            left: "100%",
                            position: "absolute"
                          },
                          onMouseDown: $,
                          onTouchStart: $,
                          children: [
                            /* @__PURE__ */ x(
                              "div",
                              {
                                css: {
                                  position: "absolute",
                                  borderRadius: "50%",
                                  width: 16,
                                  height: 16,
                                  transform: C ? " scale(1.125)" : void 0,
                                  border: C ? "1px solid #3d8eff" : "1px solid #5E6278"
                                }
                              }
                            ),
                            /* @__PURE__ */ x(
                              "div",
                              {
                                css: {
                                  position: "absolute",
                                  borderRadius: "50%",
                                  width: 16,
                                  height: 16,
                                  boxShadow: C ? "0 0 0 8px #3d8eff" : "0 0 4px 1px #bbbbbb",
                                  opacity: C ? 0.5 : 1
                                }
                              }
                            )
                          ]
                        }
                      )
                    }
                  )
                }
              )
            ]
          }
        )
      ]
    }
  );
}, O5 = ({ children: n, isActive: e, disabled: t, onClick: r, ...i }, o) => /* @__PURE__ */ x(
  "div",
  {
    ref: o,
    css: {
      position: "relative",
      display: "flex",
      alignItems: "center",
      justifyContent: "center",
      borderRadius: 4,
      height: 32,
      padding: "0 4px",
      cursor: t ? "not-allowed" : "pointer",
      backgroundColor: e ? "rgba(57,76,96,.15)" : "#fff",
      color: t ? "rgba(36,49,61,.4)" : void 0,
      whiteSpace: "nowrap",
      ":hover": {
        backgroundColor: t ? void 0 : "rgba(64,87,109,.07)"
      }
    },
    onClick: (a) => !t && r && r(a),
    ...i,
    children: n
  }
), Dt = Yt(O5);
function T5() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return pe(
    () => (r) => {
      e.forEach((i) => i(r));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e
  );
}
const tu = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
function vs(n) {
  const e = Object.prototype.toString.call(n);
  return e === "[object Window]" || // In Electron context the Window object serializes to [object global]
  e === "[object global]";
}
function Ph(n) {
  return "nodeType" in n;
}
function Tn(n) {
  var e, t;
  return n ? vs(n) ? n : Ph(n) && (e = (t = n.ownerDocument) == null ? void 0 : t.defaultView) != null ? e : window : window;
}
function _h(n) {
  const {
    Document: e
  } = Tn(n);
  return n instanceof e;
}
function _a(n) {
  return vs(n) ? !1 : n instanceof Tn(n).HTMLElement;
}
function M5(n) {
  return n instanceof Tn(n).SVGElement;
}
function ys(n) {
  return n ? vs(n) ? n.document : Ph(n) ? _h(n) ? n : _a(n) ? n.ownerDocument : document : document : document;
}
const mr = tu ? t8 : be;
function nu(n) {
  const e = ge(n);
  return mr(() => {
    e.current = n;
  }), Ie(function() {
    for (var t = arguments.length, r = new Array(t), i = 0; i < t; i++)
      r[i] = arguments[i];
    return e.current == null ? void 0 : e.current(...r);
  }, []);
}
function R5() {
  const n = ge(null), e = Ie((r, i) => {
    n.current = setInterval(r, i);
  }, []), t = Ie(() => {
    n.current !== null && (clearInterval(n.current), n.current = null);
  }, []);
  return [e, t];
}
function ba(n, e) {
  e === void 0 && (e = [n]);
  const t = ge(n);
  return mr(() => {
    t.current !== n && (t.current = n);
  }, e), t;
}
function Na(n, e) {
  const t = ge();
  return pe(
    () => {
      const r = n(t.current);
      return t.current = r, r;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...e]
  );
}
function Oc(n) {
  const e = nu(n), t = ge(null), r = Ie(
    (i) => {
      i !== t.current && (e == null || e(i, t.current)), t.current = i;
    },
    //eslint-disable-next-line
    []
  );
  return [t, r];
}
function Tc(n) {
  const e = ge();
  return be(() => {
    e.current = n;
  }, [n]), e.current;
}
let qd = {};
function za(n, e) {
  return pe(() => {
    if (e)
      return e;
    const t = qd[n] == null ? 0 : qd[n] + 1;
    return qd[n] = t, n + "-" + t;
  }, [n, e]);
}
function rb(n) {
  return function(e) {
    for (var t = arguments.length, r = new Array(t > 1 ? t - 1 : 0), i = 1; i < t; i++)
      r[i - 1] = arguments[i];
    return r.reduce((o, a) => {
      const l = Object.entries(a);
      for (const [u, d] of l) {
        const h = o[u];
        h != null && (o[u] = h + n * d);
      }
      return o;
    }, {
      ...e
    });
  };
}
const is = /* @__PURE__ */ rb(1), Mc = /* @__PURE__ */ rb(-1);
function D5(n) {
  return "clientX" in n && "clientY" in n;
}
function ru(n) {
  if (!n)
    return !1;
  const {
    KeyboardEvent: e
  } = Tn(n.target);
  return e && n instanceof e;
}
function I5(n) {
  if (!n)
    return !1;
  const {
    TouchEvent: e
  } = Tn(n.target);
  return e && n instanceof e;
}
function Rc(n) {
  if (I5(n)) {
    if (n.touches && n.touches.length) {
      const {
        clientX: e,
        clientY: t
      } = n.touches[0];
      return {
        x: e,
        y: t
      };
    } else if (n.changedTouches && n.changedTouches.length) {
      const {
        clientX: e,
        clientY: t
      } = n.changedTouches[0];
      return {
        x: e,
        y: t
      };
    }
  }
  return D5(n) ? {
    x: n.clientX,
    y: n.clientY
  } : null;
}
const $i = /* @__PURE__ */ Object.freeze({
  Translate: {
    toString(n) {
      if (!n)
        return;
      const {
        x: e,
        y: t
      } = n;
      return "translate3d(" + (e ? Math.round(e) : 0) + "px, " + (t ? Math.round(t) : 0) + "px, 0)";
    }
  },
  Scale: {
    toString(n) {
      if (!n)
        return;
      const {
        scaleX: e,
        scaleY: t
      } = n;
      return "scaleX(" + e + ") scaleY(" + t + ")";
    }
  },
  Transform: {
    toString(n) {
      if (n)
        return [$i.Translate.toString(n), $i.Scale.toString(n)].join(" ");
    }
  },
  Transition: {
    toString(n) {
      let {
        property: e,
        duration: t,
        easing: r
      } = n;
      return e + " " + t + "ms " + r;
    }
  }
}), o1 = "a,frame,iframe,input:not([type=hidden]):not(:disabled),select:not(:disabled),textarea:not(:disabled),button:not(:disabled),*[tabindex]";
function A5(n) {
  return n.matches(o1) ? n : n.querySelector(o1);
}
const L5 = {
  display: "none"
};
function P5(n) {
  let {
    id: e,
    value: t
  } = n;
  return yt.createElement("div", {
    id: e,
    style: L5
  }, t);
}
const _5 = {
  position: "fixed",
  width: 1,
  height: 1,
  margin: -1,
  border: 0,
  padding: 0,
  overflow: "hidden",
  clip: "rect(0 0 0 0)",
  clipPath: "inset(100%)",
  whiteSpace: "nowrap"
};
function N5(n) {
  let {
    id: e,
    announcement: t
  } = n;
  return yt.createElement("div", {
    id: e,
    style: _5,
    role: "status",
    "aria-live": "assertive",
    "aria-atomic": !0
  }, t);
}
function z5() {
  const [n, e] = Le("");
  return {
    announce: Ie((r) => {
      r != null && e(r);
    }, []),
    announcement: n
  };
}
const ib = /* @__PURE__ */ Ui(null);
function B5(n) {
  const e = It(ib);
  be(() => {
    if (!e)
      throw new Error("useDndMonitor must be used within a children of <DndContext>");
    return e(n);
  }, [n, e]);
}
function F5() {
  const [n] = Le(() => /* @__PURE__ */ new Set()), e = Ie((r) => (n.add(r), () => n.delete(r)), [n]);
  return [Ie((r) => {
    let {
      type: i,
      event: o
    } = r;
    n.forEach((a) => {
      var l;
      return (l = a[i]) == null ? void 0 : l.call(a, o);
    });
  }, [n]), e];
}
const V5 = {
  draggable: `
    To pick up a draggable item, press the space bar.
    While dragging, use the arrow keys to move the item.
    Press space again to drop the item in its new position, or press escape to cancel.
  `
}, W5 = {
  onDragStart(n) {
    let {
      active: e
    } = n;
    return "Picked up draggable item " + e.id + ".";
  },
  onDragOver(n) {
    let {
      active: e,
      over: t
    } = n;
    return t ? "Draggable item " + e.id + " was moved over droppable area " + t.id + "." : "Draggable item " + e.id + " is no longer over a droppable area.";
  },
  onDragEnd(n) {
    let {
      active: e,
      over: t
    } = n;
    return t ? "Draggable item " + e.id + " was dropped over droppable area " + t.id : "Draggable item " + e.id + " was dropped.";
  },
  onDragCancel(n) {
    let {
      active: e
    } = n;
    return "Dragging was cancelled. Draggable item " + e.id + " was dropped.";
  }
};
function H5(n) {
  let {
    announcements: e = W5,
    container: t,
    hiddenTextDescribedById: r,
    screenReaderInstructions: i = V5
  } = n;
  const {
    announce: o,
    announcement: a
  } = z5(), l = za("DndLiveRegion"), [u, d] = Le(!1);
  if (be(() => {
    d(!0);
  }, []), B5(pe(() => ({
    onDragStart(p) {
      let {
        active: g
      } = p;
      o(e.onDragStart({
        active: g
      }));
    },
    onDragMove(p) {
      let {
        active: g,
        over: v
      } = p;
      e.onDragMove && o(e.onDragMove({
        active: g,
        over: v
      }));
    },
    onDragOver(p) {
      let {
        active: g,
        over: v
      } = p;
      o(e.onDragOver({
        active: g,
        over: v
      }));
    },
    onDragEnd(p) {
      let {
        active: g,
        over: v
      } = p;
      o(e.onDragEnd({
        active: g,
        over: v
      }));
    },
    onDragCancel(p) {
      let {
        active: g,
        over: v
      } = p;
      o(e.onDragCancel({
        active: g,
        over: v
      }));
    }
  }), [o, e])), !u)
    return null;
  const h = yt.createElement(yt.Fragment, null, yt.createElement(P5, {
    id: r,
    value: i.draggable
  }), yt.createElement(N5, {
    id: l,
    announcement: a
  }));
  return t ? L1(h, t) : h;
}
var Zt;
(function(n) {
  n.DragStart = "dragStart", n.DragMove = "dragMove", n.DragEnd = "dragEnd", n.DragCancel = "dragCancel", n.DragOver = "dragOver", n.RegisterDroppable = "registerDroppable", n.SetDroppableDisabled = "setDroppableDisabled", n.UnregisterDroppable = "unregisterDroppable";
})(Zt || (Zt = {}));
function Dc() {
}
function Gd(n, e) {
  return pe(
    () => ({
      sensor: n,
      options: e ?? {}
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n, e]
  );
}
function $5() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return pe(
    () => [...e].filter((r) => r != null),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [...e]
  );
}
const Mr = /* @__PURE__ */ Object.freeze({
  x: 0,
  y: 0
});
function U5(n, e) {
  const t = Rc(n);
  if (!t)
    return "0 0";
  const r = {
    x: (t.x - e.left) / e.width * 100,
    y: (t.y - e.top) / e.height * 100
  };
  return r.x + "% " + r.y + "%";
}
function Z5(n, e) {
  let {
    data: {
      value: t
    }
  } = n, {
    data: {
      value: r
    }
  } = e;
  return r - t;
}
function j5(n, e) {
  if (!n || n.length === 0)
    return null;
  const [t] = n;
  return e ? t[e] : t;
}
function Y5(n, e) {
  const t = Math.max(e.top, n.top), r = Math.max(e.left, n.left), i = Math.min(e.left + e.width, n.left + n.width), o = Math.min(e.top + e.height, n.top + n.height), a = i - r, l = o - t;
  if (r < i && t < o) {
    const u = e.width * e.height, d = n.width * n.height, h = a * l, p = h / (u + d - h);
    return Number(p.toFixed(4));
  }
  return 0;
}
const q5 = (n) => {
  let {
    collisionRect: e,
    droppableRects: t,
    droppableContainers: r
  } = n;
  const i = [];
  for (const o of r) {
    const {
      id: a
    } = o, l = t.get(a);
    if (l) {
      const u = Y5(l, e);
      u > 0 && i.push({
        id: a,
        data: {
          droppableContainer: o,
          value: u
        }
      });
    }
  }
  return i.sort(Z5);
};
function G5(n, e, t) {
  return {
    ...n,
    scaleX: e && t ? e.width / t.width : 1,
    scaleY: e && t ? e.height / t.height : 1
  };
}
function ob(n, e) {
  return n && e ? {
    x: n.left - e.left,
    y: n.top - e.top
  } : Mr;
}
function K5(n) {
  return function(t) {
    for (var r = arguments.length, i = new Array(r > 1 ? r - 1 : 0), o = 1; o < r; o++)
      i[o - 1] = arguments[o];
    return i.reduce((a, l) => ({
      ...a,
      top: a.top + n * l.y,
      bottom: a.bottom + n * l.y,
      left: a.left + n * l.x,
      right: a.right + n * l.x
    }), {
      ...t
    });
  };
}
const X5 = /* @__PURE__ */ K5(1);
function sb(n) {
  if (n.startsWith("matrix3d(")) {
    const e = n.slice(9, -1).split(/, /);
    return {
      x: +e[12],
      y: +e[13],
      scaleX: +e[0],
      scaleY: +e[5]
    };
  } else if (n.startsWith("matrix(")) {
    const e = n.slice(7, -1).split(/, /);
    return {
      x: +e[4],
      y: +e[5],
      scaleX: +e[0],
      scaleY: +e[3]
    };
  }
  return null;
}
function J5(n, e, t) {
  const r = sb(e);
  if (!r)
    return n;
  const {
    scaleX: i,
    scaleY: o,
    x: a,
    y: l
  } = r, u = n.left - a - (1 - i) * parseFloat(t), d = n.top - l - (1 - o) * parseFloat(t.slice(t.indexOf(" ") + 1)), h = i ? n.width / i : n.width, p = o ? n.height / o : n.height;
  return {
    width: h,
    height: p,
    top: d,
    right: u + h,
    bottom: d + p,
    left: u
  };
}
const Q5 = {
  ignoreTransform: !1
};
function ws(n, e) {
  e === void 0 && (e = Q5);
  let t = n.getBoundingClientRect();
  if (e.ignoreTransform) {
    const {
      transform: d,
      transformOrigin: h
    } = Tn(n).getComputedStyle(n);
    d && (t = J5(t, d, h));
  }
  const {
    top: r,
    left: i,
    width: o,
    height: a,
    bottom: l,
    right: u
  } = t;
  return {
    top: r,
    left: i,
    width: o,
    height: a,
    bottom: l,
    right: u
  };
}
function s1(n) {
  return ws(n, {
    ignoreTransform: !0
  });
}
function e3(n) {
  const e = n.innerWidth, t = n.innerHeight;
  return {
    top: 0,
    left: 0,
    right: e,
    bottom: t,
    width: e,
    height: t
  };
}
function t3(n, e) {
  return e === void 0 && (e = Tn(n).getComputedStyle(n)), e.position === "fixed";
}
function n3(n, e) {
  e === void 0 && (e = Tn(n).getComputedStyle(n));
  const t = /(auto|scroll|overlay)/;
  return ["overflow", "overflowX", "overflowY"].some((i) => {
    const o = e[i];
    return typeof o == "string" ? t.test(o) : !1;
  });
}
function Nh(n, e) {
  const t = [];
  function r(i) {
    if (e != null && t.length >= e || !i)
      return t;
    if (_h(i) && i.scrollingElement != null && !t.includes(i.scrollingElement))
      return t.push(i.scrollingElement), t;
    if (!_a(i) || M5(i) || t.includes(i))
      return t;
    const o = Tn(n).getComputedStyle(i);
    return i !== n && n3(i, o) && t.push(i), t3(i, o) ? t : r(i.parentNode);
  }
  return n ? r(n) : t;
}
function ab(n) {
  const [e] = Nh(n, 1);
  return e ?? null;
}
function Kd(n) {
  return !tu || !n ? null : vs(n) ? n : Ph(n) ? _h(n) || n === ys(n).scrollingElement ? window : _a(n) ? n : null : null;
}
function lb(n) {
  return vs(n) ? n.scrollX : n.scrollLeft;
}
function cb(n) {
  return vs(n) ? n.scrollY : n.scrollTop;
}
function Yf(n) {
  return {
    x: lb(n),
    y: cb(n)
  };
}
var Gt;
(function(n) {
  n[n.Forward = 1] = "Forward", n[n.Backward = -1] = "Backward";
})(Gt || (Gt = {}));
function ub(n) {
  return !tu || !n ? !1 : n === document.scrollingElement;
}
function db(n) {
  const e = {
    x: 0,
    y: 0
  }, t = ub(n) ? {
    height: window.innerHeight,
    width: window.innerWidth
  } : {
    height: n.clientHeight,
    width: n.clientWidth
  }, r = {
    x: n.scrollWidth - t.width,
    y: n.scrollHeight - t.height
  }, i = n.scrollTop <= e.y, o = n.scrollLeft <= e.x, a = n.scrollTop >= r.y, l = n.scrollLeft >= r.x;
  return {
    isTop: i,
    isLeft: o,
    isBottom: a,
    isRight: l,
    maxScroll: r,
    minScroll: e
  };
}
const r3 = {
  x: 0.2,
  y: 0.2
};
function i3(n, e, t, r, i) {
  let {
    top: o,
    left: a,
    right: l,
    bottom: u
  } = t;
  r === void 0 && (r = 10), i === void 0 && (i = r3);
  const {
    isTop: d,
    isBottom: h,
    isLeft: p,
    isRight: g
  } = db(n), v = {
    x: 0,
    y: 0
  }, m = {
    x: 0,
    y: 0
  }, w = {
    height: e.height * i.y,
    width: e.width * i.x
  };
  return !d && o <= e.top + w.height ? (v.y = Gt.Backward, m.y = r * Math.abs((e.top + w.height - o) / w.height)) : !h && u >= e.bottom - w.height && (v.y = Gt.Forward, m.y = r * Math.abs((e.bottom - w.height - u) / w.height)), !g && l >= e.right - w.width ? (v.x = Gt.Forward, m.x = r * Math.abs((e.right - w.width - l) / w.width)) : !p && a <= e.left + w.width && (v.x = Gt.Backward, m.x = r * Math.abs((e.left + w.width - a) / w.width)), {
    direction: v,
    speed: m
  };
}
function o3(n) {
  if (n === document.scrollingElement) {
    const {
      innerWidth: o,
      innerHeight: a
    } = window;
    return {
      top: 0,
      left: 0,
      right: o,
      bottom: a,
      width: o,
      height: a
    };
  }
  const {
    top: e,
    left: t,
    right: r,
    bottom: i
  } = n.getBoundingClientRect();
  return {
    top: e,
    left: t,
    right: r,
    bottom: i,
    width: n.clientWidth,
    height: n.clientHeight
  };
}
function fb(n) {
  return n.reduce((e, t) => is(e, Yf(t)), Mr);
}
function s3(n) {
  return n.reduce((e, t) => e + lb(t), 0);
}
function a3(n) {
  return n.reduce((e, t) => e + cb(t), 0);
}
function hb(n, e) {
  if (e === void 0 && (e = ws), !n)
    return;
  const {
    top: t,
    left: r,
    bottom: i,
    right: o
  } = e(n);
  ab(n) && (i <= 0 || o <= 0 || t >= window.innerHeight || r >= window.innerWidth) && n.scrollIntoView({
    block: "center",
    inline: "center"
  });
}
const l3 = [["x", ["left", "right"], s3], ["y", ["top", "bottom"], a3]];
class zh {
  constructor(e, t) {
    this.rect = void 0, this.width = void 0, this.height = void 0, this.top = void 0, this.bottom = void 0, this.right = void 0, this.left = void 0;
    const r = Nh(t), i = fb(r);
    this.rect = {
      ...e
    }, this.width = e.width, this.height = e.height;
    for (const [o, a, l] of l3)
      for (const u of a)
        Object.defineProperty(this, u, {
          get: () => {
            const d = l(r), h = i[o] - d;
            return this.rect[u] + h;
          },
          enumerable: !0
        });
    Object.defineProperty(this, "rect", {
      enumerable: !1
    });
  }
}
class ta {
  constructor(e) {
    this.target = void 0, this.listeners = [], this.removeAll = () => {
      this.listeners.forEach((t) => {
        var r;
        return (r = this.target) == null ? void 0 : r.removeEventListener(...t);
      });
    }, this.target = e;
  }
  add(e, t, r) {
    var i;
    (i = this.target) == null || i.addEventListener(e, t, r), this.listeners.push([e, t, r]);
  }
}
function c3(n) {
  const {
    EventTarget: e
  } = Tn(n);
  return n instanceof e ? n : ys(n);
}
function Xd(n, e) {
  const t = Math.abs(n.x), r = Math.abs(n.y);
  return typeof e == "number" ? Math.sqrt(t ** 2 + r ** 2) > e : "x" in e && "y" in e ? t > e.x && r > e.y : "x" in e ? t > e.x : "y" in e ? r > e.y : !1;
}
var dr;
(function(n) {
  n.Click = "click", n.DragStart = "dragstart", n.Keydown = "keydown", n.ContextMenu = "contextmenu", n.Resize = "resize", n.SelectionChange = "selectionchange", n.VisibilityChange = "visibilitychange";
})(dr || (dr = {}));
function a1(n) {
  n.preventDefault();
}
function u3(n) {
  n.stopPropagation();
}
var gt;
(function(n) {
  n.Space = "Space", n.Down = "ArrowDown", n.Right = "ArrowRight", n.Left = "ArrowLeft", n.Up = "ArrowUp", n.Esc = "Escape", n.Enter = "Enter";
})(gt || (gt = {}));
const pb = {
  start: [gt.Space, gt.Enter],
  cancel: [gt.Esc],
  end: [gt.Space, gt.Enter]
}, d3 = (n, e) => {
  let {
    currentCoordinates: t
  } = e;
  switch (n.code) {
    case gt.Right:
      return {
        ...t,
        x: t.x + 25
      };
    case gt.Left:
      return {
        ...t,
        x: t.x - 25
      };
    case gt.Down:
      return {
        ...t,
        y: t.y + 25
      };
    case gt.Up:
      return {
        ...t,
        y: t.y - 25
      };
  }
};
class Bh {
  constructor(e) {
    this.props = void 0, this.autoScrollEnabled = !1, this.referenceCoordinates = void 0, this.listeners = void 0, this.windowListeners = void 0, this.props = e;
    const {
      event: {
        target: t
      }
    } = e;
    this.props = e, this.listeners = new ta(ys(t)), this.windowListeners = new ta(Tn(t)), this.handleKeyDown = this.handleKeyDown.bind(this), this.handleCancel = this.handleCancel.bind(this), this.attach();
  }
  attach() {
    this.handleStart(), this.windowListeners.add(dr.Resize, this.handleCancel), this.windowListeners.add(dr.VisibilityChange, this.handleCancel), setTimeout(() => this.listeners.add(dr.Keydown, this.handleKeyDown));
  }
  handleStart() {
    const {
      activeNode: e,
      onStart: t
    } = this.props, r = e.node.current;
    r && hb(r), t(Mr);
  }
  handleKeyDown(e) {
    if (ru(e)) {
      const {
        active: t,
        context: r,
        options: i
      } = this.props, {
        keyboardCodes: o = pb,
        coordinateGetter: a = d3,
        scrollBehavior: l = "smooth"
      } = i, {
        code: u
      } = e;
      if (o.end.includes(u)) {
        this.handleEnd(e);
        return;
      }
      if (o.cancel.includes(u)) {
        this.handleCancel(e);
        return;
      }
      const {
        collisionRect: d
      } = r.current, h = d ? {
        x: d.left,
        y: d.top
      } : Mr;
      this.referenceCoordinates || (this.referenceCoordinates = h);
      const p = a(e, {
        active: t,
        context: r.current,
        currentCoordinates: h
      });
      if (p) {
        const g = Mc(p, h), v = {
          x: 0,
          y: 0
        }, {
          scrollableAncestors: m
        } = r.current;
        for (const w of m) {
          const b = e.code, {
            isTop: C,
            isRight: M,
            isLeft: k,
            isBottom: D,
            maxScroll: T,
            minScroll: R
          } = db(w), _ = o3(w), Z = {
            x: Math.min(b === gt.Right ? _.right - _.width / 2 : _.right, Math.max(b === gt.Right ? _.left : _.left + _.width / 2, p.x)),
            y: Math.min(b === gt.Down ? _.bottom - _.height / 2 : _.bottom, Math.max(b === gt.Down ? _.top : _.top + _.height / 2, p.y))
          }, K = b === gt.Right && !M || b === gt.Left && !k, $ = b === gt.Down && !D || b === gt.Up && !C;
          if (K && Z.x !== p.x) {
            const F = w.scrollLeft + g.x, Y = b === gt.Right && F <= T.x || b === gt.Left && F >= R.x;
            if (Y && !g.y) {
              w.scrollTo({
                left: F,
                behavior: l
              });
              return;
            }
            Y ? v.x = w.scrollLeft - F : v.x = b === gt.Right ? w.scrollLeft - T.x : w.scrollLeft - R.x, v.x && w.scrollBy({
              left: -v.x,
              behavior: l
            });
            break;
          } else if ($ && Z.y !== p.y) {
            const F = w.scrollTop + g.y, Y = b === gt.Down && F <= T.y || b === gt.Up && F >= R.y;
            if (Y && !g.x) {
              w.scrollTo({
                top: F,
                behavior: l
              });
              return;
            }
            Y ? v.y = w.scrollTop - F : v.y = b === gt.Down ? w.scrollTop - T.y : w.scrollTop - R.y, v.y && w.scrollBy({
              top: -v.y,
              behavior: l
            });
            break;
          }
        }
        this.handleMove(e, is(Mc(p, this.referenceCoordinates), v));
      }
    }
  }
  handleMove(e, t) {
    const {
      onMove: r
    } = this.props;
    e.preventDefault(), r(t);
  }
  handleEnd(e) {
    const {
      onEnd: t
    } = this.props;
    e.preventDefault(), this.detach(), t();
  }
  handleCancel(e) {
    const {
      onCancel: t
    } = this.props;
    e.preventDefault(), this.detach(), t();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll();
  }
}
Bh.activators = [{
  eventName: "onKeyDown",
  handler: (n, e, t) => {
    let {
      keyboardCodes: r = pb,
      onActivation: i
    } = e, {
      active: o
    } = t;
    const {
      code: a
    } = n.nativeEvent;
    if (r.start.includes(a)) {
      const l = o.activatorNode.current;
      return l && n.target !== l ? !1 : (n.preventDefault(), i == null || i({
        event: n.nativeEvent
      }), !0);
    }
    return !1;
  }
}];
function l1(n) {
  return !!(n && "distance" in n);
}
function c1(n) {
  return !!(n && "delay" in n);
}
class Fh {
  constructor(e, t, r) {
    var i;
    r === void 0 && (r = c3(e.event.target)), this.props = void 0, this.events = void 0, this.autoScrollEnabled = !0, this.document = void 0, this.activated = !1, this.initialCoordinates = void 0, this.timeoutId = null, this.listeners = void 0, this.documentListeners = void 0, this.windowListeners = void 0, this.props = e, this.events = t;
    const {
      event: o
    } = e, {
      target: a
    } = o;
    this.props = e, this.events = t, this.document = ys(a), this.documentListeners = new ta(this.document), this.listeners = new ta(r), this.windowListeners = new ta(Tn(a)), this.initialCoordinates = (i = Rc(o)) != null ? i : Mr, this.handleStart = this.handleStart.bind(this), this.handleMove = this.handleMove.bind(this), this.handleEnd = this.handleEnd.bind(this), this.handleCancel = this.handleCancel.bind(this), this.handleKeydown = this.handleKeydown.bind(this), this.removeTextSelection = this.removeTextSelection.bind(this), this.attach();
  }
  attach() {
    const {
      events: e,
      props: {
        options: {
          activationConstraint: t
        }
      }
    } = this;
    if (this.listeners.add(e.move.name, this.handleMove, {
      passive: !1
    }), this.listeners.add(e.end.name, this.handleEnd), this.windowListeners.add(dr.Resize, this.handleCancel), this.windowListeners.add(dr.DragStart, a1), this.windowListeners.add(dr.VisibilityChange, this.handleCancel), this.windowListeners.add(dr.ContextMenu, a1), this.documentListeners.add(dr.Keydown, this.handleKeydown), t) {
      if (l1(t))
        return;
      if (c1(t)) {
        this.timeoutId = setTimeout(this.handleStart, t.delay);
        return;
      }
    }
    this.handleStart();
  }
  detach() {
    this.listeners.removeAll(), this.windowListeners.removeAll(), setTimeout(this.documentListeners.removeAll, 50), this.timeoutId !== null && (clearTimeout(this.timeoutId), this.timeoutId = null);
  }
  handleStart() {
    const {
      initialCoordinates: e
    } = this, {
      onStart: t
    } = this.props;
    e && (this.activated = !0, this.documentListeners.add(dr.Click, u3, {
      capture: !0
    }), this.removeTextSelection(), this.documentListeners.add(dr.SelectionChange, this.removeTextSelection), t(e));
  }
  handleMove(e) {
    var t;
    const {
      activated: r,
      initialCoordinates: i,
      props: o
    } = this, {
      onMove: a,
      options: {
        activationConstraint: l
      }
    } = o;
    if (!i)
      return;
    const u = (t = Rc(e)) != null ? t : Mr, d = Mc(i, u);
    if (!r && l) {
      if (c1(l))
        return Xd(d, l.tolerance) ? this.handleCancel() : void 0;
      if (l1(l))
        return l.tolerance != null && Xd(d, l.tolerance) ? this.handleCancel() : Xd(d, l.distance) ? this.handleStart() : void 0;
    }
    e.cancelable && e.preventDefault(), a(u);
  }
  handleEnd() {
    const {
      onEnd: e
    } = this.props;
    this.detach(), e();
  }
  handleCancel() {
    const {
      onCancel: e
    } = this.props;
    this.detach(), e();
  }
  handleKeydown(e) {
    e.code === gt.Esc && this.handleCancel();
  }
  removeTextSelection() {
    var e;
    (e = this.document.getSelection()) == null || e.removeAllRanges();
  }
}
const f3 = {
  move: {
    name: "pointermove"
  },
  end: {
    name: "pointerup"
  }
};
class gb extends Fh {
  constructor(e) {
    const {
      event: t
    } = e, r = ys(t.target);
    super(e, f3, r);
  }
}
gb.activators = [{
  eventName: "onPointerDown",
  handler: (n, e) => {
    let {
      nativeEvent: t
    } = n, {
      onActivation: r
    } = e;
    return !t.isPrimary || t.button !== 0 ? !1 : (r == null || r({
      event: t
    }), !0);
  }
}];
const h3 = {
  move: {
    name: "mousemove"
  },
  end: {
    name: "mouseup"
  }
};
var qf;
(function(n) {
  n[n.RightClick = 2] = "RightClick";
})(qf || (qf = {}));
class mb extends Fh {
  constructor(e) {
    super(e, h3, ys(e.event.target));
  }
}
mb.activators = [{
  eventName: "onMouseDown",
  handler: (n, e) => {
    let {
      nativeEvent: t
    } = n, {
      onActivation: r
    } = e;
    return t.button === qf.RightClick ? !1 : (r == null || r({
      event: t
    }), !0);
  }
}];
const Jd = {
  move: {
    name: "touchmove"
  },
  end: {
    name: "touchend"
  }
};
class vb extends Fh {
  constructor(e) {
    super(e, Jd);
  }
  static setup() {
    return window.addEventListener(Jd.move.name, e, {
      capture: !1,
      passive: !1
    }), function() {
      window.removeEventListener(Jd.move.name, e);
    };
    function e() {
    }
  }
}
vb.activators = [{
  eventName: "onTouchStart",
  handler: (n, e) => {
    let {
      nativeEvent: t
    } = n, {
      onActivation: r
    } = e;
    const {
      touches: i
    } = t;
    return i.length > 1 ? !1 : (r == null || r({
      event: t
    }), !0);
  }
}];
var na;
(function(n) {
  n[n.Pointer = 0] = "Pointer", n[n.DraggableRect = 1] = "DraggableRect";
})(na || (na = {}));
var Ic;
(function(n) {
  n[n.TreeOrder = 0] = "TreeOrder", n[n.ReversedTreeOrder = 1] = "ReversedTreeOrder";
})(Ic || (Ic = {}));
function p3(n) {
  let {
    acceleration: e,
    activator: t = na.Pointer,
    canScroll: r,
    draggingRect: i,
    enabled: o,
    interval: a = 5,
    order: l = Ic.TreeOrder,
    pointerCoordinates: u,
    scrollableAncestors: d,
    scrollableAncestorRects: h,
    delta: p,
    threshold: g
  } = n;
  const v = m3({
    delta: p,
    disabled: !o
  }), [m, w] = R5(), b = ge({
    x: 0,
    y: 0
  }), C = ge({
    x: 0,
    y: 0
  }), M = pe(() => {
    switch (t) {
      case na.Pointer:
        return u ? {
          top: u.y,
          bottom: u.y,
          left: u.x,
          right: u.x
        } : null;
      case na.DraggableRect:
        return i;
    }
  }, [t, i, u]), k = ge(null), D = Ie(() => {
    const R = k.current;
    if (!R)
      return;
    const _ = b.current.x * C.current.x, Z = b.current.y * C.current.y;
    R.scrollBy(_, Z);
  }, []), T = pe(() => l === Ic.TreeOrder ? [...d].reverse() : d, [l, d]);
  be(
    () => {
      if (!o || !d.length || !M) {
        w();
        return;
      }
      for (const R of T) {
        if ((r == null ? void 0 : r(R)) === !1)
          continue;
        const _ = d.indexOf(R), Z = h[_];
        if (!Z)
          continue;
        const {
          direction: K,
          speed: $
        } = i3(R, Z, M, e, g);
        for (const F of ["x", "y"])
          v[F][K[F]] || ($[F] = 0, K[F] = 0);
        if ($.x > 0 || $.y > 0) {
          w(), k.current = R, m(D, a), b.current = $, C.current = K;
          return;
        }
      }
      b.current = {
        x: 0,
        y: 0
      }, C.current = {
        x: 0,
        y: 0
      }, w();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [
      e,
      D,
      r,
      w,
      o,
      a,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(M),
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(v),
      m,
      d,
      T,
      h,
      // eslint-disable-next-line react-hooks/exhaustive-deps
      JSON.stringify(g)
    ]
  );
}
const g3 = {
  x: {
    [Gt.Backward]: !1,
    [Gt.Forward]: !1
  },
  y: {
    [Gt.Backward]: !1,
    [Gt.Forward]: !1
  }
};
function m3(n) {
  let {
    delta: e,
    disabled: t
  } = n;
  const r = Tc(e);
  return Na((i) => {
    if (t || !r || !i)
      return g3;
    const o = {
      x: Math.sign(e.x - r.x),
      y: Math.sign(e.y - r.y)
    };
    return {
      x: {
        [Gt.Backward]: i.x[Gt.Backward] || o.x === -1,
        [Gt.Forward]: i.x[Gt.Forward] || o.x === 1
      },
      y: {
        [Gt.Backward]: i.y[Gt.Backward] || o.y === -1,
        [Gt.Forward]: i.y[Gt.Forward] || o.y === 1
      }
    };
  }, [t, e, r]);
}
function v3(n, e) {
  const t = e !== null ? n.get(e) : void 0, r = t ? t.node.current : null;
  return Na((i) => {
    var o;
    return e === null ? null : (o = r ?? i) != null ? o : null;
  }, [r, e]);
}
function y3(n, e) {
  return pe(() => n.reduce((t, r) => {
    const {
      sensor: i
    } = r, o = i.activators.map((a) => ({
      eventName: a.eventName,
      handler: e(a.handler, r)
    }));
    return [...t, ...o];
  }, []), [n, e]);
}
var xa;
(function(n) {
  n[n.Always = 0] = "Always", n[n.BeforeDragging = 1] = "BeforeDragging", n[n.WhileDragging = 2] = "WhileDragging";
})(xa || (xa = {}));
var Gf;
(function(n) {
  n.Optimized = "optimized";
})(Gf || (Gf = {}));
const u1 = /* @__PURE__ */ new Map();
function w3(n, e) {
  let {
    dragging: t,
    dependencies: r,
    config: i
  } = e;
  const [o, a] = Le(null), {
    frequency: l,
    measure: u,
    strategy: d
  } = i, h = ge(n), p = b(), g = ba(p), v = Ie(function(C) {
    C === void 0 && (C = []), !g.current && a((M) => M === null ? C : M.concat(C.filter((k) => !M.includes(k))));
  }, [g]), m = ge(null), w = Na((C) => {
    if (p && !t)
      return u1;
    if (!C || C === u1 || h.current !== n || o != null) {
      const M = /* @__PURE__ */ new Map();
      for (let k of n) {
        if (!k)
          continue;
        if (o && o.length > 0 && !o.includes(k.id) && k.rect.current) {
          M.set(k.id, k.rect.current);
          continue;
        }
        const D = k.node.current, T = D ? new zh(u(D), D) : null;
        k.rect.current = T, T && M.set(k.id, T);
      }
      return M;
    }
    return C;
  }, [n, o, t, p, u]);
  return be(() => {
    h.current = n;
  }, [n]), be(
    () => {
      p || v();
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t, p]
  ), be(
    () => {
      o && o.length > 0 && a(null);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [JSON.stringify(o)]
  ), be(
    () => {
      p || typeof l != "number" || m.current !== null || (m.current = setTimeout(() => {
        v(), m.current = null;
      }, l));
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [l, p, v, ...r]
  ), {
    droppableRects: w,
    measureDroppableContainers: v,
    measuringScheduled: o != null
  };
  function b() {
    switch (d) {
      case xa.Always:
        return !1;
      case xa.BeforeDragging:
        return t;
      default:
        return !t;
    }
  }
}
function Vh(n, e) {
  return Na((t) => n ? t || (typeof e == "function" ? e(n) : n) : null, [e, n]);
}
function b3(n, e) {
  return Vh(n, e);
}
function x3(n) {
  let {
    callback: e,
    disabled: t
  } = n;
  const r = nu(e), i = pe(() => {
    if (t || typeof window > "u" || typeof window.MutationObserver > "u")
      return;
    const {
      MutationObserver: o
    } = window;
    return new o(r);
  }, [r, t]);
  return be(() => () => i == null ? void 0 : i.disconnect(), [i]), i;
}
function iu(n) {
  let {
    callback: e,
    disabled: t
  } = n;
  const r = nu(e), i = pe(
    () => {
      if (t || typeof window > "u" || typeof window.ResizeObserver > "u")
        return;
      const {
        ResizeObserver: o
      } = window;
      return new o(r);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [t]
  );
  return be(() => () => i == null ? void 0 : i.disconnect(), [i]), i;
}
function S3(n) {
  return new zh(ws(n), n);
}
function d1(n, e, t) {
  e === void 0 && (e = S3);
  const [r, i] = Lc(l, null), o = x3({
    callback(u) {
      if (n)
        for (const d of u) {
          const {
            type: h,
            target: p
          } = d;
          if (h === "childList" && p instanceof HTMLElement && p.contains(n)) {
            i();
            break;
          }
        }
    }
  }), a = iu({
    callback: i
  });
  return mr(() => {
    i(), n ? (a == null || a.observe(n), o == null || o.observe(document.body, {
      childList: !0,
      subtree: !0
    })) : (a == null || a.disconnect(), o == null || o.disconnect());
  }, [n]), r;
  function l(u) {
    if (!n)
      return null;
    if (n.isConnected === !1) {
      var d;
      return (d = u ?? t) != null ? d : null;
    }
    const h = e(n);
    return JSON.stringify(u) === JSON.stringify(h) ? u : h;
  }
}
function C3(n) {
  const e = Vh(n);
  return ob(n, e);
}
const f1 = [];
function E3(n) {
  const e = ge(n), t = Na((r) => n ? r && r !== f1 && n && e.current && n.parentNode === e.current.parentNode ? r : Nh(n) : f1, [n]);
  return be(() => {
    e.current = n;
  }, [n]), t;
}
function k3(n) {
  const [e, t] = Le(null), r = ge(n), i = Ie((o) => {
    const a = Kd(o.target);
    a && t((l) => l ? (l.set(a, Yf(a)), new Map(l)) : null);
  }, []);
  return be(() => {
    const o = r.current;
    if (n !== o) {
      a(o);
      const l = n.map((u) => {
        const d = Kd(u);
        return d ? (d.addEventListener("scroll", i, {
          passive: !0
        }), [d, Yf(d)]) : null;
      }).filter((u) => u != null);
      t(l.length ? new Map(l) : null), r.current = n;
    }
    return () => {
      a(n), a(o);
    };
    function a(l) {
      l.forEach((u) => {
        const d = Kd(u);
        d == null || d.removeEventListener("scroll", i);
      });
    }
  }, [i, n]), pe(() => n.length ? e ? Array.from(e.values()).reduce((o, a) => is(o, a), Mr) : fb(n) : Mr, [n, e]);
}
function h1(n, e) {
  e === void 0 && (e = []);
  const t = ge(null);
  return be(
    () => {
      t.current = null;
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    e
  ), be(() => {
    const r = n !== Mr;
    r && !t.current && (t.current = n), !r && t.current && (t.current = null);
  }, [n]), t.current ? Mc(n, t.current) : Mr;
}
function O3(n) {
  be(
    () => {
      if (!tu)
        return;
      const e = n.map((t) => {
        let {
          sensor: r
        } = t;
        return r.setup == null ? void 0 : r.setup();
      });
      return () => {
        for (const t of e)
          t == null || t();
      };
    },
    // TO-DO: Sensors length could theoretically change which would not be a valid dependency
    // eslint-disable-next-line react-hooks/exhaustive-deps
    n.map((e) => {
      let {
        sensor: t
      } = e;
      return t;
    })
  );
}
function T3(n, e) {
  return pe(() => n.reduce((t, r) => {
    let {
      eventName: i,
      handler: o
    } = r;
    return t[i] = (a) => {
      o(a, e);
    }, t;
  }, {}), [n, e]);
}
function yb(n) {
  return pe(() => n ? e3(n) : null, [n]);
}
const Qd = [];
function M3(n, e) {
  e === void 0 && (e = ws);
  const [t] = n, r = yb(t ? Tn(t) : null), [i, o] = Lc(l, Qd), a = iu({
    callback: o
  });
  return n.length > 0 && i === Qd && o(), mr(() => {
    n.length ? n.forEach((u) => a == null ? void 0 : a.observe(u)) : (a == null || a.disconnect(), o());
  }, [n]), i;
  function l() {
    return n.length ? n.map((u) => ub(u) ? r : new zh(e(u), u)) : Qd;
  }
}
function wb(n) {
  if (!n)
    return null;
  if (n.children.length > 1)
    return n;
  const e = n.children[0];
  return _a(e) ? e : n;
}
function R3(n) {
  let {
    measure: e
  } = n;
  const [t, r] = Le(null), i = Ie((d) => {
    for (const {
      target: h
    } of d)
      if (_a(h)) {
        r((p) => {
          const g = e(h);
          return p ? {
            ...p,
            width: g.width,
            height: g.height
          } : g;
        });
        break;
      }
  }, [e]), o = iu({
    callback: i
  }), a = Ie((d) => {
    const h = wb(d);
    o == null || o.disconnect(), h && (o == null || o.observe(h)), r(h ? e(h) : null);
  }, [e, o]), [l, u] = Oc(a);
  return pe(() => ({
    nodeRef: l,
    rect: t,
    setRef: u
  }), [t, l, u]);
}
const D3 = [{
  sensor: gb,
  options: {}
}, {
  sensor: Bh,
  options: {}
}], I3 = {
  current: {}
}, Kl = {
  draggable: {
    measure: s1
  },
  droppable: {
    measure: s1,
    strategy: xa.WhileDragging,
    frequency: Gf.Optimized
  },
  dragOverlay: {
    measure: ws
  }
};
class ra extends Map {
  get(e) {
    var t;
    return e != null && (t = super.get(e)) != null ? t : void 0;
  }
  toArray() {
    return Array.from(this.values());
  }
  getEnabled() {
    return this.toArray().filter((e) => {
      let {
        disabled: t
      } = e;
      return !t;
    });
  }
  getNodeFor(e) {
    var t, r;
    return (t = (r = this.get(e)) == null ? void 0 : r.node.current) != null ? t : void 0;
  }
}
const A3 = {
  activatorEvent: null,
  active: null,
  activeNode: null,
  activeNodeRect: null,
  collisions: null,
  containerNodeRect: null,
  draggableNodes: /* @__PURE__ */ new Map(),
  droppableRects: /* @__PURE__ */ new Map(),
  droppableContainers: /* @__PURE__ */ new ra(),
  over: null,
  dragOverlay: {
    nodeRef: {
      current: null
    },
    rect: null,
    setRef: Dc
  },
  scrollableAncestors: [],
  scrollableAncestorRects: [],
  measuringConfiguration: Kl,
  measureDroppableContainers: Dc,
  windowRect: null,
  measuringScheduled: !1
}, bb = {
  activatorEvent: null,
  activators: [],
  active: null,
  activeNodeRect: null,
  ariaDescribedById: {
    draggable: ""
  },
  dispatch: Dc,
  draggableNodes: /* @__PURE__ */ new Map(),
  over: null,
  measureDroppableContainers: Dc
}, Ba = /* @__PURE__ */ Ui(bb), xb = /* @__PURE__ */ Ui(A3);
function L3() {
  return {
    draggable: {
      active: null,
      initialCoordinates: {
        x: 0,
        y: 0
      },
      nodes: /* @__PURE__ */ new Map(),
      translate: {
        x: 0,
        y: 0
      }
    },
    droppable: {
      containers: new ra()
    }
  };
}
function P3(n, e) {
  switch (e.type) {
    case Zt.DragStart:
      return {
        ...n,
        draggable: {
          ...n.draggable,
          initialCoordinates: e.initialCoordinates,
          active: e.active
        }
      };
    case Zt.DragMove:
      return n.draggable.active ? {
        ...n,
        draggable: {
          ...n.draggable,
          translate: {
            x: e.coordinates.x - n.draggable.initialCoordinates.x,
            y: e.coordinates.y - n.draggable.initialCoordinates.y
          }
        }
      } : n;
    case Zt.DragEnd:
    case Zt.DragCancel:
      return {
        ...n,
        draggable: {
          ...n.draggable,
          active: null,
          initialCoordinates: {
            x: 0,
            y: 0
          },
          translate: {
            x: 0,
            y: 0
          }
        }
      };
    case Zt.RegisterDroppable: {
      const {
        element: t
      } = e, {
        id: r
      } = t, i = new ra(n.droppable.containers);
      return i.set(r, t), {
        ...n,
        droppable: {
          ...n.droppable,
          containers: i
        }
      };
    }
    case Zt.SetDroppableDisabled: {
      const {
        id: t,
        key: r,
        disabled: i
      } = e, o = n.droppable.containers.get(t);
      if (!o || r !== o.key)
        return n;
      const a = new ra(n.droppable.containers);
      return a.set(t, {
        ...o,
        disabled: i
      }), {
        ...n,
        droppable: {
          ...n.droppable,
          containers: a
        }
      };
    }
    case Zt.UnregisterDroppable: {
      const {
        id: t,
        key: r
      } = e, i = n.droppable.containers.get(t);
      if (!i || r !== i.key)
        return n;
      const o = new ra(n.droppable.containers);
      return o.delete(t), {
        ...n,
        droppable: {
          ...n.droppable,
          containers: o
        }
      };
    }
    default:
      return n;
  }
}
function _3(n) {
  let {
    disabled: e
  } = n;
  const {
    active: t,
    activatorEvent: r,
    draggableNodes: i
  } = It(Ba), o = Tc(r), a = Tc(t == null ? void 0 : t.id);
  return be(() => {
    if (!e && !r && o && a != null) {
      if (!ru(o) || document.activeElement === o.target)
        return;
      const l = i.get(a);
      if (!l)
        return;
      const {
        activatorNode: u,
        node: d
      } = l;
      if (!u.current && !d.current)
        return;
      requestAnimationFrame(() => {
        for (const h of [u.current, d.current]) {
          if (!h)
            continue;
          const p = A5(h);
          if (p) {
            p.focus();
            break;
          }
        }
      });
    }
  }, [r, e, i, a, o]), null;
}
function Sb(n, e) {
  let {
    transform: t,
    ...r
  } = e;
  return n != null && n.length ? n.reduce((i, o) => o({
    transform: i,
    ...r
  }), t) : t;
}
function N3(n) {
  return pe(
    () => ({
      draggable: {
        ...Kl.draggable,
        ...n == null ? void 0 : n.draggable
      },
      droppable: {
        ...Kl.droppable,
        ...n == null ? void 0 : n.droppable
      },
      dragOverlay: {
        ...Kl.dragOverlay,
        ...n == null ? void 0 : n.dragOverlay
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [n == null ? void 0 : n.draggable, n == null ? void 0 : n.droppable, n == null ? void 0 : n.dragOverlay]
  );
}
function z3(n) {
  let {
    activeNode: e,
    measure: t,
    initialRect: r,
    config: i = !0
  } = n;
  const o = ge(!1), {
    x: a,
    y: l
  } = typeof i == "boolean" ? {
    x: i,
    y: i
  } : i;
  mr(() => {
    if (!a && !l || !e) {
      o.current = !1;
      return;
    }
    if (o.current || !r)
      return;
    const d = e == null ? void 0 : e.node.current;
    if (!d || d.isConnected === !1)
      return;
    const h = t(d), p = ob(h, r);
    if (a || (p.x = 0), l || (p.y = 0), o.current = !0, Math.abs(p.x) > 0 || Math.abs(p.y) > 0) {
      const g = ab(d);
      g && g.scrollBy({
        top: p.y,
        left: p.x
      });
    }
  }, [e, a, l, r, t]);
}
const ou = /* @__PURE__ */ Ui({
  ...Mr,
  scaleX: 1,
  scaleY: 1
});
var Ri;
(function(n) {
  n[n.Uninitialized = 0] = "Uninitialized", n[n.Initializing = 1] = "Initializing", n[n.Initialized = 2] = "Initialized";
})(Ri || (Ri = {}));
const B3 = /* @__PURE__ */ n8(function(e) {
  var t, r, i, o;
  let {
    id: a,
    accessibility: l,
    autoScroll: u = !0,
    children: d,
    sensors: h = D3,
    collisionDetection: p = q5,
    measuring: g,
    modifiers: v,
    ...m
  } = e;
  const w = Lc(P3, void 0, L3), [b, C] = w, [M, k] = F5(), [D, T] = Le(Ri.Uninitialized), R = D === Ri.Initialized, {
    draggable: {
      active: _,
      nodes: Z,
      translate: K
    },
    droppable: {
      containers: $
    }
  } = b, F = _ ? Z.get(_) : null, Y = ge({
    initial: null,
    translated: null
  }), Q = pe(() => {
    var zt;
    return _ != null ? {
      id: _,
      // It's possible for the active node to unmount while dragging
      data: (zt = F == null ? void 0 : F.data) != null ? zt : I3,
      rect: Y
    } : null;
  }, [_, F]), ee = ge(null), [ie, re] = Le(null), [oe, de] = Le(null), se = ba(m, Object.values(m)), we = za("DndDescribedBy", a), Oe = pe(() => $.getEnabled(), [$]), le = N3(g), {
    droppableRects: Ce,
    measureDroppableContainers: Ne,
    measuringScheduled: me
  } = w3(Oe, {
    dragging: R,
    dependencies: [K.x, K.y],
    config: le.droppable
  }), U = v3(Z, _), ae = pe(() => oe ? Rc(oe) : null, [oe]), G = cu(), xe = b3(U, le.draggable.measure);
  z3({
    activeNode: _ ? Z.get(_) : null,
    config: G.layoutShiftCompensation,
    initialRect: xe,
    measure: le.draggable.measure
  });
  const ye = d1(U, le.draggable.measure, xe), Je = d1(U ? U.parentElement : null), te = ge({
    activatorEvent: null,
    active: null,
    activeNode: U,
    collisionRect: null,
    collisions: null,
    droppableRects: Ce,
    draggableNodes: Z,
    draggingNode: null,
    draggingNodeRect: null,
    droppableContainers: $,
    over: null,
    scrollableAncestors: [],
    scrollAdjustedTranslate: null
  }), $e = $.getNodeFor((t = te.current.over) == null ? void 0 : t.id), Be = R3({
    measure: le.dragOverlay.measure
  }), vt = (r = Be.nodeRef.current) != null ? r : U, P = R ? (i = Be.rect) != null ? i : ye : null, A = !!(Be.nodeRef.current && Be.rect), z = C3(A ? null : ye), H = yb(vt ? Tn(vt) : null), ce = E3(R ? $e ?? U : null), fe = M3(ce), _e = Sb(v, {
    transform: {
      x: K.x - z.x,
      y: K.y - z.y,
      scaleX: 1,
      scaleY: 1
    },
    activatorEvent: oe,
    active: Q,
    activeNodeRect: ye,
    containerNodeRect: Je,
    draggingNodeRect: P,
    over: te.current.over,
    overlayNodeRect: Be.rect,
    scrollableAncestors: ce,
    scrollableAncestorRects: fe,
    windowRect: H
  }), tt = ae ? is(ae, K) : null, Mt = k3(ce), Pe = h1(Mt), qe = h1(Mt, [ye]), ve = is(_e, Pe), Ae = P ? X5(P, _e) : null, ot = Q && Ae ? p({
    active: Q,
    collisionRect: Ae,
    droppableRects: Ce,
    droppableContainers: Oe,
    pointerCoordinates: tt
  }) : null, Ct = j5(ot, "id"), [Fe, De] = Le(null), on = A ? _e : is(_e, qe), Ur = G5(on, (o = Fe == null ? void 0 : Fe.rect) != null ? o : null, ye), Zr = Ie(
    (zt, sn) => {
      let {
        sensor: wn,
        options: Rr
      } = sn;
      if (ee.current == null)
        return;
      const Mn = Z.get(ee.current);
      if (!Mn)
        return;
      const Bn = zt.nativeEvent, Fn = new wn({
        active: ee.current,
        activeNode: Mn,
        event: Bn,
        options: Rr,
        // Sensors need to be instantiated with refs for arguments that change over time
        // otherwise they are frozen in time with the stale arguments
        context: te,
        onStart(Vn) {
          const Gi = ee.current;
          if (Gi == null)
            return;
          const jr = Z.get(Gi);
          if (!jr)
            return;
          const {
            onDragStart: Io
          } = se.current, hi = {
            active: {
              id: Gi,
              data: jr.data,
              rect: Y
            }
          };
          zs(() => {
            Io == null || Io(hi), T(Ri.Initializing), C({
              type: Zt.DragStart,
              initialCoordinates: Vn,
              active: Gi
            }), M({
              type: "onDragStart",
              event: hi
            });
          });
        },
        onMove(Vn) {
          C({
            type: Zt.DragMove,
            coordinates: Vn
          });
        },
        onEnd: fi(Zt.DragEnd),
        onCancel: fi(Zt.DragCancel)
      });
      zs(() => {
        re(Fn), de(zt.nativeEvent);
      });
      function fi(Vn) {
        return async function() {
          const {
            active: jr,
            collisions: Io,
            over: hi,
            scrollAdjustedTranslate: Fa
          } = te.current;
          let Ki = null;
          if (jr && Fa) {
            const {
              cancelDrop: Xi
            } = se.current;
            Ki = {
              activatorEvent: Bn,
              active: jr,
              collisions: Io,
              delta: Fa,
              over: hi
            }, Vn === Zt.DragEnd && typeof Xi == "function" && await Promise.resolve(Xi(Ki)) && (Vn = Zt.DragCancel);
          }
          ee.current = null, zs(() => {
            C({
              type: Vn
            }), T(Ri.Uninitialized), De(null), re(null), de(null);
            const Xi = Vn === Zt.DragEnd ? "onDragEnd" : "onDragCancel";
            if (Ki) {
              const xs = se.current[Xi];
              xs == null || xs(Ki), M({
                type: Xi,
                event: Ki
              });
            }
          });
        };
      }
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Z]
  ), bs = Ie((zt, sn) => (wn, Rr) => {
    const Mn = wn.nativeEvent, Bn = Z.get(Rr);
    if (
      // Another sensor is already instantiating
      ee.current !== null || // No active draggable
      !Bn || // Event has already been captured
      Mn.dndKit || Mn.defaultPrevented
    )
      return;
    const Fn = {
      active: Bn
    };
    zt(wn, sn.options, Fn) === !0 && (Mn.dndKit = {
      capturedBy: sn.sensor
    }, ee.current = Rr, Zr(wn, sn));
  }, [Z, Zr]), Do = y3(h, bs);
  O3(h), mr(() => {
    ye && D === Ri.Initializing && T(Ri.Initialized);
  }, [ye, D]), be(
    () => {
      const {
        onDragMove: zt
      } = se.current, {
        active: sn,
        activatorEvent: wn,
        collisions: Rr,
        over: Mn
      } = te.current;
      if (!sn || !wn)
        return;
      const Bn = {
        active: sn,
        activatorEvent: wn,
        collisions: Rr,
        delta: {
          x: ve.x,
          y: ve.y
        },
        over: Mn
      };
      zs(() => {
        zt == null || zt(Bn), M({
          type: "onDragMove",
          event: Bn
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [ve.x, ve.y]
  ), be(
    () => {
      const {
        active: zt,
        activatorEvent: sn,
        collisions: wn,
        droppableContainers: Rr,
        scrollAdjustedTranslate: Mn
      } = te.current;
      if (!zt || ee.current == null || !sn || !Mn)
        return;
      const {
        onDragOver: Bn
      } = se.current, Fn = Rr.get(Ct), fi = Fn && Fn.rect.current ? {
        id: Fn.id,
        rect: Fn.rect.current,
        data: Fn.data,
        disabled: Fn.disabled
      } : null, Vn = {
        active: zt,
        activatorEvent: sn,
        collisions: wn,
        delta: {
          x: Mn.x,
          y: Mn.y
        },
        over: fi
      };
      zs(() => {
        De(fi), Bn == null || Bn(Vn), M({
          type: "onDragOver",
          event: Vn
        });
      });
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [Ct]
  ), mr(() => {
    te.current = {
      activatorEvent: oe,
      active: Q,
      activeNode: U,
      collisionRect: Ae,
      collisions: ot,
      droppableRects: Ce,
      draggableNodes: Z,
      draggingNode: vt,
      draggingNodeRect: P,
      droppableContainers: $,
      over: Fe,
      scrollableAncestors: ce,
      scrollAdjustedTranslate: ve
    }, Y.current = {
      initial: P,
      translated: Ae
    };
  }, [Q, U, ot, Ae, Z, vt, P, Ce, $, Fe, ce, ve]), p3({
    ...G,
    delta: K,
    draggingRect: Ae,
    pointerCoordinates: tt,
    scrollableAncestors: ce,
    scrollableAncestorRects: fe
  });
  const au = pe(() => ({
    active: Q,
    activeNode: U,
    activeNodeRect: ye,
    activatorEvent: oe,
    collisions: ot,
    containerNodeRect: Je,
    dragOverlay: Be,
    draggableNodes: Z,
    droppableContainers: $,
    droppableRects: Ce,
    over: Fe,
    measureDroppableContainers: Ne,
    scrollableAncestors: ce,
    scrollableAncestorRects: fe,
    measuringConfiguration: le,
    measuringScheduled: me,
    windowRect: H
  }), [Q, U, ye, oe, ot, Je, Be, Z, $, Ce, Fe, Ne, ce, fe, le, me, H]), lu = pe(() => ({
    activatorEvent: oe,
    activators: Do,
    active: Q,
    activeNodeRect: ye,
    ariaDescribedById: {
      draggable: we
    },
    dispatch: C,
    draggableNodes: Z,
    over: Fe,
    measureDroppableContainers: Ne
  }), [oe, Do, Q, ye, C, we, Z, Fe, Ne]);
  return yt.createElement(ib.Provider, {
    value: k
  }, yt.createElement(Ba.Provider, {
    value: lu
  }, yt.createElement(xb.Provider, {
    value: au
  }, yt.createElement(ou.Provider, {
    value: Ur
  }, d)), yt.createElement(_3, {
    disabled: (l == null ? void 0 : l.restoreFocus) === !1
  })), yt.createElement(H5, {
    ...l,
    hiddenTextDescribedById: we
  }));
  function cu() {
    const zt = (ie == null ? void 0 : ie.autoScrollEnabled) === !1, sn = typeof u == "object" ? u.enabled === !1 : u === !1, wn = R && !zt && !sn;
    return typeof u == "object" ? {
      ...u,
      enabled: wn
    } : {
      enabled: wn
    };
  }
}), F3 = /* @__PURE__ */ Ui(null), p1 = "button", V3 = "Droppable";
function W3(n) {
  let {
    id: e,
    data: t,
    disabled: r = !1,
    attributes: i
  } = n;
  const o = za(V3), {
    activators: a,
    activatorEvent: l,
    active: u,
    activeNodeRect: d,
    ariaDescribedById: h,
    draggableNodes: p,
    over: g
  } = It(Ba), {
    role: v = p1,
    roleDescription: m = "draggable",
    tabIndex: w = 0
  } = i ?? {}, b = (u == null ? void 0 : u.id) === e, C = It(b ? ou : F3), [M, k] = Oc(), [D, T] = Oc(), R = T3(a, e), _ = ba(t);
  mr(
    () => (p.set(e, {
      id: e,
      key: o,
      node: M,
      activatorNode: D,
      data: _
    }), () => {
      const K = p.get(e);
      K && K.key === o && p.delete(e);
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [p, e]
  );
  const Z = pe(() => ({
    role: v,
    tabIndex: w,
    "aria-disabled": r,
    "aria-pressed": b && v === p1 ? !0 : void 0,
    "aria-roledescription": m,
    "aria-describedby": h.draggable
  }), [r, v, w, b, m, h.draggable]);
  return {
    active: u,
    activatorEvent: l,
    activeNodeRect: d,
    attributes: Z,
    isDragging: b,
    listeners: r ? void 0 : R,
    node: M,
    over: g,
    setNodeRef: k,
    setActivatorNodeRef: T,
    transform: C
  };
}
function Cb() {
  return It(xb);
}
const H3 = "Droppable", $3 = {
  timeout: 25
};
function U3(n) {
  let {
    data: e,
    disabled: t = !1,
    id: r,
    resizeObserverConfig: i
  } = n;
  const o = za(H3), {
    active: a,
    dispatch: l,
    over: u,
    measureDroppableContainers: d
  } = It(Ba), h = ge({
    disabled: t
  }), p = ge(!1), g = ge(null), v = ge(null), {
    disabled: m,
    updateMeasurementsFor: w,
    timeout: b
  } = {
    ...$3,
    ...i
  }, C = ba(w ?? r), M = Ie(
    () => {
      if (!p.current) {
        p.current = !0;
        return;
      }
      v.current != null && clearTimeout(v.current), v.current = setTimeout(() => {
        d(Array.isArray(C.current) ? C.current : [C.current]), v.current = null;
      }, b);
    },
    //eslint-disable-next-line react-hooks/exhaustive-deps
    [b]
  ), k = iu({
    callback: M,
    disabled: m || !a
  }), D = Ie((Z, K) => {
    k && (K && (k.unobserve(K), p.current = !1), Z && k.observe(Z));
  }, [k]), [T, R] = Oc(D), _ = ba(e);
  return be(() => {
    !k || !T.current || (k.disconnect(), p.current = !1, k.observe(T.current));
  }, [T, k]), mr(
    () => (l({
      type: Zt.RegisterDroppable,
      element: {
        id: r,
        key: o,
        disabled: t,
        node: T,
        rect: g,
        data: _
      }
    }), () => l({
      type: Zt.UnregisterDroppable,
      key: o,
      id: r
    })),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [r]
  ), be(() => {
    t !== h.current.disabled && (l({
      type: Zt.SetDroppableDisabled,
      id: r,
      key: o,
      disabled: t
    }), h.current.disabled = t);
  }, [r, o, t, l]), {
    active: a,
    rect: g,
    isOver: (u == null ? void 0 : u.id) === r,
    node: T,
    over: u,
    setNodeRef: R
  };
}
function Z3(n) {
  let {
    animation: e,
    children: t
  } = n;
  const [r, i] = Le(null), [o, a] = Le(null), l = Tc(t);
  return !t && !r && l && i(l), mr(() => {
    if (!o)
      return;
    const u = r == null ? void 0 : r.key, d = r == null ? void 0 : r.props.id;
    if (u == null || d == null) {
      i(null);
      return;
    }
    Promise.resolve(e(d, o)).then(() => {
      i(null);
    });
  }, [e, r, o]), yt.createElement(yt.Fragment, null, t, r ? r8(r, {
    ref: a
  }) : null);
}
const j3 = {
  x: 0,
  y: 0,
  scaleX: 1,
  scaleY: 1
};
function Y3(n) {
  let {
    children: e
  } = n;
  return yt.createElement(Ba.Provider, {
    value: bb
  }, yt.createElement(ou.Provider, {
    value: j3
  }, e));
}
const q3 = {
  position: "fixed",
  touchAction: "none"
}, G3 = (n) => ru(n) ? "transform 250ms ease" : void 0, K3 = /* @__PURE__ */ Yt((n, e) => {
  let {
    as: t,
    activatorEvent: r,
    adjustScale: i,
    children: o,
    className: a,
    rect: l,
    style: u,
    transform: d,
    transition: h = G3
  } = n;
  if (!l)
    return null;
  const p = i ? d : {
    ...d,
    scaleX: 1,
    scaleY: 1
  }, g = {
    ...q3,
    width: l.width,
    height: l.height,
    top: l.top,
    left: l.left,
    transform: $i.Transform.toString(p),
    transformOrigin: i && r ? U5(r, l) : void 0,
    transition: typeof h == "function" ? h(r) : h,
    ...u
  };
  return yt.createElement(t, {
    className: a,
    style: g,
    ref: e
  }, o);
}), X3 = (n) => (e) => {
  let {
    active: t,
    dragOverlay: r
  } = e;
  const i = {}, {
    styles: o,
    className: a
  } = n;
  if (o != null && o.active)
    for (const [l, u] of Object.entries(o.active))
      u !== void 0 && (i[l] = t.node.style.getPropertyValue(l), t.node.style.setProperty(l, u));
  if (o != null && o.dragOverlay)
    for (const [l, u] of Object.entries(o.dragOverlay))
      u !== void 0 && r.node.style.setProperty(l, u);
  return a != null && a.active && t.node.classList.add(a.active), a != null && a.dragOverlay && r.node.classList.add(a.dragOverlay), function() {
    for (const [u, d] of Object.entries(i))
      t.node.style.setProperty(u, d);
    a != null && a.active && t.node.classList.remove(a.active);
  };
}, J3 = (n) => {
  let {
    transform: {
      initial: e,
      final: t
    }
  } = n;
  return [{
    transform: $i.Transform.toString(e)
  }, {
    transform: $i.Transform.toString(t)
  }];
}, Q3 = {
  duration: 250,
  easing: "ease",
  keyframes: J3,
  sideEffects: /* @__PURE__ */ X3({
    styles: {
      active: {
        opacity: "0"
      }
    }
  })
};
function eL(n) {
  let {
    config: e,
    draggableNodes: t,
    droppableContainers: r,
    measuringConfiguration: i
  } = n;
  return nu((o, a) => {
    if (e === null)
      return;
    const l = t.get(o);
    if (!l)
      return;
    const u = l.node.current;
    if (!u)
      return;
    const d = wb(a);
    if (!d)
      return;
    const {
      transform: h
    } = Tn(a).getComputedStyle(a), p = sb(h);
    if (!p)
      return;
    const g = typeof e == "function" ? e : tL(e);
    return hb(u, i.draggable.measure), g({
      active: {
        id: o,
        data: l.data,
        node: u,
        rect: i.draggable.measure(u)
      },
      draggableNodes: t,
      dragOverlay: {
        node: a,
        rect: i.dragOverlay.measure(d)
      },
      droppableContainers: r,
      measuringConfiguration: i,
      transform: p
    });
  });
}
function tL(n) {
  const {
    duration: e,
    easing: t,
    sideEffects: r,
    keyframes: i
  } = {
    ...Q3,
    ...n
  };
  return (o) => {
    let {
      active: a,
      dragOverlay: l,
      transform: u,
      ...d
    } = o;
    if (!e)
      return;
    const h = {
      x: l.rect.left - a.rect.left,
      y: l.rect.top - a.rect.top
    }, p = {
      scaleX: u.scaleX !== 1 ? a.rect.width * u.scaleX / l.rect.width : 1,
      scaleY: u.scaleY !== 1 ? a.rect.height * u.scaleY / l.rect.height : 1
    }, g = {
      x: u.x - h.x,
      y: u.y - h.y,
      ...p
    }, v = i({
      ...d,
      active: a,
      dragOverlay: l,
      transform: {
        initial: u,
        final: g
      }
    }), [m] = v, w = v[v.length - 1];
    if (JSON.stringify(m) === JSON.stringify(w))
      return;
    const b = r == null ? void 0 : r({
      active: a,
      dragOverlay: l,
      ...d
    }), C = l.node.animate(v, {
      duration: e,
      easing: t,
      fill: "forwards"
    });
    return new Promise((M) => {
      C.onfinish = () => {
        b == null || b(), M();
      };
    });
  };
}
let g1 = 0;
function nL(n) {
  return pe(() => {
    if (n != null)
      return g1++, g1;
  }, [n]);
}
const rL = /* @__PURE__ */ yt.memo((n) => {
  let {
    adjustScale: e = !1,
    children: t,
    dropAnimation: r,
    style: i,
    transition: o,
    modifiers: a,
    wrapperElement: l = "div",
    className: u,
    zIndex: d = 999
  } = n;
  const {
    activatorEvent: h,
    active: p,
    activeNodeRect: g,
    containerNodeRect: v,
    draggableNodes: m,
    droppableContainers: w,
    dragOverlay: b,
    over: C,
    measuringConfiguration: M,
    scrollableAncestors: k,
    scrollableAncestorRects: D,
    windowRect: T
  } = Cb(), R = It(ou), _ = nL(p == null ? void 0 : p.id), Z = Sb(a, {
    activatorEvent: h,
    active: p,
    activeNodeRect: g,
    containerNodeRect: v,
    draggingNodeRect: b.rect,
    over: C,
    overlayNodeRect: b.rect,
    scrollableAncestors: k,
    scrollableAncestorRects: D,
    transform: R,
    windowRect: T
  }), K = Vh(g), $ = eL({
    config: r,
    draggableNodes: m,
    droppableContainers: w,
    measuringConfiguration: M
  }), F = K ? b.setRef : void 0;
  return yt.createElement(Y3, null, yt.createElement(Z3, {
    animation: $
  }, p && _ ? yt.createElement(K3, {
    key: _,
    id: p.id,
    ref: F,
    as: l,
    activatorEvent: h,
    adjustScale: e,
    className: u,
    transition: o,
    rect: K,
    style: {
      zIndex: d,
      ...i
    },
    transform: Z
  }, t) : null));
}), iL = (n) => {
  let {
    transform: e
  } = n;
  return {
    ...e,
    x: 0
  };
};
function Eb(n, e, t) {
  const r = n.slice();
  return r.splice(t < 0 ? r.length + t : t, 0, r.splice(e, 1)[0]), r;
}
function oL(n, e) {
  return n.reduce((t, r, i) => {
    const o = e.get(r);
    return o && (t[i] = o), t;
  }, Array(n.length));
}
function Vl(n) {
  return n !== null && n >= 0;
}
function sL(n, e) {
  if (n === e)
    return !0;
  if (n.length !== e.length)
    return !1;
  for (let t = 0; t < n.length; t++)
    if (n[t] !== e[t])
      return !1;
  return !0;
}
function aL(n) {
  return typeof n == "boolean" ? {
    draggable: n,
    droppable: n
  } : n;
}
const Wh = (n) => {
  let {
    rects: e,
    activeIndex: t,
    overIndex: r,
    index: i
  } = n;
  const o = Eb(e, r, t), a = e[i], l = o[i];
  return !l || !a ? null : {
    x: l.left - a.left,
    y: l.top - a.top,
    scaleX: l.width / a.width,
    scaleY: l.height / a.height
  };
}, kb = "Sortable", Ob = /* @__PURE__ */ yt.createContext({
  activeIndex: -1,
  containerId: kb,
  disableTransforms: !1,
  items: [],
  overIndex: -1,
  useDragOverlay: !1,
  sortedRects: [],
  strategy: Wh,
  disabled: {
    draggable: !1,
    droppable: !1
  }
});
function lL(n) {
  let {
    children: e,
    id: t,
    items: r,
    strategy: i = Wh,
    disabled: o = !1
  } = n;
  const {
    active: a,
    dragOverlay: l,
    droppableRects: u,
    over: d,
    measureDroppableContainers: h
  } = Cb(), p = za(kb, t), g = l.rect !== null, v = pe(() => r.map((R) => typeof R == "object" && "id" in R ? R.id : R), [r]), m = a != null, w = a ? v.indexOf(a.id) : -1, b = d ? v.indexOf(d.id) : -1, C = ge(v), M = !sL(v, C.current), k = b !== -1 && w === -1 || M, D = aL(o);
  mr(() => {
    M && m && h(v);
  }, [M, v, m, h]), be(() => {
    C.current = v;
  }, [v]);
  const T = pe(
    () => ({
      activeIndex: w,
      containerId: p,
      disabled: D,
      disableTransforms: k,
      items: v,
      overIndex: b,
      useDragOverlay: g,
      sortedRects: oL(v, u),
      strategy: i
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [w, p, D.draggable, D.droppable, k, v, b, u, g, i]
  );
  return yt.createElement(Ob.Provider, {
    value: T
  }, e);
}
const cL = (n) => {
  let {
    id: e,
    items: t,
    activeIndex: r,
    overIndex: i
  } = n;
  return Eb(t, r, i).indexOf(e);
}, uL = (n) => {
  let {
    containerId: e,
    isSorting: t,
    wasDragging: r,
    index: i,
    items: o,
    newIndex: a,
    previousItems: l,
    previousContainerId: u,
    transition: d
  } = n;
  return !d || !r || l !== o && i === a ? !1 : t ? !0 : a !== i && e === u;
}, dL = {
  duration: 200,
  easing: "ease"
}, Tb = "transform", fL = /* @__PURE__ */ $i.Transition.toString({
  property: Tb,
  duration: 0,
  easing: "linear"
}), hL = {
  roleDescription: "sortable"
};
function pL(n) {
  let {
    disabled: e,
    index: t,
    node: r,
    rect: i
  } = n;
  const [o, a] = Le(null), l = ge(t);
  return mr(() => {
    if (!e && t !== l.current && r.current) {
      const u = i.current;
      if (u) {
        const d = ws(r.current, {
          ignoreTransform: !0
        }), h = {
          x: u.left - d.left,
          y: u.top - d.top,
          scaleX: u.width / d.width,
          scaleY: u.height / d.height
        };
        (h.x || h.y) && a(h);
      }
    }
    t !== l.current && (l.current = t);
  }, [e, t, r, i]), be(() => {
    o && a(null);
  }, [o]), o;
}
function gL(n) {
  let {
    animateLayoutChanges: e = uL,
    attributes: t,
    disabled: r,
    data: i,
    getNewIndex: o = cL,
    id: a,
    strategy: l,
    resizeObserverConfig: u,
    transition: d = dL
  } = n;
  const {
    items: h,
    containerId: p,
    activeIndex: g,
    disabled: v,
    disableTransforms: m,
    sortedRects: w,
    overIndex: b,
    useDragOverlay: C,
    strategy: M
  } = It(Ob), k = mL(r, v), D = h.indexOf(a), T = pe(() => ({
    sortable: {
      containerId: p,
      index: D,
      items: h
    },
    ...i
  }), [p, i, D, h]), R = pe(() => h.slice(h.indexOf(a)), [h, a]), {
    rect: _,
    node: Z,
    isOver: K,
    setNodeRef: $
  } = U3({
    id: a,
    data: T,
    disabled: k.droppable,
    resizeObserverConfig: {
      updateMeasurementsFor: R,
      ...u
    }
  }), {
    active: F,
    activatorEvent: Y,
    activeNodeRect: Q,
    attributes: ee,
    setNodeRef: ie,
    listeners: re,
    isDragging: oe,
    over: de,
    setActivatorNodeRef: se,
    transform: we
  } = W3({
    id: a,
    data: T,
    attributes: {
      ...hL,
      ...t
    },
    disabled: k.draggable
  }), Oe = T5($, ie), le = !!F, Ce = le && !m && Vl(g) && Vl(b), Ne = !C && oe, me = Ne && Ce ? we : null, ae = Ce ? me ?? (l ?? M)({
    rects: w,
    activeNodeRect: Q,
    activeIndex: g,
    overIndex: b,
    index: D
  }) : null, G = Vl(g) && Vl(b) ? o({
    id: a,
    items: h,
    activeIndex: g,
    overIndex: b
  }) : D, xe = F == null ? void 0 : F.id, ye = ge({
    activeId: xe,
    items: h,
    newIndex: G,
    containerId: p
  }), Je = h !== ye.current.items, te = e({
    active: F,
    containerId: p,
    isDragging: oe,
    isSorting: le,
    id: a,
    index: D,
    items: h,
    newIndex: ye.current.newIndex,
    previousItems: ye.current.items,
    previousContainerId: ye.current.containerId,
    transition: d,
    wasDragging: ye.current.activeId != null
  }), $e = pL({
    disabled: !te,
    index: D,
    node: Z,
    rect: _
  });
  return be(() => {
    le && ye.current.newIndex !== G && (ye.current.newIndex = G), p !== ye.current.containerId && (ye.current.containerId = p), h !== ye.current.items && (ye.current.items = h);
  }, [le, G, p, h]), be(() => {
    if (xe === ye.current.activeId)
      return;
    if (xe && !ye.current.activeId) {
      ye.current.activeId = xe;
      return;
    }
    const vt = setTimeout(() => {
      ye.current.activeId = xe;
    }, 50);
    return () => clearTimeout(vt);
  }, [xe]), {
    active: F,
    activeIndex: g,
    attributes: ee,
    data: T,
    rect: _,
    index: D,
    newIndex: G,
    items: h,
    isOver: K,
    isSorting: le,
    isDragging: oe,
    listeners: re,
    node: Z,
    overIndex: b,
    over: de,
    setNodeRef: Oe,
    setActivatorNodeRef: se,
    setDroppableNodeRef: $,
    setDraggableNodeRef: ie,
    transform: $e ?? ae,
    transition: Be()
  };
  function Be() {
    if (
      // Temporarily disable transitions for a single frame to set up derived transforms
      $e || // Or to prevent items jumping to back to their "new" position when items change
      Je && ye.current.newIndex === D
    )
      return fL;
    if (!(Ne && !ru(Y) || !d) && (le || te))
      return $i.Transition.toString({
        ...d,
        property: Tb
      });
  }
}
function mL(n, e) {
  var t, r;
  return typeof n == "boolean" ? {
    draggable: n,
    // Backwards compatibility
    droppable: !1
  } : {
    draggable: (t = n == null ? void 0 : n.draggable) != null ? t : e.draggable,
    droppable: (r = n == null ? void 0 : n.droppable) != null ? r : e.droppable
  };
}
gt.Down, gt.Right, gt.Up, gt.Left;
const ef = 231, tf = 36, Mb = ({
  layer: n,
  hiddenChild: e
}) => {
  const t = pe(() => {
    const i = {
      width: ef,
      height: tf,
      scale: 1
    }, o = i.width / i.height, a = n.data.props, l = hr(a.boxSize, a.position, a.rotate), u = l.width / l.height;
    return o > u ? (i.height = tf, i.width = i.height * u, i.scale = i.height / l.height) : (i.width = ef, i.height = i.width / u, i.scale = i.width / l.width), i;
  }, [n]), r = pe(() => {
    const i = n.data.props;
    if (i.rotate === 0)
      return {
        x: -i.position.x * t.scale,
        y: -i.position.y * t.scale
      };
    {
      const o = hr(i.boxSize, i.position, i.rotate);
      return {
        x: -o.x * t.scale,
        y: -o.y * t.scale
      };
    }
  }, [n, t]);
  return /* @__PURE__ */ x(
    "div",
    {
      css: {
        width: ef,
        height: tf,
        display: "flex",
        alignItems: "center",
        justifyContent: "center"
      },
      children: /* @__PURE__ */ x(
        "div",
        {
          css: {
            width: t.width,
            height: t.height
          },
          children: /* @__PURE__ */ x(
            "div",
            {
              css: {
                transform: ut({
                  position: r
                })
              },
              children: /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    transformOrigin: "0px 0px",
                    transform: `scale(${t.scale})`
                  },
                  children: e ? Xl(n.data.comp, n.data.props, null) : /* @__PURE__ */ x(ev, { id: n.id, children: /* @__PURE__ */ x(zw, {}) })
                }
              )
            }
          )
        }
      )
    }
  );
};
var vL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M108 60a16 16 0 1 1-16-16 16 16 0 0 1 16 16Zm56 16a16 16 0 1 0-16-16 16 16 0 0 0 16 16Zm-72 36a16 16 0 1 0 16 16 16 16 0 0 0-16-16Zm72 0a16 16 0 1 0 16 16 16 16 0 0 0-16-16Zm-72 68a16 16 0 1 0 16 16 16 16 0 0 0-16-16Zm72 0a16 16 0 1 0 16 16 16 16 0 0 0-16-16Z"
    })
  }));
};
const yL = ({ layer: n, onOpenOption: e, listeners: t, extraCSS: r, ...i }, o) => {
  const { selectedLayerIds: a } = rn();
  return /* @__PURE__ */ W(
    "div",
    {
      ref: o,
      css: {
        background: "#F6F6F6",
        borderRadius: 8,
        padding: 8,
        cursor: "pointer",
        position: "relative",
        borderWidth: 2,
        borderStyle: "solid",
        borderColor: a.includes(n.id) ? "#3d8eff" : "transparent",
        ...r ?? {}
      },
      ...i,
      children: [
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              display: "flex",
              alignItems: "center"
            },
            children: [
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    fontSize: 24,
                    width: 40,
                    height: 40,
                    display: "flex",
                    justifyContent: "center",
                    alignItems: "center",
                    flexShrink: 0
                  },
                  ...t,
                  children: /* @__PURE__ */ x(vL, {})
                }
              ),
              /* @__PURE__ */ x("div", { css: { minWidth: 0, flexGrow: 1 }, children: /* @__PURE__ */ x(Mb, { layer: n }) }),
              fs(n) && /* @__PURE__ */ x("div", { css: { flexShrink: 0, fontSize: 24 }, children: /* @__PURE__ */ x(_w, {}) })
            ]
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              position: "absolute",
              right: 4,
              top: 4,
              background: "#5E6278",
              borderRadius: 8,
              color: "#fff",
              padding: "0 6px"
            },
            onClick: e,
            children: /* @__PURE__ */ x(Kw, {})
          }
        )
      ]
    }
  );
}, Rb = Yt(yL), wL = ({ open: n, children: e }, t) => {
  const [r, i] = Le(
    window.document.getElementById("settings")
  ), o = /* @__PURE__ */ x(
    "div",
    {
      ref: t,
      css: {
        borderRight: "1px solid rgba(57,76,96,.15)",
        background: "#fff",
        width: "100%",
        height: "100%",
        position: "absolute",
        overflowY: "auto",
        pointerEvents: "auto",
        "@media (max-width: 900px)": {
          width: "100%",
          position: "fixed",
          bottom: 0,
          left: 0,
          top: 0,
          background: "#fff"
        }
      },
      children: e
    }
  );
  return be(() => {
    i(window.document.getElementById("settings"));
  }, []), r && n ? A1.createPortal(o, r) : null;
}, su = Yt(
  wL
), bL = (n) => {
  const { transition: e, transform: t, isDragging: r } = n || {}, i = n ? {
    transform: $i.Transform.toString(t || null),
    transition: e,
    zIndex: r ? 1 : "auto",
    opacity: r ? 0.2 : 1,
    touchAction: "none"
  } : {
    boxShadow: "0px 4px 12px rgb(0 0 0 / 10%)"
  }, o = n ? { opacity: n.isDragging ? 0 : 1 } : void 0;
  return { css: i, contentCss: o };
}, xL = ({ layer: n, onOpenOption: e }) => {
  const t = gL({ id: n.id }), { css: r } = bL(t);
  return /* @__PURE__ */ x(
    Rb,
    {
      ref: t.setNodeRef,
      extraCSS: r,
      layer: n,
      listeners: t.listeners,
      onOpenOption: e,
      ...t.attributes
    }
  );
}, SL = ({ ...n }, e) => {
  const t = ge({ isMultipleSelect: !1 }), { selectedLayerIds: r } = rn(), [i, o] = Le(null), { layers: a, actions: l, activePage: u } = je((w) => ({
    layers: w.pages[w.activePage] && w.pages[w.activePage].layers,
    activePage: w.activePage
  })), d = pe(() => {
    if (a)
      return ey(a.ROOT.data.child.map((w) => a[w]));
  }, [a]), h = pe(() => {
    if (a)
      return a.ROOT;
  }, [a]), p = $5(
    Gd(mb),
    Gd(vb),
    Gd(Bh)
  ), g = ({ active: w, over: b }) => {
    if (o(null), !!b && w.id !== b.id) {
      const C = d.length - d.findIndex((M) => M.id === b.id) - 1;
      l.moveLayerPosition(u, w.id, C);
    }
  }, v = (w) => {
    l.showContextMenu(Wt(w.nativeEvent));
  };
  be(() => {
    const w = (b) => {
      t.current.isMultipleSelect = b.shiftKey;
    };
    return window.addEventListener("keydown", w), window.addEventListener("keyup", w), () => {
      window.removeEventListener("keydown", w), window.removeEventListener("keyup", w);
    };
  }, []);
  const m = pe(
    () => (d || []).find((w) => w.id === i),
    [d, i]
  );
  return /* @__PURE__ */ x(su, { ...n, children: /* @__PURE__ */ x(Mo.Provider, { value: { pageIndex: u }, children: /* @__PURE__ */ W(
    "div",
    {
      css: {
        width: "100%",
        height: "100%",
        display: "flex",
        flexDirection: "column",
        overflowY: "auto"
      },
      children: [
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              flexShrink: 0,
              height: 48,
              borderBottom: "1px solid rgba(57,76,96,.15)",
              padding: "0 20px"
            },
            children: [
              /* @__PURE__ */ x(
                "p",
                {
                  css: {
                    lineHeight: "48px",
                    fontWeight: 600,
                    color: "#181C32",
                    flexGrow: 1
                  },
                  children: "Layers"
                }
              ),
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    fontSize: 20,
                    flexShrink: 0,
                    width: 32,
                    height: 32,
                    cursor: "pointer",
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "center"
                  },
                  onClick: () => {
                    l.setSidebar();
                  },
                  children: /* @__PURE__ */ x(Ro, {})
                }
              )
            ]
          }
        ),
        /* @__PURE__ */ x(
          B3,
          {
            modifiers: [iL],
            sensors: p,
            onDragCancel: () => o(null),
            onDragEnd: g,
            onDragStart: ({ active: w }) => {
              w && o(w.id);
            },
            children: /* @__PURE__ */ x(
              "div",
              {
                ref: e,
                css: {
                  flexGrow: 1,
                  overflowY: "auto"
                },
                children: /* @__PURE__ */ W(
                  "div",
                  {
                    css: {
                      display: "grid",
                      gridTemplateColumns: "minmax(0,1fr)",
                      gridRowGap: 8,
                      padding: 16
                    },
                    children: [
                      /* @__PURE__ */ W(
                        lL,
                        {
                          items: (d || []).map((w) => w.id),
                          strategy: Wh,
                          children: [
                            L1(
                              /* @__PURE__ */ x(rL, { children: m ? /* @__PURE__ */ x(Rb, { layer: m }) : null }),
                              document.body
                            ),
                            (d || []).map((w) => /* @__PURE__ */ x(
                              xL,
                              {
                                layer: w,
                                onMouseDown: () => {
                                  l.selectLayers(
                                    u,
                                    w.id,
                                    t.current.isMultipleSelect ? "add" : "replace"
                                  );
                                },
                                onOpenOption: v
                              },
                              w.id
                            ))
                          ]
                        }
                      ),
                      h && /* @__PURE__ */ x(
                        "div",
                        {
                          css: {
                            background: "#F6F6F6",
                            borderRadius: 8,
                            padding: 8,
                            cursor: "pointer",
                            position: "relative",
                            borderWidth: 2,
                            borderStyle: "solid",
                            borderColor: r.includes(h.id) ? "#3d8eff" : "transparent"
                          },
                          onMouseDown: () => {
                            l.selectLayers(
                              u,
                              h.id,
                              t.current.isMultipleSelect ? "add" : "replace"
                            );
                          },
                          children: /* @__PURE__ */ W(
                            "div",
                            {
                              css: {
                                display: "flex",
                                alignItems: "center"
                              },
                              children: [
                                /* @__PURE__ */ x(
                                  "div",
                                  {
                                    css: {
                                      width: 40,
                                      height: 40,
                                      display: "flex",
                                      justifyContent: "center",
                                      alignItems: "center",
                                      flexShrink: 0
                                    }
                                  }
                                ),
                                /* @__PURE__ */ x("div", { css: { minWidth: 0, flexGrow: 1 }, children: /* @__PURE__ */ x(
                                  Mb,
                                  {
                                    hiddenChild: !0,
                                    layer: h
                                  }
                                ) }),
                                /* @__PURE__ */ x("div", { css: { flexShrink: 0, fontSize: 24 }, children: /* @__PURE__ */ x(Gl, {}) })
                              ]
                            }
                          )
                        }
                      )
                    ]
                  }
                )
              }
            )
          }
        )
      ]
    }
  ) }) });
}, CL = Yt(SL), EL = () => {
  const n = ge(null), e = ge(null), t = ge(null), r = ge(null), [i, o] = Le(!1), [a, l] = Le(!1), [u, d] = Le(!1), { selectedLayers: h, selectedLayerIds: p } = rn(), { actions: g, activePage: v, sidebar: m, pageSize: w, isPageLocked: b } = je(
    ($, F) => ({
      activePage: $.activePage,
      sidebar: $.sidebar,
      pageSize: F.getPageSize(),
      isPageLocked: $.pages[$.activePage] && $.pages[$.activePage].layers.ROOT.data.locked
    })
  ), [C, M] = Le(w);
  be(() => {
    M(w);
  }, [w]);
  const { transparency: k } = pe(() => Object.entries(h).reduce(
    ($, [, F]) => {
      var Y;
      return Fi(F) ? $.transparency = Math.max(
        $.transparency,
        typeof ((Y = F.data.props.image) == null ? void 0 : Y.transparency) < "u" ? F.data.props.image.transparency : 1
      ) : $.transparency = Math.max(
        $.transparency,
        typeof F.data.props.transparency < "u" ? F.data.props.transparency : 1
      ), $;
    },
    { transparency: 0 }
  ), [h]), D = !!h.find(($) => $.data.locked), T = () => {
    D ? g.unlock(v, p) : g.lock(v, p);
  }, R = ($) => {
    p.forEach((F) => {
      F === "ROOT" ? g.history.throttle(2e3).setProp(v, F, {
        image: {
          transparency: $ / 100
        }
      }) : g.history.throttle(2e3).setProp(v, F, {
        transparency: $ / 100
      });
    });
  };
  be(() => {
    o(!1);
  }, [JSON.stringify(p)]);
  const _ = ($, F) => {
    const Y = C.width / C.height, Q = parseInt($, 10);
    F === "width" && (u && (r.current.value = String(
      Math.round(Q / Y * 10) / 10
    )), M({ ...C, width: Q })), F === "height" && (u && (t.current.value = String(
      Math.round(Q * Y * 10) / 10
    )), M({ ...C, height: Q }));
  }, Z = pe(
    () => C.width < 100 || C.height < 100,
    [C]
  ), K = () => {
    Z || (g.changePageSize(C), l(!1));
  };
  return /* @__PURE__ */ W(Tt, { children: [
    /* @__PURE__ */ W(
      "div",
      {
        css: {
          display: "grid",
          alignItems: "center",
          gridAutoFlow: "column",
          gridGap: 8
        },
        children: [
          /* @__PURE__ */ x(Dt, { onClick: () => g.setSidebar("LAYER_MANAGEMENT"), children: /* @__PURE__ */ x("span", { css: { padding: "0 4px" }, children: "Position" }) }),
          p.length > 0 && !D && !b && (!Fi(h[0]) || Fi(h[0]) && h[0].data.props.image) && /* @__PURE__ */ W(Tt, { children: [
            /* @__PURE__ */ x(
              "div",
              {
                css: {
                  height: 24,
                  width: "1px",
                  background: "rgba(57,76,96,.15)"
                }
              }
            ),
            /* @__PURE__ */ x(
              Dt,
              {
                ref: n,
                css: { fontSize: 20 },
                onClick: () => o(!0),
                children: /* @__PURE__ */ x(S5, {})
              }
            ),
            /* @__PURE__ */ x(
              gr,
              {
                anchorEl: n.current,
                offsets: {
                  "bottom-end": { x: 0, y: 8 }
                },
                open: i,
                placement: "bottom-end",
                onClose: () => o(!1),
                children: /* @__PURE__ */ x("div", { css: { padding: 16 }, children: /* @__PURE__ */ x(
                  Hi,
                  {
                    defaultValue: k * 100,
                    label: "Transparency",
                    onChange: R
                  }
                ) })
              }
            )
          ] }),
          !b && /* @__PURE__ */ W(Tt, { children: [
            /* @__PURE__ */ x(
              "div",
              {
                css: {
                  height: 24,
                  width: "1px",
                  background: "rgba(57,76,96,.15)"
                }
              }
            ),
            /* @__PURE__ */ x(
              Dt,
              {
                ref: e,
                onClick: () => l(!0),
                children: /* @__PURE__ */ x("span", { css: { padding: "0 4px" }, children: "Resize" })
              }
            )
          ] }),
          /* @__PURE__ */ x(
            gr,
            {
              anchorEl: e.current,
              offsets: {
                "bottom-end": { x: 0, y: 8 }
              },
              open: a,
              placement: "bottom-end",
              onClose: () => l(!1),
              children: /* @__PURE__ */ W("div", { css: { padding: 16, width: 240 }, children: [
                /* @__PURE__ */ W("div", { css: { display: "flex", gap: 8, alignItems: "flex-end" }, children: [
                  /* @__PURE__ */ W("div", { children: [
                    /* @__PURE__ */ x("div", { css: { fontSize: 12, fontWeight: 600 }, children: "Width" }),
                    /* @__PURE__ */ x(
                      "div",
                      {
                        css: {
                          border: "1px solid rgba(43,59,74,.3)",
                          height: 40,
                          padding: "0 12px",
                          width: 80,
                          borderRadius: 4
                        },
                        children: /* @__PURE__ */ x(
                          "input",
                          {
                            ref: t,
                            css: { width: "100%", minWidth: 8, height: "100%" },
                            defaultValue: C.width,
                            onChange: ($) => _($.target.value, "width")
                          }
                        )
                      }
                    )
                  ] }),
                  /* @__PURE__ */ W("div", { children: [
                    /* @__PURE__ */ x("div", { css: { fontSize: 12, fontWeight: 600 }, children: "Height" }),
                    /* @__PURE__ */ x(
                      "div",
                      {
                        css: {
                          border: "1px solid rgba(43,59,74,.3)",
                          height: 40,
                          padding: "0 12px",
                          width: 80,
                          borderRadius: 4
                        },
                        children: /* @__PURE__ */ x(
                          "input",
                          {
                            ref: r,
                            css: { width: "100%", minWidth: 8, height: "100%" },
                            defaultValue: C.height,
                            onChange: ($) => _($.target.value, "height")
                          }
                        )
                      }
                    )
                  ] }),
                  /* @__PURE__ */ x(
                    "div",
                    {
                      css: { fontSize: 20, cursor: "pointer", margin: "10px 0" },
                      onClick: () => d(!u),
                      children: u ? /* @__PURE__ */ x(ma, {}) : /* @__PURE__ */ x(Ff, {})
                    }
                  )
                ] }),
                Z && /* @__PURE__ */ x("div", { css: { color: "#db1436" }, children: "Dimensions must be at least 100px and no more than 8000px." }),
                /* @__PURE__ */ x("div", { css: { marginTop: 12 }, children: /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      background: Z ? "#8383A2" : "#3a3a4c",
                      padding: "8px 14px",
                      lineHeight: 1,
                      color: "#FFF",
                      borderRadius: 4,
                      cursor: Z ? "not-allowed" : "pointer",
                      fontSize: 16,
                      textAlign: "center",
                      fontWeight: 700
                    },
                    onClick: K,
                    children: "Resize"
                  }
                ) })
              ] })
            }
          ),
          p.length > 0 && /* @__PURE__ */ W(
            Dt,
            {
              css: { fontSize: 20 },
              isActive: D,
              onClick: T,
              children: [
                D && /* @__PURE__ */ x(ma, {}),
                !D && /* @__PURE__ */ x(Ff, {})
              ]
            }
          )
        ]
      }
    ),
    m === "LAYER_MANAGEMENT" && /* @__PURE__ */ x(CL, { open: !0 })
  ] });
}, nf = [
  ["#000000", "#545454", "#737373", "#a6a6a6", "#d9d9d9", "#ffffff"],
  ["#ff3131", "#FF5757", "#FF66C4", "#CB6CE6", "#8C52FF", "#5E17EB"],
  ["#0097B2", "#0CC0DF", "#5CE1E6", "#38B6FF", "#5271FF", "#004AAD"],
  ["#00BF62", "#7ED957", "#C1FF72", "#FFDE59", "#FFBD59", "#FF914D"]
], m1 = ({
  color: n,
  event: e,
  onChange: t,
  children: r
}) => {
  const i = ge(null), [o, a] = Le(!1);
  return /* @__PURE__ */ W(Tt, { children: [
    /* @__PURE__ */ x(
      "div",
      {
        ref: i,
        css: { cursor: "pointer" },
        onClick: () => e === "click" && a(!0),
        onDoubleClick: () => e === "doubleClick" && a(!0),
        children: r
      }
    ),
    /* @__PURE__ */ x(
      gr,
      {
        anchorEl: i.current,
        offsets: { bottom: { y: 8, x: 0 } },
        open: o,
        placement: "bottom",
        onClose: () => a(!1),
        children: /* @__PURE__ */ x("div", { css: { padding: 16, width: 280 }, children: /* @__PURE__ */ x(ec, { color: new Nt(n).toHex(), onChange: t }) })
      }
    )
  ] });
}, kL = [
  "leftToRight",
  "topToBottom",
  "topLeftToBottomRight",
  "circleCenter",
  "circleTopLeft"
], rf = ({
  selectedColor: n,
  gradient: e,
  event: t,
  children: r,
  onChangeGradient: i,
  onChangeColor: o
}) => {
  const a = ge(null), l = ge(null), u = ge([]), [d, h] = Le(!1), [p, g] = Le(null), [v, m] = Le(e ? "gradient" : "solid"), [w, b] = Le(), [C, M] = Le(n), k = pe(() => {
    if (e != null && e.colors.length)
      return e == null ? void 0 : e.colors;
    {
      const $ = new Nt(n), F = $.toHsl();
      return F.l < 50 ? F.l = Math.min(100, F.l + 30) : F.l = Math.max(0, F.l - 30), [$.toRgbString(), new Nt(F).toRgbString()];
    }
  }, [e, n]);
  be(() => {
    d && b({
      colors: k,
      style: (e == null ? void 0 : e.style) || "leftToRight"
    });
  }, [d]), be(() => {
    w && v === "gradient" && i(w);
  }, [w, v, i]);
  const D = ($) => {
    M($), o($);
  }, T = ($) => {
    b({
      colors: k,
      style: $
    });
  }, R = ($) => {
    if (p) {
      const F = [...k];
      F[p.index] = new Nt($).toRgbString(), b({
        colors: F,
        style: (w == null ? void 0 : w.style) || "leftToRight"
      });
    }
  }, _ = () => {
    const $ = k[k.length - 1];
    b({
      colors: [...k, $],
      style: (e == null ? void 0 : e.style) || "leftToRight"
    }), g({ index: k.length, color: $ });
  }, Z = () => {
    b({
      colors: (w == null ? void 0 : w.colors) || [],
      style: (w == null ? void 0 : w.style) || "leftToRight"
    });
  }, K = ($) => {
    w && b({
      colors: w.colors.filter((F, Y) => Y !== $),
      style: w.style
    });
  };
  return /* @__PURE__ */ W(Tt, { children: [
    /* @__PURE__ */ x(
      "div",
      {
        ref: l,
        css: { cursor: "pointer" },
        onClick: () => t === "click" && h(!0),
        onDoubleClick: () => t === "doubleClick" && h(!0),
        children: r
      }
    ),
    /* @__PURE__ */ x(
      gr,
      {
        ref: a,
        anchorEl: l.current,
        offsets: { bottom: { y: 8, x: 0 } },
        open: d,
        placement: "bottom",
        onClose: () => {
          h(!1), g(null);
        },
        children: /* @__PURE__ */ W("div", { css: { padding: "0 16px 16px 16px", width: 280 }, children: [
          /* @__PURE__ */ W(
            "div",
            {
              css: {
                display: "flex",
                justifyContent: "center",
                marginBottom: 12,
                borderBottom: "1px solid rgba(217, 219, 228, 0.6)"
              },
              children: [
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      display: "inline-block",
                      cursor: "pointer",
                      padding: 8,
                      flexGrow: 1,
                      textAlign: "center",
                      overflow: "hidden",
                      flexShrink: 0,
                      fontWeight: 700,
                      whiteSpace: "nowrap",
                      color: v === "solid" ? "#3d8eff" : "rgba(13,18,22,.7)"
                    },
                    onClick: () => {
                      m("solid"), o(C);
                    },
                    children: "Solid Color"
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      display: "inline-block",
                      cursor: "pointer",
                      padding: 8,
                      flexGrow: 1,
                      textAlign: "center",
                      overflow: "hidden",
                      flexShrink: 0,
                      fontWeight: 700,
                      whiteSpace: "nowrap",
                      color: v === "gradient" ? "#3d8eff" : "rgba(13,18,22,.7)"
                    },
                    onClick: () => {
                      m("gradient"), Z();
                    },
                    children: "Gradient"
                  }
                )
              ]
            }
          ),
          v === "solid" && /* @__PURE__ */ x("div", { css: {}, children: /* @__PURE__ */ x(
            ec,
            {
              color: new Nt(C).toHex(),
              onChange: D
            }
          ) }),
          v === "gradient" && /* @__PURE__ */ W(
            "div",
            {
              css: {
                display: "grid",
                rowGap: 12
              },
              children: [
                /* @__PURE__ */ W("div", { children: [
                  /* @__PURE__ */ x("div", { css: { fontWeight: 700, lineHeight: 2.2 }, children: "Gradient colors" }),
                  /* @__PURE__ */ W(
                    "div",
                    {
                      css: {
                        display: "grid",
                        gridTemplateColumns: " repeat(auto-fill, minmax(40px, 1fr))",
                        gridGap: 8
                      },
                      children: [
                        w == null ? void 0 : w.colors.map(($, F) => /* @__PURE__ */ W("div", { css: { position: "relative" }, children: [
                          /* @__PURE__ */ x(
                            qs,
                            {
                              ref: (Y) => u.current[F] = Y,
                              color: $,
                              selected: null,
                              onClick: () => g({ index: F, color: $ })
                            }
                          ),
                          /* @__PURE__ */ x(
                            "div",
                            {
                              css: {
                                position: "absolute",
                                top: -8,
                                right: -8,
                                fontSize: 12,
                                padding: 4,
                                borderRadius: "50%",
                                opacity: 0,
                                transition: "opacity .15s ease-in-out",
                                background: "rgba(17,23,29,.6)",
                                color: "#fff",
                                display: (w == null ? void 0 : w.colors.length) > 2 ? "block" : "none",
                                cursor: "pointer",
                                ":hover": {
                                  opacity: 1
                                }
                              },
                              onClick: () => (w == null ? void 0 : w.colors.length) > 2 && K(F),
                              children: /* @__PURE__ */ x(Ro, {})
                            }
                          )
                        ] }, F)),
                        /* @__PURE__ */ x(
                          gr,
                          {
                            anchorEl: p && u.current[p.index],
                            element: a.current,
                            offsets: { bottom: { y: 8, x: 0 } },
                            open: !!p,
                            placement: "bottom",
                            onClose: () => g(null),
                            children: /* @__PURE__ */ x("div", { css: { padding: 16, width: 280 }, children: /* @__PURE__ */ x(
                              ec,
                              {
                                color: new Nt(
                                  (p == null ? void 0 : p.color) || "#f25022"
                                ).toHex(),
                                enableAlpha: !0,
                                onChange: R
                              }
                            ) })
                          }
                        ),
                        /* @__PURE__ */ x(
                          "div",
                          {
                            css: {
                              paddingBottom: "100%",
                              position: "relative",
                              width: "100%",
                              cursor: "pointer"
                            },
                            onClick: _,
                            children: /* @__PURE__ */ x(
                              "div",
                              {
                                css: {
                                  background: "rgba(64,87,109,.07)",
                                  fontSize: 24,
                                  display: "flex",
                                  alignItems: "center",
                                  justifyContent: "center",
                                  position: "absolute",
                                  inset: 0,
                                  borderRadius: 4,
                                  transition: "background-color .1s linear,border-color .1s linear,color .1s linear",
                                  ":hover": {
                                    background: "rgba(57,76,96,.15)"
                                  }
                                },
                                children: /* @__PURE__ */ x(ua, {})
                              }
                            )
                          }
                        )
                      ]
                    }
                  )
                ] }),
                /* @__PURE__ */ W("div", { children: [
                  /* @__PURE__ */ x("div", { css: { fontWeight: 700, lineHeight: 2.2 }, children: "Style" }),
                  /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        display: "grid",
                        columnGap: 8,
                        gridAutoFlow: "column"
                      },
                      children: kL.map(($) => /* @__PURE__ */ x(
                        "div",
                        {
                          css: {
                            width: "100%",
                            height: 40,
                            borderRadius: 4,
                            overflow: "hidden"
                          },
                          onClick: () => T($),
                          children: /* @__PURE__ */ x(
                            "div",
                            {
                              css: {
                                backgroundColor: "#fff",
                                backgroundPosition: "0 0, 6px 6px",
                                backgroundSize: "12px 12px",
                                width: "100%",
                                height: "100%",
                                position: "relative",
                                backgroundImage: "linear-gradient(-45deg,rgba(57,76,96,.15) 25%,transparent 25%,transparent 75%,rgba(57,76,96,.15) 75%),linear-gradient(-45deg,rgba(57,76,96,.15) 25%,transparent 25%,transparent 75%,rgba(57,76,96,.15) 75%)"
                              },
                              children: /* @__PURE__ */ x(
                                "div",
                                {
                                  css: {
                                    background: Ql(
                                      k,
                                      $
                                    ),
                                    position: "absolute",
                                    inset: 0
                                  }
                                }
                              )
                            }
                          )
                        },
                        $
                      ))
                    }
                  )
                ] })
              ]
            }
          )
        ] })
      }
    )
  ] });
}, OL = ({ selected: n, gradient: e, useGradient: t, onSelect: r, onChangeGradient: i, ...o }, a) => {
  const [l, u] = Le(null), [d, h] = Le(null), [p] = Le(n), { actions: g, state: v } = je(), m = pe(() => v.pages.reduce((R, _) => (Object.entries(_.layers).forEach(([, Z]) => {
    Fi(Z) && Z.data.props.color || xc(Z) && Z.data.props.color ? R.push(Z.data.props.color) : ui(Z) ? R.push(...Z.data.props.colors) : kh(Z) ? R.push(...Z.data.props.colors) : Iw(Z) && R.push(Z.data.props.color);
  }), Te.uniq(R)), []), []), w = pe(() => {
    const R = v.pages.reduce((_, Z) => (Object.entries(Z.layers).forEach(([, K]) => {
      (Fi(K) && K.data.props.gradientBackground || xc(K) && K.data.props.gradientBackground) && _.push(K.data.props.gradientBackground);
    }), _), []);
    return Te.uniqWith(R, Te.isEqual);
  }, []), b = pe(() => {
    if (l) {
      const R = m.findIndex(
        (_) => p && _ === new Nt(p).toRgbString()
      );
      return Te.uniq([
        ...m.slice(0, R),
        l,
        ...m.slice(R, m.length)
      ]);
    } else
      return m;
  }, [m, l, p]), C = pe(() => {
    if (d) {
      const R = w.findIndex((_) => Te.isEqual(_, e));
      return Te.uniqWith(
        [
          ...w.slice(0, R),
          d,
          ...w.slice(R, w.length)
        ],
        Te.isEqual
      );
    } else
      return w;
  }, [w, d, e]), M = (R) => {
    Te.isEqual(R, l) || (u(null), h(null)), r(new Nt(R).toRgbString());
  }, k = (R) => {
    Te.isEqual(R, d) || (u(null), h(null)), i && i(R);
  }, D = (R) => {
    u(R), h(null), r(R);
  }, T = (R) => {
    u(null), h(R), i && i(R);
  };
  return /* @__PURE__ */ W(su, { ref: a, ...o, children: [
    /* @__PURE__ */ W(
      "div",
      {
        css: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          height: 48,
          borderBottom: "1px solid rgba(57,76,96,.15)",
          padding: "0 20px"
        },
        children: [
          /* @__PURE__ */ x(
            "p",
            {
              css: {
                lineHeight: "48px",
                fontWeight: 600,
                color: "#181C32",
                flexGrow: 1
              },
              children: "Colors"
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                fontSize: 20,
                flexShrink: 0,
                width: 32,
                height: 32,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              onClick: () => {
                g.setSidebar();
              },
              children: /* @__PURE__ */ x(Ro, {})
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ W("div", { css: { padding: "0 20px", display: "grid", rowGap: 24 }, children: [
      /* @__PURE__ */ W("div", { children: [
        /* @__PURE__ */ x("div", { css: { padding: "8px 0", fontWeight: 700 }, children: "Document colors" }),
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              display: "grid",
              gridGap: 12,
              gridTemplateColumns: `repeat(${nf[0].length},minmax(0,1fr))`
            },
            children: [
              t && i && /* @__PURE__ */ x(
                rf,
                {
                  event: "click",
                  gradient: d || e,
                  selectedColor: new Nt(
                    l || n || "#f25022"
                  ).toHex(),
                  onChangeColor: (R) => {
                    D(new Nt(R).toRgbString());
                  },
                  onChangeGradient: T,
                  children: /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        paddingBottom: "100%",
                        position: "relative",
                        width: "100%"
                      },
                      children: /* @__PURE__ */ x(
                        "div",
                        {
                          css: {
                            borderRadius: 4,
                            overflow: "hidden",
                            background: "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)",
                            width: "100%",
                            height: "100%",
                            position: "absolute",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center"
                          },
                          children: /* @__PURE__ */ x(
                            "div",
                            {
                              css: {
                                fontSize: 16,
                                width: 24,
                                height: 24,
                                background: "#fff",
                                borderRadius: "50%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center"
                              },
                              children: /* @__PURE__ */ x(ua, {})
                            }
                          )
                        }
                      )
                    }
                  )
                }
              ),
              !t && /* @__PURE__ */ x(
                m1,
                {
                  color: p || "#f25022",
                  event: "click",
                  onChange: M,
                  children: /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        paddingBottom: "100%",
                        position: "relative",
                        width: "100%"
                      },
                      children: /* @__PURE__ */ x(
                        "div",
                        {
                          css: {
                            borderRadius: 4,
                            overflow: "hidden",
                            background: "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)",
                            width: "100%",
                            height: "100%",
                            position: "absolute",
                            display: "flex",
                            alignItems: "center",
                            justifyContent: "center"
                          },
                          children: /* @__PURE__ */ x(
                            "div",
                            {
                              css: {
                                fontSize: 16,
                                width: 24,
                                height: 24,
                                background: "#fff",
                                borderRadius: "50%",
                                display: "flex",
                                alignItems: "center",
                                justifyContent: "center"
                              },
                              children: /* @__PURE__ */ x(ua, {})
                            }
                          )
                        }
                      )
                    }
                  )
                }
              ),
              b.map((R, _) => {
                const Z = /* @__PURE__ */ x(
                  qs,
                  {
                    color: R,
                    selected: n,
                    onClick: () => n !== R && M(R)
                  }
                );
                return t && i ? /* @__PURE__ */ x(
                  rf,
                  {
                    event: "doubleClick",
                    gradient: d || e,
                    selectedColor: new Nt(
                      l || n || "#f25022"
                    ).toHex(),
                    onChangeColor: (K) => {
                      const $ = pf(K);
                      D($);
                    },
                    onChangeGradient: T,
                    children: Z
                  },
                  _
                ) : /* @__PURE__ */ x(
                  m1,
                  {
                    color: p || "#f25022",
                    event: "doubleClick",
                    onChange: M,
                    children: Z
                  },
                  _
                );
              }),
              t && i && C.map((R, _) => /* @__PURE__ */ x(
                rf,
                {
                  event: "doubleClick",
                  gradient: d || e,
                  selectedColor: new Nt(
                    l || n || "#f25022"
                  ).toHex(),
                  onChangeColor: (Z) => {
                    const K = pf(Z);
                    D(K);
                  },
                  onChangeGradient: T,
                  children: /* @__PURE__ */ x(
                    qs,
                    {
                      color: Ql(R.colors, R.style),
                      selected: e && Ql(
                        e.colors,
                        e.style
                      ) || null,
                      onClick: () => k(R)
                    }
                  )
                },
                _
              ))
            ]
          }
        )
      ] }),
      /* @__PURE__ */ W("div", { css: { borderTop: "1px solid rgba(217, 219, 228, 0.6)" }, children: [
        /* @__PURE__ */ x("div", { css: { padding: "8px 0", fontWeight: 700 }, children: "Default Colors" }),
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              display: "grid",
              gridGap: 12,
              gridTemplateColumns: `repeat(${nf[0].length},minmax(0,1fr))`
            },
            children: nf.map(
              (R) => R.map((_, Z) => /* @__PURE__ */ x(
                qs,
                {
                  color: _,
                  selected: n,
                  onClick: () => M(_)
                },
                Z
              ))
            )
          }
        )
      ] })
    ] })
  ] });
}, Hh = Yt(OL), Sa = ({
  colors: n,
  gradient: e,
  useGradient: t,
  children: r,
  onChange: i,
  onChangeGradient: o
}) => {
  const { actions: a, sidebar: l } = je((d) => ({
    sidebar: d.sidebar
  })), u = pe(() => (n.length === 0 || n.length === 1 && new Nt(n[0]).white() === 100) && !e ? "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)" : e ? Ql(e.colors, e.style) : n.map((d) => `linear-gradient(to right, ${d}, ${d})`).join(", "), [n, e]);
  return /* @__PURE__ */ W(Tt, { children: [
    /* @__PURE__ */ W(Dt, { onClick: () => a.setSidebar("CHOOSING_COLOR"), children: [
      !r && /* @__PURE__ */ x(
        "div",
        {
          css: {
            width: 24,
            height: 24,
            boxShadow: "inset 0 0 0 1px rgba(57,76,96,.15)",
            borderRadius: 2,
            position: "relative",
            overflow: "hidden"
          },
          children: /* @__PURE__ */ x(
            "div",
            {
              css: {
                backgroundColor: "#fff",
                backgroundPosition: "0 0, 6px 6px",
                backgroundSize: "12px 12px",
                inset: 0,
                position: "absolute",
                backgroundImage: "linear-gradient(-45deg,rgba(57,76,96,.15) 25%,transparent 25%,transparent 75%,rgba(57,76,96,.15) 75%),linear-gradient(-45deg,rgba(57,76,96,.15) 25%,transparent 25%,transparent 75%,rgba(57,76,96,.15) 75%)"
              },
              children: /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    position: "absolute",
                    inset: 0,
                    background: u
                  }
                }
              )
            }
          )
        }
      ),
      r
    ] }),
    l === "CHOOSING_COLOR" && /* @__PURE__ */ x(
      Hh,
      {
        gradient: e,
        open: !0,
        selected: n.length === 1 ? n[0] : null,
        useGradient: t,
        onChangeGradient: o,
        onSelect: i
      }
    )
  ] });
}, TL = ({ layers: n }) => {
  const { actions: e, activePage: t } = je((l) => ({
    activePage: l.activePage,
    sidebar: l.sidebar
  })), r = pe(() => n.map((l) => l.data.props.color).filter((l) => !!l), [n]), i = pe(() => n.map((l) => l.data.props.gradientBackground).filter((l) => !!l), [n]), o = (l) => {
    const u = n.map((d) => d.id);
    e.history.throttle(2e3).setProp(t, u, {
      color: l,
      gradientBackground: null
    });
  }, a = (l) => {
    const u = n.map((d) => d.id);
    e.history.throttle(2e3).setProp(t, u, {
      gradientBackground: l,
      color: null
    });
  };
  return /* @__PURE__ */ x(
    Sa,
    {
      colors: r,
      gradient: i.length > 0 ? i[0] : null,
      useGradient: !0,
      onChange: o,
      onChangeGradient: a
    }
  );
};
var Db = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M208 28H48a20 20 0 0 0-20 20v160a20 20 0 0 0 20 20h160a20 20 0 0 0 20-20V48a20 20 0 0 0-20-20Zm-4 176H52V52h152Z"
    })
  }));
}, Ib = function(e) {
  return /* @__PURE__ */ Pc("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    width: "1em",
    height: "1em"
  }, e, {
    children: [/* @__PURE__ */ q("rect", {
      width: 20,
      height: 2,
      x: 2,
      y: 4,
      fill: "currentColor",
      rx: 0.75
    }), /* @__PURE__ */ q("rect", {
      width: 20,
      height: 3.5,
      x: 2,
      y: 8.5,
      fill: "currentColor",
      rx: 1
    }), /* @__PURE__ */ q("rect", {
      width: 20,
      height: 6,
      x: 2,
      y: 14.5,
      fill: "currentColor",
      rx: 1
    })]
  }));
}, Ab = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e, {
    children: /* @__PURE__ */ q("line", {
      x2: 24,
      y1: "50%",
      y2: "50%",
      stroke: "currentColor",
      strokeDasharray: "2 2",
      strokeWidth: 2
    })
  }));
}, Lb = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e, {
    children: /* @__PURE__ */ q("line", {
      x2: 24,
      y1: "50%",
      y2: "50%",
      stroke: "currentColor",
      strokeDasharray: "11 2",
      strokeWidth: 2
    })
  }));
}, Pb = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e, {
    children: /* @__PURE__ */ q("line", {
      x2: 24,
      y1: "50%",
      y2: "50%",
      stroke: "currentColor",
      strokeDasharray: "6 2",
      strokeWidth: 2
    })
  }));
}, _b = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, e, {
    children: /* @__PURE__ */ q("line", {
      x2: 24,
      y1: "50%",
      y2: "50%",
      stroke: "currentColor",
      strokeWidth: 2
    })
  }));
}, Ca = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "m229.66 77.66-128 128a8 8 0 0 1-11.32 0l-56-56a8 8 0 0 1 11.32-11.32L96 188.69 218.34 66.34a8 8 0 0 1 11.32 11.32Z"
    })
  }));
};
const v1 = {
  none: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M5 12v-.75h16a.75.75 0 0 1 0 1.5H5V12z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x("path", { d: "M5 9.5v5L3 12l2-2.5z", fill: "currentColor" })
  ] }),
  bar: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M3.25 12a.75.75 0 0 1 .75-.75h16.5a.75.75 0 0 1 0 1.5H4a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M3.75 8a.75.75 0 0 1 .75.75v6.5a.75.75 0 0 1-1.5 0v-6.5A.75.75 0 0 1 3.75 8z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    )
  ] }),
  arrow: /* @__PURE__ */ x("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: /* @__PURE__ */ x(
    "path",
    {
      clipRule: "evenodd",
      d: "M2.97 12.53a.75.75 0 0 1 0-1.06l4.773-4.773a.75.75 0 0 1 1.06 1.06L5.311 11.25H20.5a.75.75 0 0 1 0 1.5H5.31l3.493 3.493a.75.75 0 1 1-1.06 1.06L2.97 12.53z",
      fill: "currentColor",
      fillRule: "evenodd"
    }
  ) }),
  triangle: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M9.75 12a.75.75 0 0 1 .75-.75h10a.75.75 0 0 1 0 1.5h-10a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        d: "M2.624 11.584a.5.5 0 0 0 0 .832l7.599 5.066a.5.5 0 0 0 .777-.416V6.934a.5.5 0 0 0-.777-.416l-7.599 5.066z",
        fill: "currentColor"
      }
    )
  ] }),
  outlineCircle: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M9.75 12a.75.75 0 0 1 .75-.75h10a.75.75 0 0 1 0 1.5h-10a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M4.5 12a2.5 2.5 0 1 0 5 0 2.5 2.5 0 0 0-5 0zM7 8a4 4 0 1 0 0 8 4 4 0 0 0 0-8z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    )
  ] }),
  circle: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M9.75 12a.75.75 0 0 1 .75-.75h10a.75.75 0 0 1 0 1.5h-10a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x("path", { d: "M3 12a4 4 0 1 1 8 0 4 4 0 0 1-8 0z", fill: "currentColor" })
  ] }),
  outlineSquare: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M9.75 12a.75.75 0 0 1 .75-.75h10a.75.75 0 0 1 0 1.5h-10a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M4.5 9.5v5h5v-5h-5zM3.5 8a.5.5 0 0 0-.5.5v7a.5.5 0 0 0 .5.5h7a.5.5 0 0 0 .5-.5v-7a.5.5 0 0 0-.5-.5h-7z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    )
  ] }),
  square: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M9.75 12a.75.75 0 0 1 .75-.75h10a.75.75 0 0 1 0 1.5h-10a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        d: "M3 8.5a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 .5.5v7a.5.5 0 0 1-.5.5h-7a.5.5 0 0 1-.5-.5v-7z",
        fill: "currentColor"
      }
    )
  ] }),
  outlineDiamond: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M11.25 12a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5H12a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M8 8.931 4.931 12 8 15.069 11.069 12 8 8.931zm.324-1.797a.459.459 0 0 0-.648 0l-4.542 4.542a.458.458 0 0 0 0 .648l4.542 4.542c.179.179.47.179.648 0l4.542-4.542a.458.458 0 0 0 0-.648L8.324 7.134z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    )
  ] }),
  diamond: /* @__PURE__ */ W("svg", { height: "24", width: "24", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ x(
      "path",
      {
        clipRule: "evenodd",
        d: "M11.25 12a.75.75 0 0 1 .75-.75h8.5a.75.75 0 0 1 0 1.5H12a.75.75 0 0 1-.75-.75z",
        fill: "currentColor",
        fillRule: "evenodd"
      }
    ),
    /* @__PURE__ */ x(
      "path",
      {
        d: "M7.676 7.134a.458.458 0 0 1 .648 0l4.542 4.542a.458.458 0 0 1 0 .648l-4.542 4.542a.458.458 0 0 1-.648 0l-4.542-4.542a.459.459 0 0 1 0-.648l4.542-4.542z",
        fill: "currentColor"
      }
    )
  ] })
}, ML = [
  "none",
  "bar",
  "arrow",
  "triangle",
  "outlineCircle",
  "circle",
  "outlineSquare",
  "square",
  "outlineDiamond",
  "diamond"
], y1 = ({
  position: n = "start",
  value: e = "none",
  onChange: t
}) => {
  const r = ge(null), [i, o] = Le(!1);
  return /* @__PURE__ */ W(J1, { children: [
    /* @__PURE__ */ x(Dt, { ref: r, onClick: () => o(!0), children: /* @__PURE__ */ x(
      "div",
      {
        css: { transform: n === "start" ? void 0 : "scaleX(-1)" },
        children: v1[e]
      }
    ) }),
    /* @__PURE__ */ x(
      gr,
      {
        anchorEl: r.current,
        open: i,
        placement: "bottom",
        onClose: () => o(!1),
        children: /* @__PURE__ */ x("div", { css: { maxHeight: "50vh", overflowY: "auto" }, children: ML.map((a) => /* @__PURE__ */ W(
          "div",
          {
            css: {
              height: 40,
              minWidth: 120,
              padding: "0 8px",
              display: "flex",
              alignItems: "center",
              cursor: "pointer",
              ":hover": {
                backgroundColor: "rgba(64,87,109,.07)"
              }
            },
            onClick: () => t(a),
            children: [
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    flexShrink: 0,
                    transform: n === "start" ? void 0 : "scaleX(-1)"
                  },
                  children: v1[a]
                }
              ),
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    fontSize: 24,
                    flexGrow: 1,
                    display: "flex",
                    justifyContent: "end"
                  },
                  children: a === e && /* @__PURE__ */ x(Ca, {})
                }
              )
            ]
          },
          a
        )) })
      }
    )
  ] });
}, RL = [
  { type: "solid", icon: /* @__PURE__ */ x(_b, {}) },
  { type: "longDashes", icon: /* @__PURE__ */ x(Lb, {}) },
  { type: "shortDashes", icon: /* @__PURE__ */ x(Pb, {}) },
  { type: "dots", icon: /* @__PURE__ */ x(Ab, {}) }
], DL = ({ layers: n }) => {
  const e = ge(null), { actions: t, activePage: r } = je((b) => ({
    activePage: b.activePage
  })), [i, o] = Le(!1), a = pe(() => n.map((b) => b.data.props.color), [n]), l = pe(() => n.map((b) => b.data.props.arrowStart), [n]), u = pe(() => n.map((b) => b.data.props.arrowEnd), [n]), d = pe(() => n.map((b) => b.data.props.style), [n]), h = pe(() => n.map((b) => b.data.props.boxSize.height), [n]), p = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        color: b
      });
    });
  }, g = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        boxSize: {
          height: b
        }
      });
    });
  }, v = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        style: b
      });
    });
  }, m = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        arrowStart: b
      });
    });
  }, w = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        arrowEnd: b
      });
    });
  };
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        display: "grid",
        alignItems: "center",
        gridAutoFlow: "column",
        gridGap: 8
      },
      children: [
        /* @__PURE__ */ x(Sa, { colors: a, onChange: p, children: /* @__PURE__ */ x(
          "div",
          {
            css: {
              width: 24,
              height: 24,
              borderRadius: 2,
              position: "relative",
              fontSize: 24,
              overflow: "hidden",
              color: a[0]
            },
            children: /* @__PURE__ */ x(Db, {})
          }
        ) }),
        /* @__PURE__ */ x(
          Dt,
          {
            ref: e,
            css: { fontSize: 20 },
            onClick: () => o(!0),
            children: /* @__PURE__ */ x(Ib, {})
          }
        ),
        /* @__PURE__ */ x(
          gr,
          {
            anchorEl: e.current,
            offsets: {
              "bottom-end": { x: 0, y: 8 }
            },
            open: i,
            placement: "bottom",
            onClose: () => o(!1),
            children: /* @__PURE__ */ W("div", { css: { padding: 16, display: "grid", gap: 12 }, children: [
              /* @__PURE__ */ x("div", { children: /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    display: "grid",
                    gridAutoFlow: "column",
                    alignItems: "center",
                    gap: 8
                  },
                  children: RL.map((b) => /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        fontSize: 24,
                        borderRadius: 4,
                        boxShadow: b.type === d[0] ? "inset 0 0 0 2px #3d8eff" : "inset 0 0 0 1px rgba(43,59,74,.3)",
                        padding: 8,
                        cursor: "pointer",
                        ":hover": {
                          boxShadow: b.type !== d[0] ? "inset 0 0 0 1px rgba(28,39,48,.5)" : void 0
                        }
                      },
                      onClick: () => v(b.type),
                      children: b.icon
                    },
                    b.type
                  ))
                }
              ) }),
              /* @__PURE__ */ x(
                Hi,
                {
                  label: "Line Weight",
                  min: 1,
                  value: h[0] || 1,
                  onChange: g
                }
              )
            ] })
          }
        ),
        /* @__PURE__ */ x(y1, { value: l[0], onChange: m }),
        /* @__PURE__ */ x(
          y1,
          {
            position: "end",
            value: u[0],
            onChange: w
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: { height: 24, width: "1px", background: "rgba(57,76,96,.15)" }
          }
        )
      ]
    }
  );
}, IL = ({ layer: n }) => {
  const { actions: e, activePage: t } = je((l) => ({
    activePage: l.activePage,
    sidebar: l.sidebar
  })), r = pe(() => n.data.props.color, [n]), i = pe(() => n.data.props.gradientBackground, [n]);
  return /* @__PURE__ */ x(
    Sa,
    {
      colors: r ? [r] : [],
      gradient: i,
      useGradient: !0,
      onChange: (l) => {
        e.history.throttle(2e3).setProp(t, n.id, {
          color: l,
          gradientBackground: null
        });
      },
      onChangeGradient: (l) => {
        e.history.throttle(2e3).setProp(t, n.id, {
          gradientBackground: l,
          color: null
        });
      }
    }
  );
};
var AL = function(e) {
  return /* @__PURE__ */ Pc("svg", Re({
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round",
    xmlns: "http://www.w3.org/2000/svg"
  }, e, {
    children: [/* @__PURE__ */ q("circle", {
      cx: 12,
      cy: 12,
      r: 10
    }), /* @__PURE__ */ q("path", {
      strokeLinecap: "square",
      d: "m5 5 14 14"
    })]
  }));
};
const LL = [
  {
    type: "none",
    icon: /* @__PURE__ */ x(AL, {})
  },
  { type: "solid", icon: /* @__PURE__ */ x(_b, {}) },
  { type: "longDashes", icon: /* @__PURE__ */ x(Lb, {}) },
  { type: "shortDashes", icon: /* @__PURE__ */ x(Pb, {}) },
  { type: "dots", icon: /* @__PURE__ */ x(Ab, {}) }
], PL = ({ layers: n }) => {
  const e = ge(null), { actions: t, activePage: r } = je((b) => ({
    activePage: b.activePage
  })), [i, o] = Le(!1), a = n.reduce((b, C) => (b < C.data.props.roundedCorners && (b = C.data.props.roundedCorners), b), 0), l = (b) => {
    const C = n.map((M) => M.id);
    t.history.throttle(2e3).setProp(r, C, {
      roundedCorners: b
    });
  }, u = pe(() => n.filter((b) => b.data.props.color && !b.data.props.gradientBackground).map((b) => b.data.props.color), [n]), d = pe(() => n.map((b) => b.data.props.gradientBackground).filter((b) => !!b), [n]), h = pe(() => {
    const b = n.map((C) => C.data.props.border).filter((C) => !!C);
    return b[0] ? b[0] : {
      style: "none",
      weight: 0,
      color: "rgb(0, 0, 0)"
    };
  }, [n]), p = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        color: b,
        gradientBackground: null
      });
    });
  }, g = (b) => {
    n.forEach((C) => {
      t.history.throttle(2e3).setProp(r, C.id, {
        gradientBackground: b
      });
    });
  }, v = (b) => {
    n.forEach((C) => {
      var M, k;
      t.history.throttle(2e3).setProp(r, C.id, {
        border: {
          style: b,
          weight: b === "none" ? 0 : ((M = C.data.props.border) == null ? void 0 : M.weight) || 4,
          color: ((k = C.data.props.border) == null ? void 0 : k.color) || "rgb(0, 0, 0)"
        }
      });
    });
  }, m = (b) => {
    const C = n.map((M) => M.id);
    t.history.throttle(2e3).setProp(r, C, {
      border: {
        style: (b === 0 ? "none" : h.style) || "solid",
        weight: b,
        color: h.color
      }
    });
  }, w = (b) => {
    const C = n.filter((M) => {
      var k;
      return ((k = M.data.props.border) == null ? void 0 : k.style) !== "none";
    }).map((M) => M.id);
    t.history.throttle(2e3).setProp(r, C, {
      border: {
        color: b
      }
    });
  };
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        display: "grid",
        alignItems: "center",
        gridAutoFlow: "column",
        gridGap: 8
      },
      children: [
        /* @__PURE__ */ x(
          Sa,
          {
            colors: u,
            gradient: d.length > 0 ? d[0] : null,
            useGradient: !0,
            onChange: p,
            onChangeGradient: g
          }
        ),
        h && h.style !== "none" && /* @__PURE__ */ x(Sa, { colors: [h.color], onChange: w, children: /* @__PURE__ */ x(
          "div",
          {
            css: {
              width: 24,
              height: 24,
              borderRadius: 2,
              position: "relative",
              fontSize: 24,
              overflow: "hidden",
              color: h.color
            },
            children: /* @__PURE__ */ x(Db, {})
          }
        ) }),
        /* @__PURE__ */ x(
          Dt,
          {
            ref: e,
            css: { fontSize: 20 },
            onClick: () => o(!0),
            children: /* @__PURE__ */ x(Ib, {})
          }
        ),
        /* @__PURE__ */ x(
          gr,
          {
            anchorEl: e.current,
            offsets: {
              "bottom-end": { x: 0, y: 8 }
            },
            open: i,
            placement: "bottom",
            onClose: () => o(!1),
            children: /* @__PURE__ */ W("div", { css: { padding: 16, display: "grid", gap: 12 }, children: [
              /* @__PURE__ */ x("div", { children: /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    display: "grid",
                    gridAutoFlow: "column",
                    alignItems: "center",
                    gap: 8
                  },
                  children: LL.map((b) => /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        fontSize: 24,
                        borderRadius: 4,
                        boxShadow: b.type === (h == null ? void 0 : h.style) ? "inset 0 0 0 2px #3d8eff" : "inset 0 0 0 1px rgba(43,59,74,.3)",
                        padding: 8,
                        cursor: "pointer",
                        ":hover": {
                          boxShadow: b.type !== (h == null ? void 0 : h.style) ? "inset 0 0 0 1px rgba(28,39,48,.5)" : void 0
                        }
                      },
                      onClick: () => v(b.type),
                      children: b.icon
                    },
                    b.type
                  ))
                }
              ) }),
              /* @__PURE__ */ x(
                Hi,
                {
                  label: "Border Weight",
                  value: (h == null ? void 0 : h.weight) || 0,
                  onChange: m
                }
              ),
              /* @__PURE__ */ x(
                Hi,
                {
                  label: "Corner Rounding",
                  value: a,
                  onChange: l
                }
              )
            ] })
          }
        )
      ]
    }
  );
}, _L = ({ layer: n }) => {
  const { actions: e, activePage: t, sidebar: r } = je((u) => ({
    activePage: u.activePage,
    sidebar: u.sidebar
  })), [i, o] = Le(null), a = pe(() => n.data.props.colors, [n]), l = (u) => {
    i !== null && e.history.throttle(2e3).setProp(t, n.id, {
      colors: [
        ...a.slice(0, i),
        u,
        ...a.slice(i + 1, a.length)
      ]
    });
  };
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        display: "grid",
        alignItems: "center",
        gridAutoFlow: "column",
        gridGap: 8
      },
      children: [
        /* @__PURE__ */ x(
          "div",
          {
            css: {
              display: "grid",
              alignItems: "center",
              gridAutoFlow: "column"
            },
            children: a.map((u, d) => /* @__PURE__ */ W(Tt, { children: [
              /* @__PURE__ */ x(
                Dt,
                {
                  isActive: d === i,
                  onClick: () => {
                    o(d), e.setSidebar("CHOOSING_COLOR");
                  },
                  children: /* @__PURE__ */ x(
                    "div",
                    {
                      css: {
                        width: 24,
                        height: 24,
                        background: u ?? "conic-gradient(red, yellow, lime, aqua, blue, magenta, red)",
                        boxShadow: "inset 0 0 0 1px rgba(57,76,96,.15)",
                        borderRadius: 2
                      }
                    }
                  )
                }
              ),
              r === "CHOOSING_COLOR" && /* @__PURE__ */ x(
                Hh,
                {
                  open: !0,
                  selected: u,
                  onSelect: l
                }
              )
            ] }, d))
          }
        ),
        /* @__PURE__ */ x(
          "div",
          {
            css: { height: 24, width: "1px", background: "rgba(57,76,96,.15)" }
          }
        )
      ]
    }
  );
};
var NL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M177.08 114.46A48 48 0 0 0 140 36H72a12 12 0 0 0-12 12v152a12 12 0 0 0 12 12h80a52 52 0 0 0 25.08-97.54ZM84 60h56a24 24 0 0 1 0 48H84Zm68 128H84v-56h68a28 28 0 0 1 0 56Z"
    })
  }));
}, zL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    width: "1em",
    height: "1em",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    xmlns: "http://www.w3.org/2000/svg"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M21 12c0 .4-.3.8-.7.8h-9.7c-.4 0-.7-.3-.7-.8 0-.4.3-.8.7-.8h9.7c.4 0 .7.4.7.8zM10.6 6.8h9.7c.4 0 .7-.4.7-.8s-.3-.8-.7-.8h-9.7c-.4 0-.7.3-.7.8 0 .4.4.8.7.8zM20.3 17.2h-9.7c-.4 0-.7.3-.7.8s.3.8.7.8h9.7c.4 0 .7-.3.7-.8s-.3-.8-.7-.8zM8.4 17.2c.3.2.3.6 0 .9l-3 2.5c-.3.2-.8.2-1.1 0l-3-2.5c-.3-.2-.3-.6 0-.9.3-.2.8-.2 1.1 0l1.7 1.4V5.3L2.4 6.8c-.3.2-.8.2-1.1 0-.3-.3-.3-.7 0-.9l3-2.5c.3-.2.8-.2 1.1 0l3 2.5c.3.2.3.6 0 .9-.3.2-.8.2-1.1 0L5.6 5.3v13.3l1.7-1.4c.3-.2.8-.2 1.1 0z"
    })
  }));
}, BL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M223.51 48h-191A16.51 16.51 0 0 0 16 64.49v127A16.51 16.51 0 0 0 32.49 208h191A16.51 16.51 0 0 0 240 191.51v-127A16.51 16.51 0 0 0 223.51 48Zm.49 143.51a.49.49 0 0 1-.49.49h-191a.49.49 0 0 1-.49-.49v-127a.49.49 0 0 1 .49-.49h191a.49.49 0 0 1 .49.49ZM208 128a8 8 0 0 1-8 8H56a8 8 0 0 1 0-16h144a8 8 0 0 1 8 8Zm0-32a8 8 0 0 1-8 8H56a8 8 0 0 1 0-16h144a8 8 0 0 1 8 8ZM72 160a8 8 0 0 1-8 8h-8a8 8 0 0 1 0-16h8a8 8 0 0 1 8 8Zm96 0a8 8 0 0 1-8 8H96a8 8 0 0 1 0-16h64a8 8 0 0 1 8 8Zm40 0a8 8 0 0 1-8 8h-8a8 8 0 0 1 0-16h8a8 8 0 0 1 8 8Z"
    })
  }));
}, FL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M80 64a8 8 0 0 1 8-8h128a8 8 0 0 1 0 16H88a8 8 0 0 1-8-8Zm136 56H88a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16Zm0 64H88a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16ZM44 52a12 12 0 1 0 12 12 12 12 0 0 0-12-12Zm0 64a12 12 0 1 0 12 12 12 12 0 0 0-12-12Zm0 64a12 12 0 1 0 12 12 12 12 0 0 0-12-12Z"
    })
  }));
}, VL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 128a8 8 0 0 1-8 8H104a8 8 0 0 1 0-16h112a8 8 0 0 1 8 8ZM104 72h112a8 8 0 0 0 0-16H104a8 8 0 0 0 0 16Zm112 112H104a8 8 0 0 0 0 16h112a8 8 0 0 0 0-16ZM43.58 55.16 48 52.94V104a8 8 0 0 0 16 0V40a8 8 0 0 0-11.58-7.16l-16 8a8 8 0 0 0 7.16 14.32Zm36.19 101.56a23.73 23.73 0 0 0-9.6-15.95 24.86 24.86 0 0 0-34.11 4.7 23.63 23.63 0 0 0-3.57 6.46 8 8 0 1 0 15 5.47 7.84 7.84 0 0 1 1.18-2.13 8.76 8.76 0 0 1 12-1.59 7.91 7.91 0 0 1 3.26 5.32 7.64 7.64 0 0 1-1.57 5.78 1 1 0 0 0-.08.11l-28.69 38.32A8 8 0 0 0 40 216h32a8 8 0 0 0 0-16H56l19.08-25.53a23.47 23.47 0 0 0 4.69-17.75Z"
    })
  }));
}, WL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M224 128a8 8 0 0 1-8 8H40a8 8 0 0 1 0-16h176a8 8 0 0 1 8 8Z"
    })
  }));
}, HL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M87.24 52.59a8 8 0 0 0-14.48 0l-64 136a8 8 0 1 0 14.48 6.81L39.9 160h80.2l16.66 35.4a8 8 0 1 0 14.48-6.81ZM47.43 144 80 74.79 112.57 144ZM200 96c-12.76 0-22.73 3.47-29.63 10.32a8 8 0 0 0 11.26 11.36c3.8-3.77 10-5.68 18.37-5.68 13.23 0 24 9 24 20v3.22a42.76 42.76 0 0 0-24-7.22c-22.06 0-40 16.15-40 36s17.94 36 40 36a42.73 42.73 0 0 0 24-7.25 8 8 0 0 0 16-.75v-60c0-19.85-17.94-36-40-36Zm0 88c-13.23 0-24-9-24-20s10.77-20 24-20 24 9 24 20-10.77 20-24 20Z"
    })
  }));
}, $L = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M32 64a8 8 0 0 1 8-8h176a8 8 0 0 1 0 16H40a8 8 0 0 1-8-8Zm32 32a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16Zm152 40H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Zm-24 40H64a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16Z"
    })
  }));
}, UL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M32 64a8 8 0 0 1 8-8h176a8 8 0 0 1 0 16H40a8 8 0 0 1-8-8Zm184 32H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Zm0 40H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Zm0 40H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Z"
    })
  }));
}, ZL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M32 64a8 8 0 0 1 8-8h176a8 8 0 0 1 0 16H40a8 8 0 0 1-8-8Zm8 48h128a8 8 0 0 0 0-16H40a8 8 0 0 0 0 16Zm176 24H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Zm-48 40H40a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16Z"
    })
  }));
}, jL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M32 64a8 8 0 0 1 8-8h176a8 8 0 0 1 0 16H40a8 8 0 0 1-8-8Zm184 32H88a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16Zm0 40H40a8 8 0 0 0 0 16h176a8 8 0 0 0 0-16Zm0 40H88a8 8 0 0 0 0 16h128a8 8 0 0 0 0-16Z"
    })
  }));
}, YL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M60.59 175.24a8 8 0 0 0 10.65-3.83L87.9 136h80.2l16.66 35.41a8 8 0 1 0 14.48-6.82l-64-136a8 8 0 0 0-14.48 0l-64 136a8 8 0 0 0 3.83 10.65ZM128 50.79 160.57 120H95.43ZM224 216a8 8 0 0 1-8 8H40a8 8 0 0 1 0-16h176a8 8 0 0 1 8 8Z"
    })
  }));
}, qL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M200 56a8 8 0 0 1-8 8h-34.23L115.1 192H144a8 8 0 0 1 0 16H64a8 8 0 0 1 0-16h34.23L140.9 64H112a8 8 0 0 1 0-16h80a8 8 0 0 1 8 8Z"
    })
  }));
}, GL = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "M200 224a8 8 0 0 1-8 8H64a8 8 0 0 1 0-16h128a8 8 0 0 1 8 8Zm-72-24a64.07 64.07 0 0 0 64-64V56a8 8 0 0 0-16 0v80a48 48 0 0 1-96 0V56a8 8 0 0 0-16 0v80a64.07 64.07 0 0 0 64 64Z"
    })
  }));
};
const Vs = (n) => (e, t) => {
  const r = e.tr, { doc: i } = r, o = Math.max(0, Math.min(i.content.size, n)), a = He.create(i, o);
  return r.setSelection(a), t ? (t(r), !0) : !1;
}, of = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = ["paragraph"];
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.includes(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      indent: n,
      listType: ""
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, Wl = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = ["paragraph"];
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.includes(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      fontFamily: n
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, Ei = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = ["paragraph"];
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.includes(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      fontSize: `${n}px`
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, sf = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = ["paragraph"];
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.includes(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      letterSpacing: n
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, af = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = ["paragraph"];
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.includes(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      lineHeight: n
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, lf = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = /* @__PURE__ */ new Set(["list_item", "paragraph"]);
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.has(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      indent: n,
      listType: "ordered"
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, cf = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = ["paragraph"];
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return (h.attrs.align || null) !== n && d.includes(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    n ? m = {
      ...m,
      textAlign: n
    } : m = {
      ...m,
      textAlign: null
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, uf = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { selection: i, doc: o } = r;
  if (!i || !o)
    return !1;
  const { from: a, to: l } = i, u = [], d = /* @__PURE__ */ new Set(["list_item", "paragraph"]);
  return o.nodesBetween(a, l, (h, p) => {
    const g = h.type;
    return d.has(g.name) && u.push({
      node: h,
      pos: p,
      nodeType: g
    }), !0;
  }), u.length ? (u.forEach((h) => {
    const { node: p, pos: g, nodeType: v } = h;
    let { attrs: m } = p;
    m = {
      ...m,
      textTransform: n ?? null
    }, r.setNodeMarkup(g, v, m, p.marks);
  }), t ? (t(r), !0) : !1) : !1;
}, w1 = (n) => (e, t, r) => (Ia("color", { color: n })(e, t, r), !0), b1 = (n) => (e, t) => {
  const r = e.tr.setSelection(e.selection), { $from: i, $to: o } = r.selection, a = i.blockRange(o);
  return a && t ? (e.doc.nodesBetween(a.start, a.end, (l, u) => {
    if (l.isBlock) {
      const d = l.type, h = {
        ...l.attrs,
        color: n
      };
      r.setNodeMarkup(u, d, h, l.marks);
    }
  }), t(r), !0) : !1;
}, x1 = (...n) => Eh("underline")(...n), KL = (...n) => Xc("underline")(...n), XL = (...n) => Ia("underline")(...n);
function JL(n, e) {
  return e.nodes[n] ? "node" : e.marks[n] ? "mark" : null;
}
function QL(n, e) {
  if (typeof n == "string") {
    if (!e.nodes[n])
      throw Error(`There is no node type named '${n}'!`);
    return e.nodes[n];
  }
  return n;
}
const S1 = (n, e, t = {}) => {
  const { from: r, to: i, empty: o } = n.selection, a = e ? QL(e, n.schema) : null, l = [];
  n.doc.nodesBetween(r, i, (p, g) => {
    if (p.isText)
      return;
    const v = Math.max(r, g), m = Math.min(i, g + p.nodeSize);
    l.push({
      node: p,
      from: v,
      to: m
    });
  });
  const u = i - r, d = l.filter((p) => a ? a.name === p.node.type.name : !0).filter((p) => yc(p.node.attrs, t));
  return o ? !!d.length : d.reduce(
    (p, g) => p + g.to - g.from,
    0
  ) >= u;
};
function pt(n, e, t = {}) {
  if (!e)
    return S1(n, null, t) || zf(n, null, t);
  const r = JL(e, n.schema);
  return r === "node" ? S1(n, e, t) : r === "mark" ? zf(n, e, t) : !1;
}
const eP = (n) => {
  var r;
  const e = (r = n.doc.type.createAndFill()) == null ? void 0 : r.toJSON(), t = n.doc.toJSON();
  return JSON.stringify(e) === JSON.stringify(t);
}, C1 = (n) => n.marks.reduce((e, t) => (Object.entries(t.attrs).forEach(([r, i]) => {
  e[r] || (e[r] = []), i && e[r].push(i);
}), e), {}), Ys = (n) => {
  let e = n.marks.reduce((t, r) => (Object.entries(r.attrs).forEach(([i, o]) => {
    t[i] || (t[i] = []), o && t[i].push(o);
  }), t), {});
  return n.content.forEach((t) => {
    e = Te.mergeWith(e, Ys(t), (r, i) => {
      if (Te.isArray(r))
        return r.concat(i);
    });
  }), e;
}, tP = (n) => Object.entries(n.attrs).reduce((e, [t, r]) => (r && (e[t] = [r]), e), {}), ki = (n) => {
  const e = Object.entries(n.attrs).reduce(
    (t, [r, i]) => (t[r] = [i], t),
    {}
  );
  return n.content.forEach((t) => {
    Object.entries(t.attrs).forEach(([r, i]) => {
      e[r] || (e[r] = []), i && e[r].push(i);
    });
  }), e;
}, Ws = (n) => Te.uniq((n == null ? void 0 : n.fontFamily) || []), lo = (n) => Te.uniq((n == null ? void 0 : n.fontSize) || []).map((e) => parseFloat(e)), df = (n) => Te.uniq((n == null ? void 0 : n.lineHeight) || []).map((e) => parseFloat(e)), ff = (n) => Te.uniq((n == null ? void 0 : n.letterSpacing) || []).map((e) => parseFloat(e)), co = (n, e) => {
  const t = Te.mergeWith(n, e, (r, i) => {
    if (Te.isArray(r))
      return r.concat(i);
  });
  return Te.uniq((t == null ? void 0 : t.color) || []).map((r) => new Nt(r).toRgbString());
};
var nP = function(e) {
  return /* @__PURE__ */ q("svg", Re({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 256 256",
    fill: "currentColor",
    width: "1em",
    height: "1em"
  }, e, {
    children: /* @__PURE__ */ q("path", {
      d: "m229.66 218.34-50.07-50.06a88.11 88.11 0 1 0-11.31 11.31l50.06 50.07a8 8 0 0 0 11.32-11.32ZM40 112a72 72 0 1 1 72 72 72.08 72.08 0 0 1-72-72Z"
    })
  }));
}, Ac = function() {
  return Ac = Object.assign || function(e) {
    for (var t, r = 1, i = arguments.length; r < i; r++) {
      t = arguments[r];
      for (var o in t)
        Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ac.apply(this, arguments);
};
function rP() {
  var n = ge(!1), e = Ie(function() {
    return n.current;
  }, []);
  return be(function() {
    return n.current = !0, function() {
      n.current = !1;
    };
  }, []), e;
}
function iP(n, e, t) {
  e === void 0 && (e = []), t === void 0 && (t = { loading: !1 });
  var r = ge(0), i = rP(), o = Le(t), a = o[0], l = o[1], u = Ie(function() {
    for (var d = [], h = 0; h < arguments.length; h++)
      d[h] = arguments[h];
    var p = ++r.current;
    return a.loading || l(function(g) {
      return Ac(Ac({}, g), { loading: !0 });
    }), n.apply(void 0, d).then(function(g) {
      return i() && p === r.current && l({ value: g, loading: !1 }), g;
    }, function(g) {
      return i() && p === r.current && l({ error: g, loading: !1 }), g;
    });
  }, e);
  return [a, u];
}
function oP(n, e) {
  e === void 0 && (e = []);
  var t = iP(n, e, {
    loading: !0
  }), r = t[0], i = t[1];
  return be(function() {
    i();
  }, [i]), r;
}
var sP = {
  name: "@emotion/react",
  version: "11.11.1",
  main: "dist/emotion-react.cjs.js",
  module: "dist/emotion-react.esm.js",
  browser: {
    "./dist/emotion-react.esm.js": "./dist/emotion-react.browser.esm.js"
  },
  exports: {
    ".": {
      module: {
        worker: "./dist/emotion-react.worker.esm.js",
        browser: "./dist/emotion-react.browser.esm.js",
        default: "./dist/emotion-react.esm.js"
      },
      import: "./dist/emotion-react.cjs.mjs",
      default: "./dist/emotion-react.cjs.js"
    },
    "./jsx-runtime": {
      module: {
        worker: "./jsx-runtime/dist/emotion-react-jsx-runtime.worker.esm.js",
        browser: "./jsx-runtime/dist/emotion-react-jsx-runtime.browser.esm.js",
        default: "./jsx-runtime/dist/emotion-react-jsx-runtime.esm.js"
      },
      import: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.mjs",
      default: "./jsx-runtime/dist/emotion-react-jsx-runtime.cjs.js"
    },
    "./_isolated-hnrs": {
      module: {
        worker: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.worker.esm.js",
        browser: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.browser.esm.js",
        default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.esm.js"
      },
      import: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.mjs",
      default: "./_isolated-hnrs/dist/emotion-react-_isolated-hnrs.cjs.js"
    },
    "./jsx-dev-runtime": {
      module: {
        worker: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.worker.esm.js",
        browser: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.browser.esm.js",
        default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.esm.js"
      },
      import: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.mjs",
      default: "./jsx-dev-runtime/dist/emotion-react-jsx-dev-runtime.cjs.js"
    },
    "./package.json": "./package.json",
    "./types/css-prop": "./types/css-prop.d.ts",
    "./macro": {
      types: {
        import: "./macro.d.mts",
        default: "./macro.d.ts"
      },
      default: "./macro.js"
    }
  },
  types: "types/index.d.ts",
  files: [
    "src",
    "dist",
    "jsx-runtime",
    "jsx-dev-runtime",
    "_isolated-hnrs",
    "types/*.d.ts",
    "macro.*"
  ],
  sideEffects: !1,
  author: "Emotion Contributors",
  license: "MIT",
  scripts: {
    "test:typescript": "dtslint types"
  },
  dependencies: {
    "@babel/runtime": "^7.18.3",
    "@emotion/babel-plugin": "^11.11.0",
    "@emotion/cache": "^11.11.0",
    "@emotion/serialize": "^1.1.2",
    "@emotion/use-insertion-effect-with-fallbacks": "^1.0.1",
    "@emotion/utils": "^1.2.1",
    "@emotion/weak-memoize": "^0.3.1",
    "hoist-non-react-statics": "^3.3.1"
  },
  peerDependencies: {
    react: ">=16.8.0"
  },
  peerDependenciesMeta: {
    "@types/react": {
      optional: !0
    }
  },
  devDependencies: {
    "@definitelytyped/dtslint": "0.0.112",
    "@emotion/css": "11.11.0",
    "@emotion/css-prettifier": "1.1.3",
    "@emotion/server": "11.11.0",
    "@emotion/styled": "11.11.0",
    "html-tag-names": "^1.1.2",
    react: "16.14.0",
    "svg-tag-names": "^1.1.1",
    typescript: "^4.5.5"
  },
  repository: "https://github.com/emotion-js/emotion/tree/main/packages/react",
  publishConfig: {
    access: "public"
  },
  "umd:main": "dist/emotion-react.umd.min.js",
  preconstruct: {
    entrypoints: [
      "./index.js",
      "./jsx-runtime.js",
      "./jsx-dev-runtime.js",
      "./_isolated-hnrs.js"
    ],
    umdName: "emotionReact",
    exports: {
      envConditions: [
        "browser",
        "worker"
      ],
      extra: {
        "./types/css-prop": "./types/css-prop.d.ts",
        "./macro": {
          types: {
            import: "./macro.d.mts",
            default: "./macro.d.ts"
          },
          default: "./macro.js"
        }
      }
    }
  }
}, E1 = !1, Nb = /* @__PURE__ */ ih(function(n, e) {
  process.env.NODE_ENV !== "production" && !E1 && // check for className as well since the user is
  // probably using the custom createElement which
  // means it will be turned into a className prop
  // $FlowFixMe I don't really want to add it to the type since it shouldn't be used
  (n.className || n.css) && (console.error("It looks like you're using the css prop on Global, did you mean to use the styles prop instead?"), E1 = !0);
  var t = n.styles, r = ca([t], void 0, pn.useContext(Vc)), i = pn.useRef();
  return I0(function() {
    var o = e.key + "-global", a = new e.sheet.constructor({
      key: o,
      nonce: e.sheet.nonce,
      container: e.sheet.container,
      speedy: e.sheet.isSpeedy
    }), l = !1, u = document.querySelector('style[data-emotion="' + o + " " + r.name + '"]');
    return e.sheet.tags.length && (a.before = e.sheet.tags[0]), u !== null && (l = !0, u.setAttribute("data-emotion", o), a.hydrate([u])), i.current = [a, l], function() {
      a.flush();
    };
  }, [e]), I0(function() {
    var o = i.current, a = o[0], l = o[1];
    if (l) {
      o[1] = !1;
      return;
    }
    if (r.next !== void 0 && th(e, r.next, !0), a.tags.length) {
      var u = a.tags[a.tags.length - 1].nextElementSibling;
      a.before = u, a.flush();
    }
    e.insert("", r, a, !1);
  }, [e, r.name]), null;
});
process.env.NODE_ENV !== "production" && (Nb.displayName = "EmotionGlobal");
function aP() {
  for (var n = arguments.length, e = new Array(n), t = 0; t < n; t++)
    e[t] = arguments[t];
  return ca(e);
}
var lP = function n(e) {
  for (var t = e.length, r = 0, i = ""; r < t; r++) {
    var o = e[r];
    if (o != null) {
      var a = void 0;
      switch (typeof o) {
        case "boolean":
          break;
        case "object": {
          if (Array.isArray(o))
            a = n(o);
          else {
            process.env.NODE_ENV !== "production" && o.styles !== void 0 && o.name !== void 0 && console.error("You have passed styles created with `css` from `@emotion/react` package to the `cx`.\n`cx` is meant to compose class names (strings) so you should convert those styles to a class name by passing them to the `css` received from <ClassNames/> component."), a = "";
            for (var l in o)
              o[l] && l && (a && (a += " "), a += l);
          }
          break;
        }
        default:
          a = o;
      }
      a && (i && (i += " "), i += a);
    }
  }
  return i;
};
function cP(n, e, t) {
  var r = [], i = $1(n, r, t);
  return r.length < 2 ? t : i + e(r);
}
var uP = function(e) {
  var t = e.cache, r = e.serializedArr;
  return q1(function() {
    for (var i = 0; i < r.length; i++)
      th(t, r[i], !1);
  }), null;
}, dP = /* @__PURE__ */ ih(function(n, e) {
  var t = !1, r = [], i = function() {
    if (t && process.env.NODE_ENV !== "production")
      throw new Error("css can only be used during render");
    for (var d = arguments.length, h = new Array(d), p = 0; p < d; p++)
      h[p] = arguments[p];
    var g = ca(h, e.registered);
    return r.push(g), eh(e, g, !1), e.key + "-" + g.name;
  }, o = function() {
    if (t && process.env.NODE_ENV !== "production")
      throw new Error("cx can only be used during render");
    for (var d = arguments.length, h = new Array(d), p = 0; p < d; p++)
      h[p] = arguments[p];
    return cP(e.registered, i, lP(h));
  }, a = {
    css: i,
    cx: o,
    theme: pn.useContext(Vc)
  }, l = n.children(a);
  return t = !0, /* @__PURE__ */ pn.createElement(pn.Fragment, null, /* @__PURE__ */ pn.createElement(uP, {
    cache: e,
    serializedArr: r
  }), l);
});
process.env.NODE_ENV !== "production" && (dP.displayName = "EmotionClassNames");
if (process.env.NODE_ENV !== "production") {
  var k1 = !0, fP = typeof jest < "u" || typeof vi < "u";
  if (k1 && !fP) {
    var O1 = (
      // $FlowIgnore
      typeof globalThis < "u" ? globalThis : k1 ? window : global
    ), T1 = "__EMOTION_REACT_" + sP.version.split(".")[0] + "__";
    O1[T1] && console.warn("You are loading @emotion/react when it is already loaded. Running multiple instances may cause problems. This can happen if multiple versions are used, or if multiple builds of the same version are used."), O1[T1] = !0;
  }
}
const hP = () => {
  const { fontList: n } = je((t) => ({ fontList: t.fontList })), e = pe(() => {
    const t = [];
    return n.forEach((r) => {
      const i = r.fonts.find((o) => !o.style);
      i && t.push(`
                @font-face {
                  font-family: '${r.name}';
                  src: url(${i.urls.join(",")}) format('woff2');
                  font-display: block;
                }
                `);
    }), t.join(`
`);
  }, [n]);
  return /* @__PURE__ */ x(
    Nb,
    {
      styles: aP`
        ${e}
      `
    }
  );
}, pP = yt.memo(hP), gP = ({ selected: n, onChangeFontFamily: e, ...t }, r) => {
  const i = ge(!1), o = ge(null), a = ge(null), { getFonts: l } = It(di), { usedFonts: u } = Jc(), { actions: d, fontList: h } = je((C) => ({
    fontList: C.fontList
  })), [p, g] = Le(!1), [v, m] = Le(""), w = Ie(
    async (C = 0) => {
      i.current = !0, g(!0);
      const M = await l({
        limit: "30",
        offset: C + "",
        q: v
      });
      C ? d.appendFontList(M) : d.setFontList(M), g(!1), M.length > 0 && (i.current = !1);
    },
    [l, d, g, v]
  );
  return oP(async () => {
    await w();
  }, [w]), be(() => {
    const C = async (k) => {
      const D = k.target;
      D.scrollHeight - D.scrollTop - 80 <= D.clientHeight && !i.current && await w(h.length);
    }, M = a.current;
    return M == null || M.addEventListener("scroll", C), () => {
      M == null || M.removeEventListener("scroll", C);
    };
  }, [w, h]), /* @__PURE__ */ W(su, { ref: r, ...t, children: [
    /* @__PURE__ */ x(pP, {}),
    /* @__PURE__ */ W(
      "div",
      {
        css: {
          width: "100%",
          height: "100%",
          display: "flex",
          flexDirection: "column",
          overflowY: "auto"
        },
        children: [
          /* @__PURE__ */ W(
            "div",
            {
              css: {
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                flexShrink: 0,
                height: 48,
                borderBottom: "1px solid rgba(57,76,96,.15)",
                padding: "0 20px"
              },
              children: [
                /* @__PURE__ */ x(
                  "p",
                  {
                    css: {
                      lineHeight: "48px",
                      fontWeight: 600,
                      color: "#181C32",
                      flexGrow: 1
                    },
                    children: "Font"
                  }
                ),
                /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      fontSize: 20,
                      flexShrink: 0,
                      width: 32,
                      height: 32,
                      cursor: "pointer",
                      display: "flex",
                      alignItems: "center",
                      justifyContent: "center"
                    },
                    onClick: () => {
                      d.setSidebar();
                    },
                    children: /* @__PURE__ */ x(Ro, {})
                  }
                )
              ]
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                borderRadius: 4,
                boxShadow: "0 0 0 1px rgba(43,59,74,.3)",
                margin: 16
              },
              children: /* @__PURE__ */ W(
                "div",
                {
                  css: {
                    height: 40,
                    borderRadius: 4,
                    padding: "0 12px",
                    display: "flex",
                    alignItems: "center"
                  },
                  children: [
                    /* @__PURE__ */ x("div", { css: { fontSize: 24, marginRight: 8, flexShrink: 0 }, children: /* @__PURE__ */ x(nP, {}) }),
                    /* @__PURE__ */ x("form", { onSubmit: async (C) => {
                      var M;
                      C.preventDefault(), a.current && (a.current.scrollTop = 0), m(((M = o.current) == null ? void 0 : M.value) || ""), await w(0);
                    }, children: /* @__PURE__ */ x(
                      "input",
                      {
                        ref: o,
                        css: { width: "100%", height: "100%" },
                        type: "text"
                      }
                    ) })
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ W("div", { ref: a, css: { flexGrow: 1, overflowY: "auto" }, children: [
            /* @__PURE__ */ x("div", { css: { padding: "16px 20px", fontWeight: 700 }, children: "Document fonts" }),
            u.map((C) => /* @__PURE__ */ W(
              "div",
              {
                css: {
                  height: 40,
                  display: "flex",
                  alignItems: "center",
                  justifyContent: "space-between",
                  cursor: "pointer",
                  padding: "0 24px",
                  ":hover": {
                    background: "#F9F9F9"
                  }
                },
                onClick: () => e(C),
                children: [
                  /* @__PURE__ */ x("span", { css: { fontFamily: C.name }, children: C.name }),
                  n.map((M) => M.name).includes(C.name) && /* @__PURE__ */ x("span", { children: /* @__PURE__ */ x(Ca, {}) })
                ]
              },
              C.name
            )),
            /* @__PURE__ */ W("div", { css: { borderTop: "1px solid rgba(217, 219, 228, 0.6)" }, children: [
              /* @__PURE__ */ x("div", { css: { padding: "16px 20px", fontWeight: 700 }, children: "Fonts" }),
              h.map((C) => /* @__PURE__ */ W(
                "div",
                {
                  css: {
                    height: 40,
                    display: "flex",
                    alignItems: "center",
                    justifyContent: "space-between",
                    cursor: "pointer",
                    padding: "0 24px",
                    ":hover": {
                      background: "#F9F9F9"
                    }
                  },
                  onClick: () => e(C),
                  children: [
                    /* @__PURE__ */ x("span", { css: { fontFamily: C.name }, children: C.name }),
                    n.map((M) => M.name).includes(C.name) && /* @__PURE__ */ x("span", { children: /* @__PURE__ */ x(Ca, {}) })
                  ]
                },
                C.name
              )),
              p && /* @__PURE__ */ x("div", { children: "Loading..." })
            ] })
          ] })
        ]
      }
    )
  ] });
}, mP = Yt(gP), hf = (n) => [
  {
    value: "none",
    img: `${n}/text/effects/none.png`
  },
  {
    value: "shadow",
    img: `${n}/text/effects/shadow.png`,
    settings: {
      offset: 50,
      direction: 45,
      blur: 0,
      transparency: 40,
      color: "#000000"
    }
  },
  {
    value: "lift",
    img: `${n}/text/effects/lift.png`,
    settings: {
      intensity: 50
    }
  },
  {
    value: "hollow",
    img: `${n}/text/effects/hollow.png`,
    settings: {
      thickness: 50
    }
  },
  {
    value: "splice",
    img: `${n}/text/effects/splice.png`,
    settings: {
      thickness: 50,
      offset: 50,
      direction: 45,
      color: "#000000"
    }
  },
  {
    value: "echo",
    img: `${n}/text/effects/echo.png`,
    settings: {
      offset: 50,
      direction: 45,
      color: "#000000"
    }
  }
], vP = ({ ...n }, e) => {
  const {
    config: { assetPath: t }
  } = It(di), r = ge(null), [i, o] = Le(!1), { selectedLayers: a } = rn(), { actions: l, activePage: u } = je((m) => ({
    activePage: m.activePage
  })), d = a.filter(
    (m) => ui(m)
  ), { effect: h, settings: p } = pe(() => d.reduce(
    (m, w) => {
      const b = w.data.props;
      return b.effect && (b.effect.name === m.effect || b.effect.name && m.effect === "none" ? (m.effect = b.effect.name, m.settings = b.effect.settings) : (m.effect = "none", m.settings = {})), m;
    },
    { effect: "none", settings: {} }
  ), [d]), g = (m) => {
    l.history.new(), d.forEach(
      ({
        id: w,
        data: {
          props: { colors: b }
        }
      }) => {
        var C;
        if (m === "none")
          l.setProp(u, w, {
            effect: null
          });
        else {
          const M = Te.cloneDeep(
            (C = hf(t).find((k) => k.value === m)) == null ? void 0 : C.settings
          );
          if (b.length > 0) {
            const k = new Nt(b[0]);
            k.white() > 50 ? M.color = k.darken(0.5).toRgbString() : M.color = k.whiten(0.5).toRgbString();
          }
          l.history.merge().setProp(
            u,
            w,
            {
              effect: {
                name: m,
                settings: M
              }
            },
            (k, D) => {
              if (D)
                return D;
            }
          );
        }
      }
    );
  }, v = Te.throttle(
    (m, w) => {
      const b = d.map((C) => C.id);
      l.history.throttle(2e3).setProp(u, b, {
        effect: {
          settings: {
            [m]: w
          }
        }
      });
    },
    16
  );
  return /* @__PURE__ */ W(su, { ref: e, ...n, children: [
    /* @__PURE__ */ W(
      "div",
      {
        css: {
          display: "flex",
          alignItems: "center",
          justifyContent: "center",
          flexShrink: 0,
          height: 48,
          borderBottom: "1px solid rgba(57,76,96,.15)",
          padding: "0 20px"
        },
        children: [
          /* @__PURE__ */ x(
            "p",
            {
              css: {
                lineHeight: "48px",
                fontWeight: 600,
                color: "#181C32",
                flexGrow: 1
              },
              children: "Text Effects"
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                fontSize: 20,
                flexShrink: 0,
                width: 32,
                height: 32,
                cursor: "pointer",
                display: "flex",
                alignItems: "center",
                justifyContent: "center"
              },
              onClick: () => {
                l.setSidebar();
              },
              children: /* @__PURE__ */ x(Ro, {})
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ W("div", { css: { padding: "24px 16px" }, children: [
      /* @__PURE__ */ x("p", { children: "Style" }),
      /* @__PURE__ */ W(
        "div",
        {
          css: {
            display: "grid",
            gridTemplateColumns: "repeat(3,minmax(0,1fr))",
            gap: 12,
            fontSize: 10
          },
          children: [
            hf(t).map((m) => /* @__PURE__ */ W("div", { children: [
              /* @__PURE__ */ W(
                "div",
                {
                  css: { cursor: "pointer", position: "relative" },
                  onClick: () => g(m.value),
                  children: [
                    /* @__PURE__ */ x("div", { css: { paddingBottom: "100%", width: "100%" } }),
                    /* @__PURE__ */ x(
                      "img",
                      {
                        alt: "Text Effect",
                        css: {
                          width: "100%",
                          height: "100%",
                          position: "absolute",
                          left: 0,
                          top: 0,
                          borderRadius: 4,
                          boxShadow: m.value === h ? "0 0 0 2px #3d8eff,inset 0 0 0 2px #fff" : "0 0 0 1px rgba(43,59,74,.3)",
                          ":hover": {
                            boxShadow: "00 0 0 2px #3d8eff,inset 0 0 0 2px #fff"
                          }
                        },
                        src: m.img
                      }
                    )
                  ]
                }
              ),
              /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    textAlign: "center",
                    marginTop: 4,
                    lineHeight: "20px",
                    textTransform: "capitalize"
                  },
                  children: m.value
                }
              )
            ] }, m.value)),
            p && /* @__PURE__ */ x(
              "div",
              {
                css: {
                  gridRow: `${Math.ceil(
                    (1 + hf(t).findIndex(
                      (m) => m.value === h
                    )) / 3
                  ) + 1} / auto`,
                  gridColumn: "1/-1",
                  padding: "8px 0"
                },
                children: /* @__PURE__ */ x(
                  "div",
                  {
                    css: {
                      display: "grid",
                      rowGap: 8
                    },
                    children: Object.entries(p).map(([m, w]) => /* @__PURE__ */ W(Tt, { children: [
                      m !== "color" && /* @__PURE__ */ x(
                        Hi,
                        {
                          defaultValue: w,
                          label: m,
                          max: m === "direction" ? 180 : 100,
                          min: m === "direction" ? -180 : 0,
                          onChange: (b) => {
                            v(m, b);
                          }
                        }
                      ),
                      m === "color" && /* @__PURE__ */ W("div", { css: { display: "flex", alignItems: "center" }, children: [
                        /* @__PURE__ */ x(
                          "div",
                          {
                            css: {
                              flexGrow: 1,
                              fontSize: 14,
                              textTransform: "capitalize",
                              whiteSpace: "nowrap"
                            },
                            children: "Color"
                          }
                        ),
                        /* @__PURE__ */ x("div", { ref: r, css: { width: 32, height: 32 }, children: /* @__PURE__ */ x(
                          qs,
                          {
                            color: w,
                            selected: null,
                            onClick: () => o(!0)
                          }
                        ) }),
                        /* @__PURE__ */ x(
                          gr,
                          {
                            anchorEl: r.current,
                            open: i,
                            placement: "bottom-end",
                            onClose: () => o(!1),
                            children: /* @__PURE__ */ x("div", { css: { padding: 16, width: 280 }, children: /* @__PURE__ */ x(
                              ec,
                              {
                                color: new Nt(
                                  w || "#f25022"
                                ).toHex(),
                                onChange: (b) => {
                                  v(
                                    m,
                                    pf(b)
                                  );
                                }
                              }
                            ) })
                          }
                        )
                      ] })
                    ] }, m))
                  }
                )
              }
            )
          ]
        }
      )
    ] })
  ] });
}, yP = Yt(
  vP
), wP = [
  6,
  8,
  10,
  12,
  14,
  16,
  18,
  21,
  24,
  28,
  32,
  36,
  42,
  48,
  56,
  64,
  72,
  80,
  88,
  96,
  104,
  120,
  144
], bP = ({ layers: n }) => {
  const e = ge(null), t = ge(null), r = ge(null), [i, o] = Le(!1), { selectedLayers: a, selectedLayerIds: l } = rn(), [u, d] = Le(!1), { usedFonts: h } = Jc(), [
    {
      isBold: p,
      isItalic: g,
      isUnderline: v,
      isUppercase: m,
      isBulletList: w,
      isOrderedList: b,
      ...C
    },
    M
  ] = Le(() => {
    const P = {
      fontFamily: {},
      fontSize: {},
      color: {},
      isBold: !0,
      isItalic: !0,
      isUnderline: !0,
      isUppercase: !0,
      isBulletList: !0,
      isOrderedList: !0,
      lineHeight: {},
      letterSpacing: {}
    };
    return n.forEach((A) => {
      P.fontFamily[A.id] = A.data.props.fonts, P.fontSize[A.id] = A.data.props.fontSizes, P.color[A.id] = A.data.props.colors;
      const z = A.data.editor;
      z && (pt(z.state, "bold") || (P.isBold = !1), pt(z.state, "italic") || (P.isItalic = !1), pt(z.state, "underline") || (P.isUnderline = !1), pt(z.state, null, { indent: 1, listType: "" }) || (P.isBulletList = !1), pt(z.state, null, { indent: 1, listType: "ordered" }) || (P.isOrderedList = !1), pt(z.state, null, { textTransform: "uppercase" }) || (P.isUppercase = !1), pt(z.state, null, { textTransform: "uppercase" }) || (P.isUppercase = !1));
    }), P;
  }), { actions: k, activePage: D, textEditor: T, editingLayer: R, sidebar: _, fontList: Z } = je((P) => ({
    activePage: P.activePage,
    sidebar: P.sidebar,
    fontList: P.fontList,
    textEditor: P.textEditor,
    editingLayer: P.textEditor ? P.pages[P.textEditor.pageIndex].layers[P.textEditor.layerId] : null
  }));
  be(() => {
    const P = {
      fontFamily: {},
      fontSize: {},
      color: {},
      isBold: !0,
      isItalic: !0,
      isUnderline: !0,
      isUppercase: !0,
      isBulletList: !0,
      isOrderedList: !0,
      lineHeight: {},
      letterSpacing: {}
    };
    o(!1), d(!1), a.forEach((A) => {
      const z = A.data.editor;
      if (z) {
        const H = ki(z.state.doc);
        P.fontFamily[A.id] = Te.uniqBy(
          Ws(H).map((ce) => ({
            name: ce,
            fonts: ie[ce] || ee[ce]
          })),
          "name"
        ), P.fontSize[A.id] = lo(H), P.lineHeight[A.id] = df(H), P.letterSpacing[A.id] = ff(H), P.color[A.id] = co(
          H,
          Ys(z.state.doc)
        ), pt(z.state, "bold") || (P.isBold = !1), pt(z.state, "italic") || (P.isItalic = !1), pt(z.state, "underline") || (P.isUnderline = !1), pt(z.state, "bulletList") || (P.isBulletList = !1), pt(z.state, "orderedList") || (P.isOrderedList = !1), pt(z.state, null, { textTransform: "uppercase" }) || (P.isUppercase = !1), M(P);
      }
    });
  }, [JSON.stringify(l)]);
  const { fontFamily: K, fontSize: $, color: F, lineHeight: Y, letterSpacing: Q } = pe(() => n.reduce(
    (P, A) => {
      if (C.fontFamily[A.id]) {
        const z = A.data.props;
        P.fontFamily.push(...C.fontFamily[A.id]), P.fontFamily = Te.uniqBy(P.fontFamily, "name"), C.fontSize[A.id] && (P.fontSize = Te.uniq(
          P.fontSize.concat(
            C.fontSize[A.id].map(
              (H) => Math.round(H * z.scale * 10) / 10
            )
          )
        )), P.color = Te.uniq(P.color.concat(C.color[A.id])), P.lineHeight = Te.uniq(
          P.lineHeight.concat(C.lineHeight[A.id])
        ), P.letterSpacing = Te.uniq(
          P.letterSpacing.concat(C.letterSpacing[A.id])
        );
      }
      return P;
    },
    {
      fontSize: [],
      fontFamily: [],
      color: [],
      lineHeight: [],
      letterSpacing: []
    }
  ), [C, a]);
  be(() => {
    t.current && ($.length === 1 ? t.current.value = $[0] + "" : t.current.value = "--");
  }, [$]);
  const ee = pe(() => Z.reduce((P, A) => (P[A.name] = A.fonts, P), {}), [Z]), ie = pe(() => h.reduce((P, A) => (P[A.name] = A.fonts, P), {}), [h]), re = Ie(
    (P) => {
      var z;
      const A = {
        fontFamily: {},
        fontSize: {},
        color: {},
        isBold: !0,
        isItalic: !0,
        isUnderline: !0,
        isUppercase: !0,
        isBulletList: !0,
        isOrderedList: !0,
        lineHeight: {},
        letterSpacing: {}
      };
      if (R) {
        A.fontFamily[R.id] = [], A.fontSize[R.id] = [], A.color[R.id] = [], A.lineHeight[R.id] = [], A.letterSpacing[R.id] = [];
        const H = T == null ? void 0 : T.editor;
        if (H) {
          (z = R.data.editor) == null || z.updateState(H.state);
          const ce = R.data.props;
          eP(H.state) && (b1(ce.colors[0])(H.state, H.dispatch), Ei(ce.fontSizes[0])(H.state, H.dispatch), Wl(ce.fonts[0].name)(H.state, H.dispatch), H.focus());
          const fe = new WebKitCSSMatrix(
            ut({
              position: R.data.props.position,
              rotate: R.data.props.rotate
            })
          ), _e = oi(
            R.data.props.boxSize,
            fe,
            R.data.props.position
          ), tt = oi(
            {
              width: R.data.props.boxSize.width,
              height: H.dom.clientHeight * R.data.props.scale
            },
            fe,
            R.data.props.position
          ), { changeX: Mt, changeY: Pe } = y0(
            _e,
            tt,
            "bottomRight"
          );
          if (H.state.selection.empty) {
            const Ae = (H.state.storedMarks || H.state.selection.$from.marks()).reduce((ot, Ct) => (Object.entries(Ct.attrs).forEach(([Fe, De]) => {
              ot[Fe] || (ot[Fe] = []), ot[Fe].push(De);
            }), ot), {});
            A.color[R.id] = Te.uniq(co({}, Ae));
          }
          let qe = null;
          if (H.state.doc.nodesBetween(
            H.state.selection.ranges[0].$from.pos,
            H.state.selection.ranges[0].$to.pos,
            (ve) => {
              const Ae = tP(ve);
              if (ve.isBlock) {
                const ot = Ws(Ae).map((Ct) => ({
                  name: Ct,
                  fonts: ie[Ct] || ee[Ct]
                }));
                A.fontFamily[R.id].push(...ot), A.fontFamily[R.id] = Te.uniqBy(
                  A.fontFamily[R.id],
                  "name"
                ), A.fontSize[R.id] = Te.uniq(
                  A.fontSize[R.id].concat(lo(Ae))
                ), A.lineHeight[R.id] = Te.uniq(
                  A.lineHeight[R.id].concat(
                    df(Ae)
                  )
                ), A.letterSpacing[R.id] = Te.uniq(
                  A.letterSpacing[R.id].concat(
                    ff(Ae)
                  )
                ), qe = co(Ae, C1(ve));
              }
              if (ve.isText && !H.state.selection.empty) {
                let ot = co(Ae, C1(ve));
                ot.length === 0 && qe && (ot = qe), A.color[R.id] = Te.uniq(
                  A.color[R.id].concat(ot)
                ), qe = null;
              }
            }
          ), pt(H.state, "bold") || (A.isBold = !1), pt(H.state, "italic") || (A.isItalic = !1), pt(H.state, "underline") || (A.isUnderline = !1), pt(H.state, null, { indent: 1, listType: "" }) || (A.isBulletList = !1), pt(H.state, null, { indent: 1, listType: "ordered" }) || (A.isOrderedList = !1), pt(H.state, null, { textTransform: "uppercase" }) || (A.isUppercase = !1), M(A), P === "content") {
            const ve = ki(H.state.doc);
            k.history.merge().setProp(D, R.id, {
              text: H.dom.innerHTML,
              fontSizes: lo(ve),
              fonts: Te.uniqBy(
                Ws(ve).map((Ae) => ({
                  name: Ae,
                  fonts: ie[Ae] || ee[Ae]
                })),
                "name"
              ),
              colors: co(ve, Ys(H.state.doc)),
              boxSize: {
                width: ce.boxSize.width,
                height: H.dom.clientHeight * ce.scale
              },
              position: {
                x: ce.position.x - Mt,
                y: ce.position.y - Pe
              }
            }), k.setControlBox({
              boxSize: {
                width: ce.boxSize.width,
                height: H.dom.clientHeight * ce.scale
              },
              position: {
                x: ce.position.x - Mt,
                y: ce.position.y - Pe
              },
              scale: ce.scale,
              rotate: ce.rotate
            });
          }
        }
      } else {
        const H = a.reduce((ce, fe) => {
          const _e = fe.data.editor;
          if (_e) {
            const tt = fe.data.props, Mt = ki(_e.state.doc);
            if (A.fontFamily[fe.id] = Te.uniqBy(
              Ws(Mt).map((Pe) => ({
                name: Pe,
                fonts: ie[Pe] || ee[Pe]
              })),
              "name"
            ), A.fontSize[fe.id] = lo(Mt), A.lineHeight[fe.id] = df(Mt), A.letterSpacing[fe.id] = ff(Mt), A.color[fe.id] = co(
              Mt,
              Ys(_e.state.doc)
            ), pt(_e.state, "bold") || (A.isBold = !1), pt(_e.state, "italic") || (A.isItalic = !1), pt(_e.state, "underline") || (A.isUnderline = !1), pt(_e.state, "bulletList") || (A.isBulletList = !1), pt(_e.state, "orderedList") || (A.isOrderedList = !1), pt(_e.state, null, { textTransform: "uppercase" }) || (A.isUppercase = !1), P === "content") {
              const Pe = Te.isEqual(
                tt.fontSizes,
                A.fontSize[fe.id]
              ) ? tt.scale : 1, qe = document.createElement("div");
              qe.append(_e.dom);
              const { clientHeight: ve } = D1(
                qe,
                fe.data.props.boxSize.width,
                Pe
              ), Ae = new WebKitCSSMatrix(
                ut({
                  position: fe.data.props.position,
                  rotate: fe.data.props.rotate
                })
              ), ot = oi(
                fe.data.props.boxSize,
                Ae,
                fe.data.props.position
              ), Ct = oi(
                {
                  width: fe.data.props.boxSize.width,
                  height: ve
                },
                Ae,
                fe.data.props.position
              ), { changeX: Fe, changeY: De } = y0(
                ot,
                Ct,
                "bottomRight"
              );
              k.history.merge().setProp(D, fe.id, {
                text: _e.dom.innerHTML,
                fontSizes: A.fontSize[fe.id],
                fonts: A.fontFamily[fe.id],
                colors: A.color[fe.id],
                scale: Pe,
                boxSize: {
                  width: fe.data.props.boxSize.width,
                  height: ve
                },
                position: {
                  x: fe.data.props.position.x - Fe,
                  y: fe.data.props.position.y - De
                }
              }), ce[fe.id] = {
                ...fe.data.props,
                boxSize: {
                  width: fe.data.props.boxSize.width,
                  height: ve
                },
                position: {
                  x: fe.data.props.position.x - Fe,
                  y: fe.data.props.position.y - De
                }
              };
            }
          } else
            ce[fe.id] = fe.data.props;
          return ce;
        }, {});
        M(A), k.setControlBox(oa(H));
      }
    },
    [
      JSON.stringify(
        a.map((P) => ({
          id: P.id,
          boxSize: P.data.props.boxSize,
          position: P.data.props.position,
          rotate: P.data.props.rotate,
          scale: P.data.props.scale
        }))
      ),
      R,
      T == null ? void 0 : T.editor,
      k,
      ee
    ]
  ), oe = Ie(() => {
    re("selection");
  }, [re]), de = Ie(() => {
    re("content");
  }, [re]);
  be(() => {
    var P, A;
    return (P = T == null ? void 0 : T.editor) == null || P.events.on("selectionUpdate", oe), (A = T == null ? void 0 : T.editor) == null || A.events.on("update", de), () => {
      var z, H;
      (z = T == null ? void 0 : T.editor) == null || z.events.off("selectionUpdate", oe), (H = T == null ? void 0 : T.editor) == null || H.events.off("update", de);
    };
  }, [T == null ? void 0 : T.editor, re]), be(() => (n.forEach((P) => {
    var A;
    (A = P.data.editor) == null || A.events.on("update", de);
  }), () => {
    n.forEach((P) => {
      var A;
      (A = P.data.editor) == null || A.events.off("update", de);
    });
  }), [JSON.stringify(n.map((P) => P.id)), re]);
  const se = Ie((P) => {
    const A = ["Bold", "Bold_Italic", "Italic"];
    return P.forEach((z) => {
      A.forEach((H, ce) => {
        z.fonts.find((fe) => fe.style === H) || A.splice(ce, 1);
      });
    }), A;
  }, []), we = (P) => {
    if (k.history.new(), R) {
      const A = T == null ? void 0 : T.editor;
      if (A) {
        Wl(P.name)(A.state, A.dispatch);
        const z = se([P]);
        if (z.includes("Bold") || Vd(A.state, A.dispatch), z.includes("Italic") || Wd(A.state, A.dispatch), A.focus(), R.data.editor) {
          const H = R.data.editor, { $from: ce, $to: fe } = A.state.selection;
          un({ from: ce.pos, to: fe.pos })(
            H.state,
            H.dispatch
          ), Wl(P.name)(H.state, H.dispatch);
          const _e = se([P]);
          _e.includes("Bold") || Vd(H.state, H.dispatch), _e.includes("Italic") || Wd(H.state, H.dispatch);
        }
      }
    } else
      n.forEach((A) => {
        const z = A.data.editor;
        if (z) {
          Cr(z.state, z.dispatch), Wl(P.name)(z.state, z.dispatch);
          const H = se([P]);
          H.includes("Bold") || Vd(z.state, z.dispatch), H.includes("Italic") || Wd(z.state, z.dispatch);
        }
      });
  }, Oe = (P) => {
    n.forEach((A) => {
      const z = A.data.editor;
      if (z) {
        const H = z.state.doc;
        z.state.doc.nodesBetween(0, H.content.size, (ce, fe) => {
          if (ce.isBlock) {
            const _e = ki(ce), tt = lo(_e);
            if (tt.length > 0) {
              const Mt = A.data.props.scale || 1;
              Vs(fe)(z.state, z.dispatch), Ei(
                Math.round((tt[0] * Mt + P) * 1e3) / 1e3
              )(z.state, z.dispatch);
            }
          }
        });
      }
    });
  }, le = (P) => {
    k.history.new();
    const A = Math.max(Math.min(800, P), 8);
    if (R) {
      const z = T == null ? void 0 : T.editor;
      if (z) {
        const H = Ei(
          Math.round(A / R.data.props.scale * 1e3) / 1e3
        );
        if (H(z.state, z.dispatch), z.focus(), R.data.editor) {
          const ce = R.data.editor, { $from: fe, $to: _e } = z.state.selection;
          un({ from: fe.pos, to: _e.pos })(
            ce.state,
            ce.dispatch
          ), H(ce.state, ce.dispatch);
        }
      }
    } else
      n.forEach((z) => {
        const H = z.data.editor;
        H && (Cr(H.state, H.dispatch), Ei(A)(H.state, H.dispatch));
      });
    d(!1);
  }, Ce = () => {
    if (k.history.new(), R) {
      const P = T == null ? void 0 : T.editor;
      if (P) {
        const A = {
          from: P.state.selection.ranges[0].$from.pos,
          to: P.state.selection.ranges[0].$to.pos
        };
        P.state.doc.nodesBetween(A.from, A.to, (z, H) => {
          if (z.isBlock) {
            const ce = ki(z), [fe] = lo(ce), _e = R.data.props.scale;
            Vs(H)(P.state, P.dispatch), Ei(Math.round((fe + 1 / _e) * 1e3) / 1e3)(
              P.state,
              P.dispatch
            );
            const tt = R.data.editor;
            tt && (Vs(H)(tt.state, tt.dispatch), Ei(Math.round((fe + 1 / _e) * 1e3) / 1e3)(
              tt.state,
              tt.dispatch
            ));
          }
        }), un(A)(P.state, P.dispatch), P.focus();
      }
    } else
      Oe(1);
  }, Ne = () => {
    if (k.history.new(), R) {
      const P = T == null ? void 0 : T.editor;
      if (P) {
        const A = {
          from: P.state.selection.ranges[0].$from.pos,
          to: P.state.selection.ranges[0].$to.pos
        };
        P.state.doc.nodesBetween(A.from, A.to, (z, H) => {
          if (z.isBlock) {
            const ce = ki(z), [fe] = lo(ce), _e = R.data.props.scale;
            Vs(H)(P.state, P.dispatch), Ei(Math.round((fe - 1 / _e) * 1e3) / 1e3)(
              P.state,
              P.dispatch
            );
            const tt = R.data.editor;
            tt && (Vs(H)(tt.state, tt.dispatch), Ei(Math.round((fe - 1 / _e) * 1e3) / 1e3)(
              tt.state,
              tt.dispatch
            ));
          }
        }), un(A)(P.state, P.dispatch), P.focus();
      }
    } else
      Oe(-1);
  }, me = pe(() => {
    if (!F)
      return {};
    if (F.length === 1 && new Nt(F[0]).white() === 100)
      return {
        backgroundImage: "linear-gradient(to right, rgb(255, 0, 0) 0%, rgb(255, 255, 0) 17%, rgb(0, 255, 0) 33%, rgb(0, 255, 255) 50%, rgb(0, 0, 255) 67%, rgb(255, 0, 255) 83%, rgb(255, 0, 0) 100%)"
      };
    const P = 100 / F.length;
    return {
      backgroundImage: F.map((A) => `linear-gradient(to right, ${A}, ${A})`).join(", "),
      backgroundSize: F.map((A, z) => `${P * (z + 1)}%`).join(", "),
      boxShadow: "inset 0 0 0 1px rgba(57,76,96,.15)"
    };
  }, [F]), U = Te.throttle((P) => {
    if (P)
      if (R) {
        const A = T == null ? void 0 : T.editor;
        if (A) {
          const z = w1(P);
          if (z(A.state, A.dispatch), A.focus(), R.data.editor) {
            const H = R.data.editor, { $from: ce, $to: fe } = A.state.selection;
            un({ from: ce.pos, to: fe.pos })(
              H.state,
              H.dispatch
            ), z(H.state, H.dispatch);
          }
        }
      } else
        n.forEach((A) => {
          const z = A.data.editor;
          if (z) {
            const H = ki(z.state.doc);
            Cr(z.state, z.dispatch), w1(P)(z.state, z.dispatch), b1(P)(z.state, z.dispatch), k.history.throttle(2e3).setProp(D, A.id, {
              colors: co(H, Ys(z.state.doc))
            });
          }
        });
  }, 16), ae = (P) => {
    if (k.history.new(), R) {
      const A = T == null ? void 0 : T.editor;
      if (A) {
        if (P === "BOLD") {
          const z = R.data.props.fonts.reduce((ce, fe) => (ce[fe.name] = fe.fonts, ce), {});
          let H = !0;
          if (A.state.doc.nodesBetween(
            A.state.selection.ranges[0].$from.pos,
            A.state.selection.ranges[0].$to.pos,
            (ce) => {
              const fe = ki(ce);
              Ws(fe).every(
                (Mt) => z[Mt] && z[Mt].find((Pe) => Pe.style === "Bold")
              ) || (H = !1);
            }
          ), H && (wc(A.state, A.dispatch), A.focus(), R.data.editor)) {
            const ce = R.data.editor, { $from: fe, $to: _e } = A.state.selection;
            un({ from: fe.pos, to: _e.pos })(
              ce.state,
              ce.dispatch
            ), wc(ce.state, ce.dispatch);
          }
        } else if (P === "ITALIC") {
          if (bc(A.state, A.dispatch), A.focus(), R.data.editor) {
            const z = R.data.editor, { $from: H, $to: ce } = A.state.selection;
            un({ from: H.pos, to: ce.pos })(
              z.state,
              z.dispatch
            ), bc(z.state, z.dispatch);
          }
        } else if (P === "UNDERLINE") {
          if (x1(A.state, A.dispatch), A.focus(), R.data.editor) {
            const z = R.data.editor, { $from: H, $to: ce } = A.state.selection;
            un({ from: H.pos, to: ce.pos })(
              z.state,
              z.dispatch
            ), x1(z.state, z.dispatch);
          }
        } else if (P === "UPPERCASE") {
          const z = uf(
            pt(A.state, null, { textTransform: "uppercase" }) ? void 0 : "uppercase"
          );
          if (z(A.state, A.dispatch), A.focus(), R.data.editor) {
            const H = R.data.editor, { $from: ce, $to: fe } = A.state.selection;
            un({ from: ce.pos, to: fe.pos })(
              H.state,
              H.dispatch
            ), z(H.state, H.dispatch);
          }
        }
      }
    } else
      n.forEach((A) => {
        const z = A.data.editor;
        z && (Cr(z.state, z.dispatch), P === "BOLD" ? p ? LD(z.state, z.dispatch) : PD(z.state, z.dispatch) : P === "ITALIC" ? g ? _D(z.state, z.dispatch) : ND(z.state, z.dispatch) : P === "UNDERLINE" ? v ? KL(z.state, z.dispatch) : XL(z.state, z.dispatch) : P === "UPPERCASE" && (m ? uf()(z.state, z.dispatch) : uf("uppercase")(z.state, z.dispatch)));
      });
  }, G = (P) => {
    k.history.new();
    const A = T == null ? void 0 : T.editor;
    if (R && A) {
      if (cf(P)(A.state, A.dispatch), A.focus(), R.data.editor) {
        const z = R.data.editor, { $from: H, $to: ce } = A.state.selection;
        un({ from: H.pos, to: ce.pos })(
          z.state,
          z.dispatch
        ), cf(P)(z.state, z.dispatch);
      }
    } else
      n.forEach((z) => {
        const H = z.data.editor;
        H && (Cr(H.state, H.dispatch), cf(P)(H.state, H.dispatch));
      });
  }, xe = (P) => {
    k.history.new();
    const A = T == null ? void 0 : T.editor;
    if (R && A) {
      if (sf(P)(A.state, A.dispatch), A.focus(), R.data.editor) {
        const z = R.data.editor, { $from: H, $to: ce } = A.state.selection;
        un({ from: H.pos, to: ce.pos })(
          z.state,
          z.dispatch
        ), sf(P)(z.state, z.dispatch);
      }
    } else
      n.forEach((z) => {
        const H = z.data.editor;
        H && (Cr(H.state, H.dispatch), sf(P)(H.state, H.dispatch));
      });
  }, ye = (P) => {
    k.history.new();
    const A = T == null ? void 0 : T.editor;
    if (R && A) {
      if (af(P)(A.state, A.dispatch), A.focus(), R.data.editor) {
        const z = R.data.editor, { $from: H, $to: ce } = A.state.selection;
        un({ from: H.pos, to: ce.pos })(
          z.state,
          z.dispatch
        ), af(P)(z.state, z.dispatch);
      }
    } else
      n.forEach((z) => {
        const H = z.data.editor;
        H && (Cr(H.state, H.dispatch), af(P)(H.state, H.dispatch));
      });
  }, Je = () => {
    if (k.history.new(), R) {
      const P = T == null ? void 0 : T.editor;
      if (P) {
        const A = pt(P.state, null, {
          indent: 1,
          listType: ""
        });
        if (of(A ? 0 : 1)(P.state, P.dispatch), P.focus(), R.data.editor) {
          const z = R.data.editor, { $from: H, $to: ce } = P.state.selection;
          un({ from: H.pos, to: ce.pos })(
            z.state,
            z.dispatch
          ), of(A ? 0 : 1)(
            z.state,
            z.dispatch
          );
        }
      }
    } else {
      const P = n.every((A) => {
        const z = A.data.editor;
        if (z)
          return Cr(z.state, z.dispatch), pt(z.state, null, { indent: 1, listType: "" });
      });
      n.forEach((A) => {
        const z = A.data.editor;
        z && of(P ? 0 : 1)(z.state, z.dispatch);
      });
    }
  }, te = () => {
    if (k.history.new(), R) {
      const P = T == null ? void 0 : T.editor;
      if (P) {
        const A = pt(P.state, null, {
          indent: 1,
          listType: "ordered"
        });
        if (lf(A ? 0 : 1)(P.state, P.dispatch), P.focus(), R.data.editor) {
          const z = R.data.editor, { $from: H, $to: ce } = P.state.selection;
          un({ from: H.pos, to: ce.pos })(
            z.state,
            z.dispatch
          ), lf(A ? 0 : 1)(
            z.state,
            z.dispatch
          );
        }
      }
    } else {
      const P = n.every((A) => {
        const z = A.data.editor;
        if (z)
          return Cr(z.state, z.dispatch), pt(z.state, null, {
            indent: 1,
            listType: "ordered"
          });
      });
      n.forEach((A) => {
        const z = A.data.editor;
        z && (Cr(z.state, z.dispatch), lf(P ? 0 : 1)(z.state, z.dispatch));
      });
    }
  }, $e = (P) => {
    const A = t.current, z = A.value;
    P.key.toLowerCase() === "enter" ? (t.current && le(+parseFloat(z).toFixed(1)), A.blur()) : P.key.match(/^[0-9]|./) || P.preventDefault();
  }, Be = () => {
    const A = t.current.value;
    A !== "--" && A !== $[0] + "" && t.current && le(+parseFloat(A).toFixed(1));
  }, vt = () => {
    k.openTextEditor(D, n[0].id);
  };
  return /* @__PURE__ */ W(Tt, { children: [
    n.length === 1 && /* @__PURE__ */ x(
      Dt,
      {
        css: {
          display: "none",
          "@media (max-width: 900px)": {
            fontSize: 24,
            display: "flex"
          }
        },
        onClick: vt,
        children: /* @__PURE__ */ x(BL, {})
      }
    ),
    /* @__PURE__ */ x("div", { children: /* @__PURE__ */ W(
      "div",
      {
        css: {
          border: "1px solid rgba(43,59,74,.3)",
          height: 32,
          padding: "0 2px",
          borderRadius: 4,
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          cursor: "pointer",
          background: _ === "FONT_FAMILY" ? "rgba(57,76,96,.15)" : "#fff"
        },
        onClick: () => k.setSidebar("FONT_FAMILY"),
        children: [
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                padding: 4,
                textOverflow: "ellipsis",
                whiteSpace: "nowrap",
                fontSize: 14
              },
              children: K.length === 1 ? K[0].name : "Multiple Fonts"
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                width: 24,
                height: 24,
                display: "flex",
                justifyContent: "center",
                alignItems: "center",
                fontSize: 16
              },
              children: /* @__PURE__ */ x(Ww, {})
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ x("div", { children: /* @__PURE__ */ W(
      "div",
      {
        css: {
          border: "1px solid rgba(43,59,74,.3)",
          display: "flex",
          alignItems: "center",
          justifyContent: "space-between"
        },
        children: [
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                width: 32,
                height: 32,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                cursor: "pointer",
                fontSize: 12
              },
              onClick: Ne,
              children: /* @__PURE__ */ x(WL, {})
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              ref: e,
              css: {
                width: 32,
                height: 32,
                borderLeft: "1px solid rgba(43,59,74,.3)",
                borderRight: "1px solid rgba(43,59,74,.3)"
              },
              onClick: () => d(!0),
              children: /* @__PURE__ */ x(
                "input",
                {
                  ref: t,
                  css: {
                    width: 28,
                    height: "100%",
                    outline: 0,
                    border: 0,
                    textAlign: "center"
                  },
                  onBlur: Be,
                  onClick: () => {
                    var P;
                    return (P = t.current) == null ? void 0 : P.select();
                  },
                  onKeyDown: $e
                }
              )
            }
          ),
          /* @__PURE__ */ x(
            gr,
            {
              anchorEl: t.current,
              open: u,
              placement: "bottom",
              onClose: () => d(!1),
              children: /* @__PURE__ */ x("div", { css: { maxHeight: "50vh", overflowY: "auto" }, children: wP.map((P) => /* @__PURE__ */ W(
                "div",
                {
                  css: {
                    height: 40,
                    minWidth: 120,
                    padding: "0 8px",
                    display: "flex",
                    alignItems: "center",
                    cursor: "pointer",
                    ":hover": {
                      backgroundColor: "rgba(64,87,109,.07)"
                    }
                  },
                  onClick: () => le(P),
                  children: [
                    /* @__PURE__ */ x("div", { css: { flexGrow: 1 }, children: P }),
                    $.includes(P) && /* @__PURE__ */ x("div", { css: { fontSize: 24, flexShrink: 0 }, children: /* @__PURE__ */ x(Ca, {}) })
                  ]
                },
                P
              )) })
            }
          ),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                width: 32,
                height: 32,
                display: "flex",
                alignItems: "center",
                justifyContent: "center",
                cursor: "pointer",
                fontSize: 12
              },
              onClick: Ce,
              children: /* @__PURE__ */ x(ua, {})
            }
          )
        ]
      }
    ) }),
    /* @__PURE__ */ W(
      "div",
      {
        css: {
          position: "relative",
          display: "flex",
          justifyContent: "center",
          fontSize: 24
        },
        onClick: () => k.setSidebar("CHOOSING_COLOR"),
        children: [
          /* @__PURE__ */ x(YL, {}),
          /* @__PURE__ */ x(
            "div",
            {
              css: {
                bottom: 1,
                left: "5%",
                width: "90%",
                position: "absolute"
              },
              children: /* @__PURE__ */ x(
                "div",
                {
                  css: {
                    paddingTop: "22.2222%",
                    height: 0,
                    position: "relative",
                    width: "100%"
                  },
                  children: /* @__PURE__ */ x(
                    "span",
                    {
                      css: {
                        borderRadius: 4,
                        overflow: "hidden",
                        position: "absolute",
                        inset: 0,
                        backgroundRepeat: "no-repeat",
                        ...me
                      }
                    }
                  )
                }
              )
            }
          )
        ]
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        disabled: !se(K).includes("Bold"),
        isActive: p,
        onClick: () => ae("BOLD"),
        children: /* @__PURE__ */ x(NL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        disabled: !se(K).includes("Italic"),
        isActive: g,
        onClick: () => ae("ITALIC"),
        children: /* @__PURE__ */ x(qL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        isActive: v,
        onClick: () => ae("UNDERLINE"),
        children: /* @__PURE__ */ x(GL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        isActive: m,
        onClick: () => ae("UPPERCASE"),
        children: /* @__PURE__ */ x(HL, {})
      }
    ),
    /* @__PURE__ */ x(
      "div",
      {
        css: { height: 24, width: "1px", background: "rgba(57,76,96,.15)" }
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        onClick: () => G("left"),
        children: /* @__PURE__ */ x(ZL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        onClick: () => G("center"),
        children: /* @__PURE__ */ x($L, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        onClick: () => G("right"),
        children: /* @__PURE__ */ x(jL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        onClick: () => G("justify"),
        children: /* @__PURE__ */ x(UL, {})
      }
    ),
    /* @__PURE__ */ x(
      "div",
      {
        css: { height: 24, width: "1px", background: "rgba(57,76,96,.15)" }
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        isActive: w,
        onClick: Je,
        children: /* @__PURE__ */ x(FL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        css: { fontSize: 24 },
        isActive: b,
        onClick: te,
        children: /* @__PURE__ */ x(VL, {})
      }
    ),
    /* @__PURE__ */ x(
      Dt,
      {
        ref: r,
        css: { fontSize: 24 },
        onClick: () => o(!0),
        children: /* @__PURE__ */ x(zL, {})
      }
    ),
    /* @__PURE__ */ x(
      gr,
      {
        anchorEl: r.current,
        offsets: {
          "bottom-end": { x: 0, y: 8 }
        },
        open: i,
        placement: "bottom-end",
        onClose: () => o(!1),
        children: /* @__PURE__ */ W("div", { css: { padding: 16, minWidth: 220, display: "grid", rowGap: 8 }, children: [
          /* @__PURE__ */ x(
            Hi,
            {
              label: "Letter spacing",
              max: 800,
              min: -200,
              value: Q[0] * 1e3 || 0,
              onChange: (P) => xe(P / 1e3)
            }
          ),
          /* @__PURE__ */ x(
            Hi,
            {
              label: "Line spacing",
              max: 2.5,
              min: 0.5,
              step: 0.01,
              value: Y[0] || 1.4,
              onChange: ye
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ x(
      "div",
      {
        css: { height: 24, width: "1px", background: "rgba(57,76,96,.15)" }
      }
    ),
    /* @__PURE__ */ x(Dt, { onClick: () => k.setSidebar("TEXT_EFFECT"), children: /* @__PURE__ */ x("span", { css: { padding: "0 4px" }, children: "Effects" }) }),
    /* @__PURE__ */ x(
      "div",
      {
        css: { height: 24, width: "1px", background: "rgba(57,76,96,.15)" }
      }
    ),
    _ === "FONT_FAMILY" && /* @__PURE__ */ x(
      mP,
      {
        open: !0,
        selected: K,
        onChangeFontFamily: we
      }
    ),
    _ === "CHOOSING_COLOR" && /* @__PURE__ */ x(
      Hh,
      {
        open: !0,
        selected: F[0],
        onSelect: U
      }
    ),
    _ === "TEXT_EFFECT" && /* @__PURE__ */ x(yP, { open: !0 })
  ] });
}, DP = () => {
  const { selectedLayers: n, selectedLayerIds: e } = rn(), { actions: t, sidebar: r, isPageLocked: i } = je((p) => ({
    sidebar: p.sidebar,
    isPageLocked: p.pages[p.activePage] && p.pages[p.activePage].layers.ROOT.data.locked
  })), {
    rootLayer: o,
    textLayers: a,
    lineLayers: l,
    shapeLayers: u,
    svgLayers: d,
    frameLayers: h
  } = pe(() => n.reduce(
    (p, g) => (g.data.locked || (Fi(g) ? p.rootLayer = g : kh(g) ? p.svgLayers.push(g) : ui(g) ? p.textLayers.push(g) : xc(g) ? p.shapeLayers.push(g) : Vi(g) ? p.frameLayers.push(g) : Iw(g) && p.lineLayers.push(g)), p),
    {
      textLayers: [],
      lineLayers: [],
      shapeLayers: [],
      rootLayer: null,
      svgLayers: [],
      frameLayers: []
    }
  ), [n]);
  return be(() => {
    const p = [];
    r && r !== "LAYER_MANAGEMENT" && (n.forEach((g) => {
      p.push(g.data.type);
    }), (r && p.includes("Text") && !["FONT_FAMILY", "TEXT_EFFECT", "CHOOSING_COLOR"].includes(r) || r && (p.includes("Shape") || p.includes("Root")) && !["CHOOSING_COLOR"].includes(r)) && t.setSidebar());
  }, [r, e, t]), /* @__PURE__ */ x(
    "div",
    {
      css: {
        display: "flex",
        width: "100%",
        height: "100%",
        alignItems: "center",
        justifyContent: "space-between",
        fontSize: 14,
        fontWeight: 600,
        padding: "0 8px"
      },
      children: /* @__PURE__ */ W(
        "div",
        {
          css: {
            display: "grid",
            alignItems: "center",
            gridAutoFlow: "column",
            gridGap: 8,
            paddingRight: 20
          },
          children: [
            o && !i && /* @__PURE__ */ x(IL, { layer: o }),
            h.length > 0 && !i && /* @__PURE__ */ x(TL, { layers: h }),
            l.length > 0 && !i && /* @__PURE__ */ x(DL, { layers: l }),
            d.length === 1 && !i && /* @__PURE__ */ x(_L, { layer: d[0] }),
            u.length > 0 && !i && /* @__PURE__ */ x(PL, { layers: u }),
            a.length > 0 && !i && /* @__PURE__ */ x(bP, { layers: a }),
            /* @__PURE__ */ x(EL, {})
          ]
        }
      )
    }
  );
}, IP = () => {
  const n = ge(null), [e, t] = Le(!1), { actions: r, activePage: i, totalPages: o, scale: a } = je((u) => ({
    activePage: u.activePage,
    totalPages: u.pages.length,
    scale: u.scale
  })), l = (u) => {
    r.setScale(u / 100);
  };
  return /* @__PURE__ */ W(
    "div",
    {
      css: {
        display: "flex",
        alignItems: "center",
        padding: "0 8px",
        fontWeight: 700
      },
      children: [
        /* @__PURE__ */ W("div", { css: { flexGrow: 1 }, children: [
          "Page ",
          i + 1,
          " / ",
          o
        ] }),
        /* @__PURE__ */ W(
          "div",
          {
            css: {
              flexShrink: 0,
              display: "grid",
              gridAutoFlow: "column",
              gridColumnGap: 8,
              alignItems: "center"
            },
            children: [
              /* @__PURE__ */ x("div", { css: { width: 200, paddingRight: 8 }, children: /* @__PURE__ */ x(
                Hi,
                {
                  hideInput: !0,
                  hideLabel: !0,
                  max: 500,
                  min: 10,
                  value: a * 100,
                  onChange: l
                }
              ) }),
              /* @__PURE__ */ x(
                Dt,
                {
                  ref: n,
                  onClick: () => t(!0),
                  children: /* @__PURE__ */ W("div", { css: { width: 48, textAlign: "center" }, children: [
                    Math.round(a * 100),
                    "%"
                  ] })
                }
              ),
              /* @__PURE__ */ x(
                gr,
                {
                  anchorEl: n.current,
                  open: e,
                  placement: "top-end",
                  onClose: () => t(!1),
                  children: /* @__PURE__ */ x("div", { css: { padding: "8px 0" }, children: [300, 200, 150, 100, 75, 50, 25, 10].map((u) => /* @__PURE__ */ W(
                    "div",
                    {
                      css: {
                        padding: "0 8px",
                        display: "flex",
                        height: 40,
                        minWidth: 100,
                        alignItems: "center",
                        cursor: "pointer",
                        ":hover": {
                          backgroundColor: "rgba(64,87,109,.07)"
                        }
                      },
                      onClick: () => {
                        r.setScale(u / 100), t(!1);
                      },
                      children: [
                        /* @__PURE__ */ W(
                          "span",
                          {
                            css: { padding: "0 8px", whiteSpace: "nowrap", flexGrow: 1 },
                            children: [
                              u,
                              "%"
                            ]
                          }
                        ),
                        u / 100 === a && /* @__PURE__ */ x(Ca, {})
                      ]
                    },
                    u
                  )) })
                }
              )
            ]
          }
        )
      ]
    }
  );
};
export {
  TP as DesignFrame,
  MP as Editor,
  DP as LayerSettings,
  IP as PageControl,
  RP as Preview,
  je as useEditor,
  gs as useLayer,
  rn as useSelectedLayers
};
